function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$2 && a2[z$2] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$1;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a2, b2) {
  return { $$typeof: l$2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$2;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$1 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$2:
          case n$2:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$1(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$1(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$2(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$1(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$1, forEach: function(a2, b2, e2) {
  S$1(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$1(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$1(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$1, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a2) {
  var b2 = M$1.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a2 }, _init: T$1 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a2();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$1.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$1.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$1.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$1.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$1.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$1.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$1.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$1.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$1.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$1.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$1.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$1.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$3.call(a2, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$1[a2] = new v$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$1[b2] = new v$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$1[a2] = new v$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa$1(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa$1
  );
  z$1[b2] = new v$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa$1);
  z$1[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa$1);
  z$1[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$1[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab$1(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab$1(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$1(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$1(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$1(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$1(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$1(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$1(190));
  }
  if (3 !== c2.tag)
    throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc$1(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd$1 = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd$1.transition;
  cd$1.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd$1.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd$1.transition;
  cd$1.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd$1.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$1, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$1, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$1 = null;
function Yc(a2, b2, c2, d2) {
  id$1 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$1 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de$1 = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re$1(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re$1, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$1(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a2, b2, c2) {
  if (H.current !== Vf)
    throw Error(p$1(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$1(108, Ra(a2) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$1(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng$1 = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng$1;
  kg[lg++] = mg;
  mg = a2;
  ng$1 = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng$1 = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$1(418));
      a2.flags = a2.flags & -4097 | 2;
      I = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I)
    return Fg(a2), I = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$1(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$1(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$1(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$1(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$1(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$1(284));
    if (!c2._owner)
      throw Error(p$1(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$1(174));
  return a2;
}
function Ih(a2, b2) {
  G(Gh, b2);
  G(Fh, a2);
  G(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E(Eh);
  G(Eh, b2);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(Fh, a2), G(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$1(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$1(301));
      f2 += 1;
      P = O = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = false;
  if (b2)
    throw Error(p$1(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a2 : P = P.next = a2;
  return P;
}
function di() {
  if (null === O) {
    var a2 = N.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O.next;
  var b2 = null === P ? N.memoizedState : P.next;
  if (null !== b2)
    P = b2, O = a2;
  else {
    if (null === a2)
      throw Error(p$1(310));
    O = a2;
    a2 = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N.memoizedState = P = a2 : P = P.next = a2;
  }
  return P;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N || null !== b2 && b2 === N;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N, e2 = ci();
  if (I) {
    if (void 0 === c2)
      throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R.identifierPrefix;
  if (I) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O ? b2.memoizedState = a2 : Di(b2, O.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G(M, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$1(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G(M, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$1(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G(M, M.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G(M, M.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(M, M.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$1(166));
          S(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D("cancel", d2);
              D("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D(lf[e2], d2);
              break;
            case "source":
              D("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d2
              );
              D("load", d2);
              break;
            case "details":
              D("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D("cancel", a2);
                D("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a2
                );
                D("load", a2);
                e2 = d2;
                break;
              case "details":
                D("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$1(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S(b2);
      return null;
    case 13:
      E(M);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$1(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return Rg(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(M);
      f2 = b2.memoizedState;
      if (null === f2)
        return S(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G(M, M.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
              return S(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E(M);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$1(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V = a2;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (F2) {
          W(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V = a2;
          break;
        }
        V = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U || Mj(c2, b2);
    case 6:
      var d2 = X, e2 = Yj;
      X = null;
      Zj(a2, b2, c2);
      X = d2;
      Yj = e2;
      null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
      break;
    case 4:
      d2 = X;
      e2 = Yj;
      X = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a2, b2, c2), U = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$1(160));
        ak(f2, g2, e2);
        X = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab$1(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$1(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a2), U = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g2;
        if ((U = k2) && !l2)
          for (V = e2; null !== V; )
            g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e2;
        Kj = h2;
        U = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function hk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok$5 = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk$1 = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$1(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== R)
    a2 === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a2, Z)), Ek(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc$1(a2, b2);
  var d2 = uc(a2, a2 === R ? Z : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$1(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R ? Z : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Kk();
    if (R !== a2 || Z !== b2)
      vk = null, Hj = B() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Qk(a2, uk$1, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk$1, vk), b2);
            break;
          }
          Qk(a2, uk$1, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk$1, vk), d2);
            break;
          }
          Qk(a2, uk$1, vk);
          break;
        case 5:
          Qk(a2, uk$1, vk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Ek(a2, B());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk$1, uk$1 = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk$1 ? uk$1 = a2 : uk$1.push.apply(uk$1, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K & 6))
    throw Error(p$1(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B()), c2;
  if (6 === c2)
    throw Error(p$1(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk$1, vk);
  Ek(a2, B());
  return null;
}
function Rk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b2 = K;
  K |= 1;
  var c2 = pk.transition, d2 = C;
  try {
    if (pk.transition = null, C = 1, a2)
      return a2();
  } finally {
    C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M);
          break;
        case 19:
          E(M);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a2;
  Y = a2 = wh(a2.current, null);
  Z = gj = b2;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk$1 = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N = null;
      Th = false;
      Uh = 0;
      ok$5.current = null;
      if (null === c2 || null === c2.return) {
        T = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T && (T = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Kk();
  if (R !== a2 || Z !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$1(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y = b2;
  ok$5.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$1(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$1(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R && (Y = R = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    ok$5.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K = h2;
    C = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C;
    try {
      pk.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V = a2.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a2.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V = u2;
          else
            b:
              for (g2 = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng$1, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$1(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$1(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$1(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$1(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl$1(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$1(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl$1(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$1(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl$1(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$1(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl$1(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$1(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$1(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$1(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$1(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$1(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$1(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$1(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$2 = reactDomExports;
{
  client.createRoot = m$2.createRoot;
  client.hydrateRoot = m$2.hydrateRoot;
}
const STYLE$1 = "*{margin:0;padding:0;box-sizing:border-box;font-family:InterYounet}@keyframes rotateLogo{0%{transform:rotate(0);opacity:1}to{transform:rotate(360deg);opacity:0}}.logo{transition:all .3s ease;filter:drop-shadow(0 20px 13px rgb(0 0 0 / .03)) drop-shadow(0 8px 5px rgb(0 0 0 / .08))}.opened{animation-name:rotateLogo;animation-duration:.9s;animation-timing-function:ease;animation-fill-mode:forwards}@keyframes rotateClose{0%{transform:rotate(-360deg);opacity:0}to{transform:rotate(0);opacity:1}}.closeRef{background:linear-gradient(135deg,#b45afc 15%,#4285ff 50%,#00b2f8 80%);border-radius:999px;cursor:pointer;position:fixed;display:flex;justify-content:center;align-items:center}.closed{animation-name:rotateClose;animation-duration:.9s;animation-timing-function:ease;animation-fill-mode:forwards}.animation-ping{animation:ping 1.6s cubic-bezier(0,0,.1,1) infinite}@keyframes ping{75%,to{transform:scale(1.4);opacity:0}}";
function formatMuiErrorMessage(code2) {
  let url = "https://mui.com/production-error/?code=" + code2;
  for (let i = 1; i < arguments.length; i += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified MUI error #" + code2 + "; visit " + url + " for the full message.";
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function memoize$1(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash$1(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$2(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$2 = 0;
var character = 0;
var characters = "";
function node$2(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign(node$2("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$2 > 0 ? charat(characters, --position$2) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$2 < length ? charat(characters, position$2++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$2);
}
function caret() {
  return position$2;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$2 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim$1(slice(position$2 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace$1(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position$2;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position$2;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position$2 - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position$2);
}
function compile(value) {
  return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$1(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous2 = character2, character2 = next()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$2(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace$2(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$2(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$1(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace$2(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$2(value, root2, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
  return node$2(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node$2(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize$2(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify$2(element2, index2, children, callback) {
  switch (element2.type) {
    case LAYER:
      if (element2.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element2.return = element2.return || element2.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element2.return = element2.value + "{" + serialize$2(element2.children, callback) + "}";
    case RULESET:
      element2.value = element2.props.join(",");
  }
  return strlen(children = serialize$2(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element2, index2, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element2, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element2) {
    if (!element2.root) {
      if (element2 = element2.return)
        callback(element2);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous2 = 0;
  var character2 = 0;
  while (true) {
    previous2 = character2;
    character2 = peek();
    if (previous2 === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position$2);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$2 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element2) {
  if (element2.type !== "rule" || !element2.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element2.length < 1) {
    return;
  }
  var value = element2.value, parent = element2.parent;
  var isImplicitRule = element2.column === parent.column && element2.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element2.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element2, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k2++) {
      element2.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element2) {
  if (element2.type === "decl") {
    var value = element2.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element2["return"] = "";
      element2.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$2(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$2(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$2(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$2(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$2(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$2(value, "-grow", "") + WEBKIT + value + MS + replace$2(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$2(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$2(replace$2(replace$2(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$2(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$2(replace$2(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$2(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$2(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace$2(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$2(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$2(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$2(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$2(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$2(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element2, index2, children, callback) {
  if (element2.length > -1) {
    if (!element2["return"])
      switch (element2.type) {
        case DECLARATION:
          element2["return"] = prefix(element2.value, element2.length);
          break;
        case KEYFRAMES:
          return serialize$2([copy$1(element2, {
            value: replace$2(element2.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element2.length)
            return combine(element2.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize$2([copy$1(element2, {
                    props: [replace$2(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize$2([copy$1(element2, {
                    props: [replace$2(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy$1(element2, {
                    props: [replace$2(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy$1(element2, {
                    props: [replace$2(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key2 = options.key;
  if (key2 === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key2 + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$2, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer2 = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize$2(compile(styles2), serializer2);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key: key2,
    sheet: new StyleSheet({
      key: key2,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c = b$1 ? Symbol.for("react.element") : 60103, d = b$1 ? Symbol.for("react.portal") : 60106, e = b$1 ? Symbol.for("react.fragment") : 60107, f = b$1 ? Symbol.for("react.strict_mode") : 60108, g = b$1 ? Symbol.for("react.profiler") : 60114, h = b$1 ? Symbol.for("react.provider") : 60109, k = b$1 ? Symbol.for("react.context") : 60110, l = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n = b$1 ? Symbol.for("react.forward_ref") : 60112, p = b$1 ? Symbol.for("react.suspense") : 60113, q = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c:
        switch (a2 = a2.type, a2) {
          case l:
          case m$1:
          case e:
          case g:
          case f:
          case p:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k:
              case n:
              case t:
              case r$1:
              case h:
                return a2;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a2) {
  return z(a2) === m$1;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m$1;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m$1 || a2 === g || a2 === f || a2 === p || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x$1 || a2.$$typeof === y || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered2, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered2[className] !== void 0) {
      registeredStyles.push(registered2[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key2, value) {
  switch (key2) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key2] !== 1 && !isCustomProperty(key2) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered2, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered2, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered2, result);
      }
      break;
    }
  }
  if (registered2 == null) {
    return interpolation;
  }
  var cached = registered2[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered2, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered2, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered2 != null && registered2[value] !== void 0) {
          string2 += _key + "{" + registered2[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered2 == null || registered2[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered2, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered2, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered2, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered2, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name2 = murmur2(styles2) + identifierName;
  return {
    name: name2,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key2 = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key: key2,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key2 + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key2);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element2 = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element2;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key2) {
  return key2 !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key2 in props) {
          mergedProps[key2] = props[key2];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
function isEmpty$2(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$2(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$1(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function isPlainObject$2(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (!isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key2) => {
    output[key2] = deepClone(source[key2]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends({}, target) : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key2) => {
      if (key2 === "__proto__") {
        return;
      }
      if (isPlainObject$2(source[key2]) && key2 in target && isPlainObject$2(target[key2])) {
        output[key2] = deepmerge(target[key2], source[key2], options);
      } else if (options.clone) {
        output[key2] = isPlainObject$2(source[key2]) ? deepClone(source[key2]) : source[key2];
      } else {
        output[key2] = source[key2];
      }
    });
  }
  return output;
}
function capitalize(string2) {
  if (typeof string2 !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function useEventCallback(fn) {
  const ref = reactExports.useRef(fn);
  useEnhancedEffect(() => {
    ref.current = fn;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
const UNINITIALIZED = {};
function useLazyRef(init, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init(initArg);
  }
  return ref;
}
const EMPTY$1 = [];
function useOnMount(fn) {
  reactExports.useEffect(fn, EMPTY$1);
}
class Timeout {
  constructor() {
    this.currentId = 0;
    this.clear = () => {
      if (this.currentId !== 0) {
        clearTimeout(this.currentId);
        this.currentId = 0;
      }
    };
    this.disposeEffect = () => {
      return this.clear;
    };
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = 0;
      fn();
    }, delay);
  }
}
function useTimeout() {
  const timeout = useLazyRef(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
const hadFocusVisibleRecentlyTimeout = new Timeout();
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      hadFocusVisibleRecentlyTimeout.start(100, () => {
        hadFocusVisibleRecently = false;
      });
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function resolveProps(defaultProps2, props) {
  const output = _extends({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends({}, defaultProps2[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output[propName] = slotProps;
      } else {
        output[propName] = _extends({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key2) => {
        if (key2) {
          const utilityClass = getUtilityClass(key2);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes && classes[key2]) {
            acc.push(classes[key2]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function clamp$1(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}
const _excluded$r = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key2) => ({
    key: key2,
    val: values2[key2]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$r);
  const sortedValues = sortBreakpointsValues(values2);
  const keys2 = Object.keys(sortedValues);
  function up2(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key2) {
    const value = typeof values2[key2] === "number" ? values2[key2] : key2;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end2) {
    const endIndex = keys2.indexOf(end2);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys2[endIndex]] === "number" ? values2[keys2[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key2) {
    if (keys2.indexOf(key2) + 1 < keys2.length) {
      return between(key2, keys2[keys2.indexOf(key2) + 1]);
    }
    return up2(key2);
  }
  function not(key2) {
    const keyIndex = keys2.indexOf(key2);
    if (keyIndex === 0) {
      return up2(keys2[1]);
    }
    if (keyIndex === keys2.length - 1) {
      return down(keys2[keyIndex]);
    }
    return between(key2, keys2[keys2.indexOf(key2) + 1]).replace("@media", "@media not all and");
  }
  return _extends({
    keys: keys2,
    values: sortedValues,
    up: up2,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
const shape$1 = shape;
function merge$1(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key2) => `@media (min-width:${values$1[key2]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key2) => {
    const breakpointStyleKey = breakpointsInput.up(key2);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key2) => {
    const breakpointOutput = acc[key2];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key2];
    }
    return acc;
  }, style2);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys2 = Object.keys(base);
  if (keys2.length === 0) {
    return breakpointValues;
  }
  let previous2;
  return keys2.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous2];
      previous2 = i;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous2];
      previous2 = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path2, checkVars = true) {
  if (!path2 || typeof path2 !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path2}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path2.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}
function memoize(fn) {
  const cache = {};
  return (arg) => {
    if (cache[arg] === void 0) {
      cache[arg] = fn(arg);
    }
    return cache[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys2, prop, transformer) {
  if (keys2.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys2) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys2, prop, transformer)).reduce(merge$1, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers2 = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers2[prop]) {
        return merge$1(acc, handlers2[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform) {
  return style$1({
    prop,
    themeKey: "borders",
    transform
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color$3 = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color$3, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
const defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys2, object) => keys2.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css2 = merge$1(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const styleFunctionSx$1 = styleFunctionSx;
function applyStyles(key2, styles2) {
  const theme = this;
  if (theme.vars && typeof theme.getColorSchemeSelector === "function") {
    const selector = theme.getColorSchemeSelector(key2).replace(/(\[[^\]]+\])/, "*:where($1)");
    return {
      [selector]: styles2
    };
  }
  if (theme.palette.mode === key2) {
    return styles2;
  }
  return {};
}
const _excluded$q = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$q);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends({}, shape$1, shapeInput)
  }, other);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$1(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
const _excluded$p = ["sx"];
const splitProps = (props) => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig$1;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$p);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return _extends({}, systemProps, result);
    };
  } else {
    finalSx = _extends({}, systemProps, inSx);
  }
  return _extends({}, otherProps, {
    sx: finalSx
  });
}
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o3 = e2.length;
      for (t2 = 0; t2 < o3; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o3 = arguments.length; f2 < o3; f2++)
    (e2 = arguments[f2]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const _excluded$o = ["className", "component"];
function createBox(options = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName
  } = options;
  const BoxRoot = styled$1("div", {
    shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
  })(styleFunctionSx$1);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme = useTheme$1(defaultTheme2);
    const _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose$1(_extendSxProp, _excluded$o);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BoxRoot, _extends({
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: themeId ? theme[themeId] || theme : theme
    }, other));
  });
  return Box2;
}
const _excluded$n = ["variant"];
function isEmpty$1(string2) {
  return string2.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$n);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key2) => {
    if (key2 === "color") {
      classKey += isEmpty$1(classKey) ? props[key2] : capitalize(props[key2]);
    } else {
      classKey += `${isEmpty$1(classKey) ? key2 : capitalize(key2)}${capitalize(props[key2].toString())}`;
    }
  });
  return classKey;
}
const _excluded$m = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name2, theme) => {
  if (theme.components && theme.components[name2] && theme.components[name2].styleOverrides) {
    return theme.components[name2].styleOverrides;
  }
  return null;
};
const transformVariants = (variants) => {
  let numOfCallbacks = 0;
  const variantsStyles = {};
  if (variants) {
    variants.forEach((definition2) => {
      let key2 = "";
      if (typeof definition2.props === "function") {
        key2 = `callback${numOfCallbacks}`;
        numOfCallbacks += 1;
      } else {
        key2 = propsToClassKey(definition2.props);
      }
      variantsStyles[key2] = definition2.style;
    });
  }
  return variantsStyles;
};
const getVariantStyles = (name2, theme) => {
  let variants = [];
  if (theme && theme.components && theme.components[name2] && theme.components[name2].variants) {
    variants = theme.components[name2].variants;
  }
  return transformVariants(variants);
};
const variantsResolver = (props, styles2, variants) => {
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  let numOfCallbacks = 0;
  if (variants) {
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        const propsToCheck = _extends({}, props, ownerState);
        isMatch = variant.props(propsToCheck);
      } else {
        Object.keys(variant.props).forEach((key2) => {
          if (ownerState[key2] !== variant.props[key2] && props[key2] !== variant.props[key2]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (typeof variant.props === "function") {
          variantsStyles.push(styles2[`callback${numOfCallbacks}`]);
        } else {
          variantsStyles.push(styles2[propsToClassKey(variant.props)]);
        }
      }
      if (typeof variant.props === "function") {
        numOfCallbacks += 1;
      }
    });
  }
  return variantsStyles;
};
const themeVariantsResolver = (props, styles2, theme, name2) => {
  var _theme$components;
  const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[name2]) == null ? void 0 : _theme$components.variants;
  return variantsResolver(props, styles2, themeVariants);
};
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$1();
const lowercaseFirstLetter = (string2) => {
  if (!string2) {
    return string2;
  }
  return string2.charAt(0).toLowerCase() + string2.slice(1);
};
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme,
  themeId
}) {
  return isEmpty(theme) ? defaultTheme2 : theme[themeId] || theme;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
const muiStyledFunctionResolver = ({
  styledArg,
  props,
  defaultTheme: defaultTheme2,
  themeId
}) => {
  const resolvedStyles = styledArg(_extends({}, props, {
    theme: resolveTheme(_extends({}, props, {
      defaultTheme: defaultTheme2,
      themeId
    }))
  }));
  let optionalVariants;
  if (resolvedStyles && resolvedStyles.variants) {
    optionalVariants = resolvedStyles.variants;
    delete resolvedStyles.variants;
  }
  if (optionalVariants) {
    const variantsStyles = variantsResolver(props, transformVariants(optionalVariants), optionalVariants);
    return [resolvedStyles, ...variantsStyles];
  }
  return resolvedStyles;
};
function createStyled(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx$1(_extends({}, props, {
      theme: resolveTheme(_extends({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$m);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label2;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$1(tag, _extends({
      shouldForwardProp: shouldForwardPropOption,
      label: label2
    }, options));
    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg) {
          return (props) => muiStyledFunctionResolver({
            styledArg: stylesArg,
            props,
            defaultTheme: defaultTheme2,
            themeId
          });
        }
        if (isPlainObject$2(stylesArg)) {
          let transformedStylesArg = stylesArg;
          let styledArgVariants;
          if (stylesArg && stylesArg.variants) {
            styledArgVariants = stylesArg.variants;
            delete transformedStylesArg.variants;
            transformedStylesArg = (props) => {
              let result = stylesArg;
              const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
              variantStyles.forEach((variantStyle) => {
                result = deepmerge(result, variantStyle);
              });
              return result;
            };
          }
          return transformedStylesArg;
        }
        return stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (isPlainObject$2(styleArg)) {
        let styledArgVariants;
        if (styleArg && styleArg.variants) {
          styledArgVariants = styleArg.variants;
          delete transformedStyleArg.variants;
          transformedStyleArg = (props) => {
            let result = styleArg;
            const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
            variantStyles.forEach((variantStyle) => {
              result = deepmerge(result, variantStyle);
            });
            return result;
          };
        }
      } else if (typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      styleArg.__emotion_real !== styleArg) {
        transformedStyleArg = (props) => muiStyledFunctionResolver({
          styledArg: styleArg,
          props,
          defaultTheme: defaultTheme2,
          themeId
        });
      }
      if (componentName && overridesResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(_extends({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const styleOverrides = getStyleOverrides(componentName, theme);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends({}, props, {
                theme
              })) : slotStyle;
            });
            return overridesResolver(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(_extends({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          return themeVariantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component2 = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component2.muiName = tag.muiName;
      }
      return Component2;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
function getThemeProps(params) {
  const {
    theme,
    name: name2,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name2] || !theme.components[name2].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name2].defaultProps, props);
}
function useThemeProps$1({
  props,
  name: name2,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$1(defaultTheme2);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  const mergedProps = getThemeProps({
    theme,
    name: name2,
    props
  });
  return mergedProps;
}
function clampWrapper(value, min = 0, max = 1) {
  return clamp$1(value, min, max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clampWrapper(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
const THEME_ID = "$$material";
function createMixins(breakpoints, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
const common = {
  black: "#000",
  white: "#fff"
};
const common$1 = common;
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const grey$1 = grey;
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const purple$1 = purple;
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const red$1 = red;
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const orange$1 = orange;
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const blue$1 = blue;
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const lightBlue$1 = lightBlue;
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const green$1 = green;
const _excluded$l = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$1.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$1.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose$1(palette, _excluded$l);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name: name2,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name2 ? ` (${name2})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name2 ? ` (${name2})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge(_extends({
    // A collection of common colors.
    common: _extends({}, common$1),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
const _excluded$k = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose$1(_ref, _excluded$k);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const _excluded$j = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends({}, easing, inputTransitions.easing);
  const mergedDuration = _extends({}, duration, inputTransitions.duration);
  const create2 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose$1(options, _excluded$j);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends({
    getAutoHeightDuration,
    create: create2
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const zIndex$1 = zIndex;
const _excluded$i = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose$1(options, _excluded$i);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex$1)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
function toUnitless(length2) {
  return parseFloat(length2);
}
const defaultTheme$1 = createTheme();
const defaultTheme$2 = defaultTheme$1;
function useTheme() {
  const theme = useTheme$1(defaultTheme$2);
  return theme[THEME_ID] || theme;
}
function useThemeProps({
  props,
  name: name2
}) {
  return useThemeProps$1({
    props,
    name: name2,
    defaultTheme: defaultTheme$2,
    themeId: THEME_ID
  });
}
const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
const styled = createStyled({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$2,
  rootShouldForwardProp
});
const getOverlayAlpha = (elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
const boxClasses = generateUtilityClasses("MuiBox", ["root"]);
const boxClasses$1 = boxClasses;
const defaultTheme = createTheme();
const Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses$1.root,
  generateClassName: ClassNameGenerator$1.generate
});
const Box$1 = Box;
function _setPrototypeOf$1(o3, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf$1(o3, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit2, enter, appear;
    exit2 = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit2 = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit: exit2,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit2 = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit2 || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child2) {
    return mapFn && reactExports.isValidElement(child2) ? mapFn(child2) : child2;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child2) {
      result[child2.key] = mapper(child2);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key2) {
    return key2 in next2 ? next2[key2] : prev2[key2];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child2, prop, props) {
  return props[prop] != null ? props[prop] : child2.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child2) {
    return reactExports.cloneElement(child2, {
      onExited: onExited.bind(null, child2),
      in: true,
      appear: getProp(child2, "appear", props),
      enter: getProp(child2, "enter", props),
      exit: getProp(child2, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key2) {
    var child2 = children[key2];
    if (!reactExports.isValidElement(child2))
      return;
    var hasPrev = key2 in prevChildMapping;
    var hasNext = key2 in nextChildMapping;
    var prevChild = prevChildMapping[key2];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key2] = reactExports.cloneElement(child2, {
        onExited: onExited.bind(null, child2),
        in: true,
        exit: getProp(child2, "exit", nextProps),
        enter: getProp(child2, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key2] = reactExports.cloneElement(child2, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key2] = reactExports.cloneElement(child2, {
        onExited: onExited.bind(null, child2),
        in: prevChild.props.in,
        exit: getProp(child2, "exit", nextProps),
        enter: getProp(child2, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child2) {
    return child2;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized$1(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child2, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child2.key in currentChildMapping)
      return;
    if (child2.props.onExited) {
      child2.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child2.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$1(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component2, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
const _excluded$h = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$2 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$h);
  const timer = useTimeout();
  const autoTimeout = reactExports.useRef();
  const theme = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.start(autoTimeout.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends({
        style: _extends({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$2[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
Grow.muiSupportAuto = true;
const Grow$1 = Grow;
const LogoImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAYAAACAvzbMAAAACXBIWXMAAAsTAAALEwEAmpwYAAEyJ0lEQVR4nOz955IkObLnC/4UZu7BeURyUry6q9nhfMi98xz7lvsKKysrd/busDN9TpPqqspKTiKDE3eD7gcYgQEwcw+SmZHVoSIR7m4GoqCqfwWgkP/n/+OIq05G3edJDrtzwnFmmDkyLB8IQ2sphmPsoEAAsaAKhRGKHESF+X1h7kBQoxwsKSdzigGysbjwdU4CikvHGMQYFMEWFmsLrLHkCvOHwuyhYDM4WLIczVlQIR8LxoI1wmlmGGUCWAa2ILcWUQGM+xSXByKoKlpYsI5fYx0fKhY7UGxuQQSx7q9i2CVnUVH3pwI2Q9WAFUAQFNA6DFhEXQIigoj7BFBVbFUZIiW/MM7cnxUwtsxYDQJk1mLUgrj3rmiKqCDWgDUub2NRsY4XpKztMl8sVhSLGlERUTEiIggGMKqIWMkEmVHRORVdtkaXgWVUloAlhSXQRYFF0DkVhgo5kIEMUMlxv3NEB0CuqgOt3ot7p2gODFTdZ8mkKjIGRgpjYAQ6br7LGBgjjIFC0TKclu8pFBkBI1SOgAMV9kD3FN0D9qzoriB7wyLfzYvsADgZZUVxmo3VClYQq44sqKpgQVCRpibVta+KYHODzTNX24VFClv2GUHrHi+oGDQT1Aigrm8U6tLSKk11fYOy6wmu35RdwSJNvwGwFlsopzbjlBxQBowYmBFiBDUZiAFV15XQsu94iaig1qBiyDKDyQXEUhQFY2uxZSmkHK9adcuyX5sswxiDiGBVKYoCqwUWWxfCGKGwwu6e8PqVYTSC1fWC1XWLtXCw70bPzKIynBMwBlVX16JVfZZFKetlPDLsbme8eZkxLoS1rYLNOwUzszAaCcVI3ZjMDJoN0WzgKlP9Cvx4KP/QDFzTNeHmgHKyJ/f+Bt7nQGEWWACWg7/F8m+h/JwFhkGaA+/3IPGZB++r3wY3P1TCYBz8Vc8K7zMMV3hhj4BDYA/YLz+rvx1Fl1V0DzhWdBTkkcrLnrPOr+maLkzXAuSaPjT5k/98+bdY/ylLwLKiTjiIzqvooigLwIKic8AsyhCYUWEIkqvWk3/5p0ab7xlgVCRTEFFK2FaiOig1e0qM5D2v/wmgFijUqaP1n9bfpai+l2Eq4TJS4QQ4QTkBjkTlEGSvED1AigPgwIruA/uCVAJmv/w79P72gAOuBck1fQC6FiDX9D7IUKIIGs1+DlgBtoBVGiSxVD6v/laBNYSlUojM4BCGn54p85HgMyD1/sef3TF6y1XlPSmsCyNRtr5gObGip2r0GDhU0V1gB3hb/u2Ufz5yeQNsl38HXlo+Wrmma3ondC1AruldUoZDFMvAGrAOrAu6ArLqfusWyIooCwaZBWYRmQPmUZ0HFhDmFWbVrUk00sE3mVdfKqSgvhQJBYfEcZQgTJCeHyAQT+pnWgUp7fH+ekMZSMo4AiAiBjRHmQEW3VoV4CZ+Z+5SDkAd4hA5Ao4RjkAORUvhIbwG3cYJmG3gDcI2DUIZcU3XdMl0LUCu6TLI4IRF9VmtVaziBMcmcBO4C9zBoY4N0BV1YeZABuLWRN3CuWd+0ma9HWhr+uFET/RuMr6oLVKdIdLJTEpZe0MEaUgTvhQgGepMe4puUJnF3OK5lr9HwAHoPg6hvAFeAE+BpyhPgdc4gfIWJ1yOymwr5HNt+rqmc9O1ALmmi9AQhy4qc9MSsAiyAqyp6CbGrim6ArqOsomw6cLqMk5wnDlTTaCAzmT859oVyJ/oz85Pf3pTBAsMb8FjwQnlrCOVtTLOEc60ta3wGquvpbBvBH2L1W2BNwqvcILkgHLRHthB2EPkxG39m471a7omuBYg13R2MjiEsYJDFreA2+XfDZQNYE3RDRXdAFkEBqADYAgyBAZam3IcaYQXyr2i/rvAzNSe66sw7TgNSU9eYSqerAm3V0oqHW3x0zKDifi/GvNZlG6MdlJrNGHeXp5zCLPqhPddVE/N2J4qnIA9ANlBeIVDJK+Bl8ATHFJ5juprGnPX9brJNU1F1wLkmqahBfUWtY3qOmpvCdwC3VThBrVZql4QX1KYQZTW9v7g82Ohd8bvZQAeLzWFocAQ1YVKXJUmuhHKHmizRgIvQF9g9aWovET0FfAC4S3IDqo7OKFyTdeUpGsBck19NMQtfN8ReKiq90S5Z+COqN7DCYw5FeaAWUFncbuk8pbWnFyfCDXzKmzL5hS86zY1NeikrZm3tj1JuJhehfWW22tkIC3em6caCcF4wd1HQUF63kJ723SlXhnEj9JCK+FGgNRKTyjsyrADVV0HlkFuACeKHoEeSaEHINsYXqqYRwg/Aj8Aj4DHONPXCdd0TQFdC5Br8mkOt/i9gFvP2MQJj/tGeSjKXaPcM6o3cYviuZ5Bhf7YUEeKLr0MZ0AgZ807ueSj1Wl8FtxvLaWvnjozl32CkScoP4A+Av0eJ0ReA7s4E1d1BuWn0KTXdAG6FiDXBO48xRpOKNyh3C2log+AO6JsZgWr5cL3MlpOPtBayfD1bZ/S2nFrx5GnWmtrUvW1/MYFSknSjhbm5cLEiKH+Xq9neGIwWHeZriwVD230UzmS8dOLJvV63drDNhVS8sskVZiO3CNh0exNbuWtJOvDmb3YAhaxelvRz1F2gJegT9Stl/yIEyZPgee4HV/jMOdr+vOhawHy50nVYbwZHNLYwi2G3wceAA/L7/eATVFmK/9ZGphpfJqkjl6rqxejS6m/FCrxzYaqcyhziN4onxzj1kueAd/hTFs/4ITJI5x5a68Md1L+XTf1nwldC5A/L8pwSOMGbtfUHVVu4xDHDUW2EDYUXQddwwmXWpf1ztt5giSeK2INtydMe4kg6VMuRi3+EcFQsHXF9zj1kEcTpn24MF5HoJWP47ULpTRIqTM97zRkmEyIptJrSCWldn7RfhnuOpumzbwQs8AdFVkFbgh8oei2Kq9wSOSJVqhEeI7yHGfuukYmfwZ0LUB++pTjkMYKbk3jNg5hfAp8BtxX92xF3RqI70MKKM1H9clq/+nZyJ9QewO9Y4p5iBfuz0XRCfXJ6aXfVjawLjH2DknaX7wc53H94xZum++pwluUZwjfA3/CIZRHOITyFHcu5ZRrYfKTpWsB8pMlAedb6jbOFPWZOPPUHRGpFsFvqdtJtQAxyqhTIdaGp5rnw8hdzyZSR+BUulPFbKb2cxxjrDMMwNOUeffxMAU3nfU3iZtEGsl00qmW0YTGl9mMVuZP5ZbAJwgvFF6K8EgM3wryI5ZHqjxRtwB/TT8xuhYgPz0SHOLYwJmmfgb6C0F/AfoQkU2cJjlUt003i3FFbCIKqW+xvMtsk3w30fTUte4SmmUm5JNcgI6fdaeXwhPVVl+dImz5LiyveuXqMEclWyAw+aVNeP1laj2L8o4FUmQudD9nQe8AmyhfAicIb8TItwK/E/hfWP5N0G9pTFvX7lN+InQtQH46ZHBC4wboHRH7EHgI+gXoZwifImxNZ0eani6a1J/LautVL+fF+NMMp5TMlUL5hopsGdE7A2PvqeiXGfxekB8QeQH1Osm1g8ePnK4FyE+DFoBbIJ+D/lyEnwv6hXvGJuiCCostdxkeNVrnZA0/WvROpRcegGstPAdhegoV8hWhIYn5a+LGKMBHI/6TVJjQlUlTJq8wEsefmF6dp39QMYUbOsoW1n/y8GLATwL1NO/CMlTpxLayMJ304n4dfkOMzg0o7qD8WuAxKn+0Ir9Tkd+i+ntxW4OvT7p/xHQtQD5emse5DdkAuYvyCcoXwFfAF4jex13IdE1T0jWaiuk8ZfJk3LyIziPcALmnau6B3MdtEX8IfIsTIq9xTh73L4Pna3p/dC1APk7aAO6DfonKV6Bfi8pDkBsoa6CruHWQxE16DcWabkJ7rT6TO4w8ah3qa2vtbY03Hb/tgiTcUtuzptDBe3tbbsBPh8afdmhYphMgp2R84jBxOXuQQsdnV9rtsFPUkb9fuD6YmEZj4bpOmr+edRI0tJbOq8gngqyBfgb8RuE7hW9V+B3we3G/XyWKcE1XlK4FyMdD1V3gWzjt7QvgZ8DPUPkc5QbuRPk1nZOuEUhMFylTS2lxZ3cGuK3km7g+/BnwOW534D3g33BbgF/QXOF7TVeYrgXIx0FbwCc489TXKvolcE/dFsobWt4JAW1tuvXbIy3fT+MmfZKG317fCDV92r+1L7048y6tOr2u0Y4vHS5Mkr9TKC1Yx5l8UHFKdHIGNJW+vqQDnfVsY27WotprXJrAQfGaSMxfzItGYWJs4mMcBWGoyD1gCeSmwFeq/IXAtwq/A/6g8Aec2/lruqJ0LUCuLg1wqOMmDm38AvgN8A3wiTp36Yb3cvTukuiSOf0pavw/BUq3S2PaCmgFh6w/wSHqxzgk8j9witHvcbu2jrjetXXl6FqAXEVSZlAegHyB8o1Y+bkaPgN5CNxR516C5ImwjrMEkvgWeeLo3RkVapsJrTMUED6yEdonqzsvfupGDlF+MeuJMnSfmkuuOYTrJGGZEjvKuvjzf/Wua3S+C+pIm9arEVFQXh+/JZkGUhe0dK7NxE02xRHKOGvVGnvEbEl5QFFlE1gEXQFuI/qJiP4W0X9D5I84/1uHkzO9pvdF1wLkalEOrKpwX+DXCH+N8heofI5lDXf4r+tq016KJqf3oL5fdhZ96YXibJIQeid0hnm1n7oTmFSe5PtayJyvNrpMgF3pCXH9pwV6kKIzsc2i3AduiOiniP0akf8J+v8F/lXhj7hT7ddo5ArQtQC5OrSF6D0VvkT4WpVfqOjXKnwGsowmNPzELqc0nXXq6NFee0J2PpOeZFplkPK+864pK5FIUAfTlTNtoVcqZbiHzygNmrUFH9pNVd6wZd6RjS+5c6ur8/RJwSDsVP3vDOk16Wa4berzoMtq7apFb4J+qqr/CydEfuB6feSD07UA+fCU4dY5fqHCX4D+jRq+BL0LLKnKXBUw9P463VbQYJHVv92uc0toTNGid+JwWmTKqj+9PDtMV6E33BQfgQuNVqiJ24MT6abLkDZdteqmQ1hNt0Cefu7/0q47SSSRTjA/N8+7NyNoYsW9k/dUnuFvD3JEfSD4naybKm56AX9FVb/Swt5B+JkqXyH8N+D/Bv4d57TxNJHsNb0HuhYgH44WUC3dquuXwK+BXyL8HOFObaoKNtNPQ83umo9nfb0mOa+h5c+TpjPrvZv03xupnVW37rcJsgpsilO6HuIW2R/hFtqvt/2+Z7oWIB+GVlE+U/glor9S5ZvSVLWFO11er3MoGps9Upq4Z+dWNNAAvQQqjVJJuCWpNEB/i6628wq0Y3/tIbRzR1pyKp7n3rcSfPUhtpaKm0AHXhnOhKYiDd/Z2CTFX7id1wvflCFEQenNq15Qr85TYcO6TaCJAFFqw6iHAoKt1okGiRGNBGWJO1m4/ds3UXbxHiJi9yrdl9TnMzJ/6m1R5nGn2X8B/Bb477hdW3/AnWi/pvdE1wLk/VGGEw5buMNT34D+GuWXuC2Mq3XId2gWv/KUOAF9Td10lWrrrLxMDN8yhdYCMgPWy787uOsKbuDG1Q3cnSQvcYLkeqH9HdO1AHk/NMB19q+BX6ror4EvgTu4g4DzkUuJlM04fJbQEmsNWd2n0+YTlnZJ6KHtq02dhl+HCPirf/moINAoE4usEXqSJr76z/E06BAZVc/67PN+XQWad1ymnvQ0COvXZ4gIU2giaqMejbyrLH5Lhev1QR01ty168YIENWjm8JkfV8M+kQw7mfczuZuX5kuDRkNkKOB8vX0BuoxDJD8D/jfwrzSn2q8vs3qHdC1A3iEpDMUdknqAEx5/Wf79HGfDzeMBd1n0cUGXD6lJXyUt/irTpHp6ZwgkEdb7PYsbX7dxSP6h+66bqvq/ROQRbtvvyRnZu6Yp6FqAvBNSVBggfILKNyB/KWq+AT5X5D7oZhMybd/vteFTBQ3tzXG8wOSOJt6FkX1HejHaCT+bUV7nEa4xpCaCiek1nKZ2aIXpdafr29zbeYRhWjl3rDsl0VTIU3TBVJOnBGXyd0k0qCLIu2ZOO+qp3Q5N+PJ3gPbUC9B1t33Thh51rjMl+kvHeknS3Uv0LoRMiTzDju1Q/l3QOVU2rNXPjNGvrLX/Q5X/BXyLcCwqSdR3TeejawFy+WSAOaN8Yix/Lcg/iMrf4hzHLXOJdd47DCasJaTfaupjmtymDDFF5F7gdI4ceqOcJb1pwr7jOpqag97WPXeql5vmhbLte7kOuqxqH1rLJyJyF2QZJ2C+wzlpvL4R8ZLoWoBcPt0W+NKo/auBlb9D+YVRPgOZT2mLXYex+sbORaYyTbwLtWM/7CRDmIiXZped4R1Z01Jlqd8lXkxTnr68KupK4yx1flEeLp6itpBRV6qSeNad4uQm76rHamTUbRRm3DFOQkbLjxxlRdGfq+o8sIywqeh/xa2NPOFaiFwKXQuQy6MMuKvCb4B/zKz+fYZ+oyJrKDNteB4PnWiBPEHdHmzDcFM8S7CQ2h7c5eU1lXJl9ogEUWLmjk1X8dSVMoyk4vq/knUSmNB673nvWEz204p5b38mqtbjL66jdHlS6aem3PbMKgn+Qmqb3sLydc/UMX+B6a2P975+FNa5SHO4Xzvy6Nxk0lSAqg5xjkeXUd1S0XWERZD/AfKY63WRC9O1ALkcWsMt4P0a+FuFvxblKxycjrS8d0Xvz7LbTJXX1uTLoWm092nTuUz6UO07Kd8zoKIB6E1gDmUGYRW33fe/A3/C3T1yTeekawFyMRLghsDPEP5Bhb8H+YUKd4DF6hBgdO9Cy7VH+dmJQLTWjLV51A7Rg14iPdfblhkt3KsXUtK81DHrOL45LtAWe/lKh00bNsLcPQoXzTX93E8xepZYvG3fWR6nkeYnRAU+ggkXvQOe/BP49WG+VPn9xXcvvUR5G209TKe7jrvqfKowrYX7br7C9MItw+oSaIeNxkliEFTvJGgHFUCXBflGlZu4y6tuAv8f3AHEZwn2rmkKuhYg5yBREGVJLHfKXVZ/BfJ3wC9x2wlFpzAlnJeuhtb/7lHV1Shnm64iT+eln1JZ+sgr52L5t4Db/rsIuqAq/2otz4qCXWs/ru3vH5quBcj5aAn4OchfA/+oyK+AeyqygbeJs1ND83p0dDAs0lhLM5HGWtd0yKMKK9G7ENFMgxgqO3O1FdR9JK3piTL574Jtnp2cp1BK4p1ODlN977bHJw7hdaSR4jQ61EeinGHeWmnc3nbeQIPWdgoVq0n+fDcgIarrU2gmu4LxvlVIIdypoERt1dUn2nl39QVihBm1i7TCOb7aCC6xjXwT9DcqrKnIbUTvCfxfIvxWhJ0Ei9fUQdcC5Gw0A6wUOT8bDfg7NfyDCn8tKvc55z0d56GLaI6Xp3V+fAjkMtL7KWntP6Wy9FGHgrVulSXQlSyXlZk5XcgHLAyH+jsRXqEcvXdGP0K6FiDTkjIQ5VMVfnU60L8vhL8GvigyvSMW48JUWyOhtcDcOsBVPauSDT8DLdY3hXXY95NaYqCZpbS7EBn1uiMP2HK/0/uZYr7iNYGuu7f78u5yHtkKE8T19PoOlyNh/pP5arTs9BScWgPpPJjo1WGMGHwkUrXnBLSXWEvq2y1Vh5nYt7z0QrcifjqdfalvTaknvShMiPK8seUveUyTnjJQ5MFwoLPLy8UGcG9mVv8vk+n/bzQy36rK/rVvtn66FiCTyeDspp+K8jcI/zTO+ZtxxuegC6BIuaPcX/f4EPR+8/5wJT1Lzhfl8l2X8qcwPV2VMpyVj1LoZPlAb+e5rptMbxjDxlhlyRbMW8vvxbDDtT+tTroWIJNIuCnCNyL8HfA3KL/A8MAKcwKN8KD9GX5v/Y5tsgk00B0vRi3x0Al3FvXzlwrTvWuoK71IN5xqzacdt0VTIa2Yj/B3hAg7UhG6effXgJr00mcmWnkHZWhiBMikpwwO6UjlzaSVUNwXGkrr6kEeUTnDvBNxgrBtfsK+FCDhFoNTIKPO/tukKw5NeHECSo0374sImIwZk/GZCLmOWbHKllrWRfhfqvyQYO2auBYgfZQDt4DfAP8J0X/Gne1YRcmbPikl8uiZwjoGfZq6J6P3Rz0r0T1LH128TuN7qM/c0MfWmdKdUIZp6rovTErARWHOvXR0dg9OZ4oxFV+NEPV/XjZNNz6CTSHn6Jf++8KCRTIxPFDLpgibJtMVkzEjgsXdfFhMZP7PjK4FSJoGoPdU7V8r8i+K/SdEv8b5skqaRT0T7KVSO90w48vO8R0tjJeqfX8dpXTni9DZ00tPRFfFQDMd1XXsw6nOkD5dpM5TGV297bCd1VH2TXXWhExhKc/1m9k5Mgx5lmuuyH9H+V6Rk+vjsw1dC5CQhBmU+6r6N6r8F4z+o6KfAvNaj0xoTDvp6d1fD+lbh+va3tlnCksx3WUA6TNx9JMmfXJMYw5JauI9prlu5FJ9ps1oqWfRtOijw5TpZQIf8TTb7WIl9bTbxNZeKG+/0/BB86Rzu22Cqw6kkFr8j/tJXFlR+06QEUqiLD3m23RtdhQi4TG6s679oiS29rbSKU3S+VAX8gE/V8OMCvMKi6oIwu+59qNV07UAadM8znfO34L+B9B/wPIVwuBdZHZePWbShPvnQtOZkz4cXQUe3gedTdl5d3lfRvwKwZkMRJhT4cvCkqEMSrUwQ/QHru9fB64FiEcyB3wG+o8q/BfQv8HdIjhwB5PaKkut7UT3dyfQhLTD9g24Ot3QAiOe1hpAm0bDEo/NNAJJ5dX8DtGQh6463JTEsT1U1tL80nk3PDSLoimtOhm3hZBC/qROtXOrb7gQrd6Pus1iDbjKyfMdi1vK7cinxaaHXAUHkTqg0TRtF9ZRnZp69ZNc4A7786T2TfTNWpuX+n1zuLDNV+L+jp7yJdBFF0JP3AEft+9kxBXyZSm3LShDlE9AB8AQ0XlR/X/hbj78s3fGeC1AHC0CXwD/APwn4O+AT/siXIamddU11KvO3zR0lcuQmFM/Suo3Qb2fvC89XfWEnjIr8BAhw3n4rRrtj7jbDv9s6VqAuIXxr0D/WeH/BP0NDnnQdiVRUuK2ufB5peFFOquPFKqnYXq1E7pY5YrcOATptfKqf8XTVIUIorWBnjWMSEOtArfKXSGktp05rUEH5fQM1dVaU/c97O0oLQrSc5p+e72h0V7Lj5ZdvF2GqZBW9Dyl6bfL69d9hAR7kWWQR1h/kqifuh18XjrqNOSvyTDW7P2wwcuwDD4yjuovQgpNx5l0sDPpoidC4X5HDNo1eXtmXcDmmZID91DNVSRDmUOYxTljPODPlP6cBYgBVnB3lf8z8B9B/x7npbOTPqS29b7pqpTxqvBx2fRTQSCXTe8MVVwksmukHLiLkiHM4OYQC/wWd9PhT7WrdtKfswDZBH4O/AdF/yPwjQbCoy0sNL0rKRr9lYPBhIYfIJpWb+u6OCf1rVY6fSQThg20r1rD8hwGxgpfMp92XikOJa1JT5NegFZcOgnk55cpKL8fP1yS8pevovJqWEdNoC7042v4XchtqnvdPX4727XPht9h7/fbocvxoMTF7VGMpriH3YsUuZ1JoNC4PwR15AfuQMWp3Y/xXfSJ9LrSTdRnvPollCW8DWSqZMAsygLC/wBeJXL6SdOfowAxwDrO9fp/wK15/KU6NHIBOoMeGUz27Xfn1Uf7lZ9LV40k+tLkchGVWhLpTeTBj6Ht9328hGahxMQVp39Rak9HF0+7J1bC/DY5n65+mQgRzsx9/bon9XSMszydhib1zVhcpHcQ15JlC/hLnFv4YRnqfwJv+DPa5vvnKEBuA79Q+M8K/4Lyc9wtZR6le1lbo2s0ltaUl4zafphCFxPJ03z7Jp6u8TFNmKkCTDHrnc/Ml0Ydfkp+uhPZSAiPpv6a9IRYC2+4IZpEUnl30TTlP+uE2JV/UsPvDNMnpLt6WRoJ9eXXSiZRf33ne7oobMN2JpPinI864os6RfQXKEaEDGUB5b8DP3L2pv0o6c9NgNwC/gL4D6r8Z1V+ASx0ml76fPWkNDKCQRaZU7r7VGSSqDWmnsX4vgNh0WKoD/nLdDom2NazugzhYO9Or5srz6wQaITtOu6YWBILpmGocOsqaKQo+2WIcupYRFbvS2d/iQRdPFF3bfFuP+uaWJs+0ukjSlLhg7KkhH5n2/XUUWqjQd03g/QT6cX1lK6jFF/xmEttuoj7WBNCgnfqFU2SYTryXwV+icpQhAXctQ6qyhNV7E9djPxZCBBRBmK5LfAbsfwfKP8A/Fxh8SLWlvdBH2P/u4jGdxYN/yy8XFW67PJeNl12/V318k5FcQHcBXNCVsrWoVr5r7aQR4VlfOU74QXoz0KAqOGOGv4W+I+i/AdRPgeWQJMu2Cd6AG09b+t3vXdWRJzFN+CF23encinRy3tsyE0iKv93C0QF6KKWDo1215VeTX6Yju2xKVccjVYdlmGyN6I+j7GRESV16DBgZqo7Seoo3cgj3WZB2Oi5914qBNITJuAjvgXRCxMhwI7+BxE6S25xrtNrJxx7HU7UUaIEDZ8V6mnz0vCTcGcabnH2n3UeOgy58t9Vcb0S1JtBZF7gKxGGYnTB5JoZRU3GI+Sn64Txpy5AchU2ipxfj4b8J+AfrfCVWOZTHeaarunPiX4Kff8qlKFRjphH+GIwVFlYsqeFlfHsvLXG8Eg1IeF+AvSTFSCiICq3VPj1aKD/2c7zz8bqlzbTeSlVONVYywDS2/4CCrWlpEYYaq+dqRBp2VHYlKZfK1gahQsP+vUV6Uz3f/cJXm/dwf2vAntIa9JNhEn7Rju9FPLr5Nd/Fx1wbKdXsppOL6jjVF5NGVI6dDrdPmTYXyeTU+xEU16acS2GWnYCJWs7qHpxw23e/rvq/zQ3JLrnkgjVRg7pXhAud0v6e5KmqWwP/XhIxrr5ZDgzq59meaEYzGBGbZZxYq15Ps288rHRT1WACLAmlm8w/Edr+Ac71C+MZbESHtf0/uhjqe6Phc/Lossu759b/VXkIRAA8gGzw1n7uckoMOwrsmcL/m9VXn8wJt8R/eQESNmGGyg/F8u/oPwn4GsVXfJ1mFqOpJBHpGH6Q6OyKwdaVBykWxP0A3ba0TvLRrguEu6CUY+/FFXlTvLeSi+xAyxRhBAR9O2q6UIe8e2F2uLDz6G/jtJIoh0+bcvvQy29zgXbyU7ZF/ztYv3lUq9Oqi4T72YL1wQS7dtn5w9/lwUWSRwdnap/hzvAtH7aWc5OVES087BPWEVtldy912KTENmk3kVrIeWzukxa5iUKIjPA52o5tioja0FV/qug25JYd/1Y6ScnQHC+rX4G/ItY/kngG2AZQzO5cr4G/Bga/TJ5/BAa6sdQxx+a3kUddZuR3k8+Pwkq5Yq1gioU7g6hn+GsWyPgEPhv/IR8Z/3UBEjlVfefgP8T+AXlLYKB0p6+rzv41raRp9cUQq3Mp26NPA4cppfQwbrTq5RQ72kf/gjTCXeXTKOhttxhRHyFz7uppXUGlTkpvaQ7967zND7vUd4pPrtQQULTb1cfiaCdbdfeiZeOr616aeO9afpSF78gibWyNqztRQzTIMK28p7um8FaXqtMnS5+2nFd0PTaRy+qCOukhR7D+EFhyncSvlMPMSlLCF8DxwiHuGtx/xXnO+ujp5+SAJkHPgf+EfiPwF/hnTBPdpDwZ6cpY6pVzHSalxx6YkodrJ4vl9Q03JWe9L6dyE9r4J49vbPQ5d8VXqUbxztHTcRvWml1dOS+nM7TJ3pMRRdB72dJLz3x99DZhmk60jnS6BNqJa3ilNkxToCcAP8Lh0o+avqpCJAZ4KE64fF/Ar8G1qfr6NHMdUF6l+ldVsjLS0+jL0yYsDR4f4Y6uiSZcin1lGTbn3QDCSLBZw8TabF9GX0pQROSvaw+lUaEicyFNuy5gtSgjjPRJugvgSNgH2QM8i1wEKd2hQsf0E9BgAyBB4r8Har/Byr/oHADSk0zaJtaEwoHdhXeC9OeA1IGjn6NqnvxPB5OfRC94TlcmCyf9y0Ce+lUX0L+Jm5LTaSY8pjbtR04mV4F9d0/Dz3FJqJkemG7dt35keB+Khcu0SJwzFVXX0oJ1a46r8vu8ZUud+1so4xf8hfaL0nVd2AGann71XbgHrNeF+ZJIy/tDlOGa9WTlG0oQfmjvu3zHqfpwqZNWSnew3e9vuwSYyieX3oRzZbCb0BOyxcK/G9Q+zEJDZ8+bgGiDFDuo/w9yv8B/BXlZVAfjqXLCXOefKfRjK5MN70kRs6SzJUp+0+Urut3IhlEbqvz4luocqiqR6g+Ru1xHUpMch3oKtLHK0CEDOEO8Dco/wX4Z1XuQ4eGWn1GM2zioFQQaxq7bbQ909Ok+rZRRvzRDtvLn6ftNWHihb52nqkbPbr5CZ+kF541rQF3LZBr+U5x2zJ9bdQ/hBfWm8+UNEIz4KSzbGcpd1jXkZFBvZqMFmbbPALdN/R59dl1f0cLgYR3XiQ0hq5ydiKnBOu9CCRoj2nqvOE3gQaCftLbPmH0Vr9La/+tYnaZV5OIpo2yxXvc7nsgU+TtImqOyF2BQtEjtcUY+H+j9g+uQgXNQMW48qgi1wLk8kgFVDDWcMsa/UtV/Y8If4/yKc4T5jX10JXpileGkWv6cNQlnn/C5ITSUOEeav8GlbGKHqN6KKqvQE5VTVtAXQuQyyJBVEDYUGN/Y3P9Lxb7Lyr6iSpZp/M4fM0vRgp1UwUqVvJAU/DZPA9WR1swqLsDxOmFqKfP3lo9b/Qfb/tg+W56zTzW4rttx31rDVFeXoPUBxzDiC1neW3NPkZcKW7D9EKGYnU7LHeS9/C3ePnWRWm3c0trD3nunCtTcMCfYKVcNgryqHhIIMBO8lFMEDgqf6setftdRH1oKvjWc1izDiP+eG2iq5sPAupeh+jaGu6DyGh7e42+JYrXvUaTaM/WOp3OovqJuNIfgp6C/jfgB6ZowqtCV1KARGO/eq6QF7o2EH6Zqf6LGv0nm9mvcLeC/STpo+lJ13Ql6GPqL6m7aq4OdfN0vjpOpafzwKeCHCpSAGOQQ+A1H8mthvlVbDqfBGp7uVHmZkb6czO2/xn4D6L6pRUnPFoKf/0g1gD70YWk43gKcXXHdqQBtpN3zxLaYZuXWKOP7cva3Zc9PssqisrVae/27fOBYT6p4dd5tesviUA6kIMknoUH/3oRkn9f+dRrXD4/Z0CW4bpLwkFinW4P+IxyivpEQidP9gFp1V8XQorXZRrWk7u8Ouo/ukZAvPjBvB/F8V7G/HbXfYpi9+ta/pQ6F8dXPPi7d0RJ8lqCCu2HB2v7BZzUcV2mXr2JtHirbQlStqT7OS/wJWAE9hV2gf8NH4ffrPxjEHNlG+Sien8wtn9nVP8F4ecqspTsfKmHHX2gfcq3L4FJmkfv1PfOqeVZGK6YUpcw7URB/EmtL5UzZeml10xoXdNC70Q2dWbTxjl7asnnU7Tz5fJxmTRtJ02Eu+T+3Qi68yQ8QcBMfr4q8BWwjRMgJ8AxH4HLk7y4UhONo0IEi6viTBWDZoLcB/4a5e+N8o3Cho8GRNMaUEShebkvbDDV9GtKQWpe4GYHf/eUNc2k1mgwtEOHcCj9KPWzTVHd9NRnrXD52K4DFnhsJuU1/W2nHYuIqatU4xJOY4poYaMJYePqn4ZClBciu3Z/SSdfXd2a5q+b//hCKS+ZEJ4kglZfzuQJfaL0aeq8U88XiZBHmFkKcSXAU/tbOECpBIfUbHXXdMhDckIJ3vVErz6VJdxp9RNgF+QVyJ+4yivoQD42H5qFhqouNRZhjGBQBqoMrG6o8BuQ/2CRX6phA9p9XoXYTMNkCN2676Drrgpx3ak9R5Vhw1HlIYHOuyUkfhYOiGnwTHsbZcVP9azdsbvMchPz7jBTJPmLzDba8CkdccLxkayb6p0vyPvvA0k969om23oWtlk8q7lUxEsvmLBS7RsKzrhsXv8N/T+14kxQanq88oZ8puq6y+SL0rnYnRLE0UHChNTtUiaQqo7j9pFgIdtvw6bHS/tBYy9t+KgVoOYd4bva9FQFiRiN27Puo96LOotAMWrdUwK4A9B/AbwAfYTzl/WSK0xXyoRVdb9C3J+qkCmLCp8Af6vo31vhPjBIxe/UZN4BTaVgdSkn06ZxxrwvPb0pynBV6Tzsvssivs++OZHeERPvtosEk28fHx3lC1XHVrIXYN4XZJGcnDJdF0wygTuC/QuUJyB7qBzjOV6cHl+/H7pSi+gJXuZwwuMvVfWvrPAVykL1MtIsE943ozD1SO7W1MJ7l6s7l6HRGiJE45sgyol3ErpI3p3tp+GTNOFb90N4YVvpafjOh/rtMiQ1aQk1prCO2nXeLl97cCY13kgbDjRT1ehdZztBbYppu+lo5ZCo9w505lHX4c12/lWeITrrK4OfqZb13Wa031twkMM0yCOlCWs6TtQ3JcGH37c0bI8u3rX1vs1fICRUy3JJXbyp7nupul9r+3gVt6zoGm20a7VCy+0ydM2SiiLt9/WifJVQ3C5eYZr0m6Aiqp+ixT+B7KPZtjrvvRbo5ORD0VXfxrspzjHiPwJfoSyeJZ1eLeVcnE1BV62Fz0NXrAwfGfip6bIR4XRxPsKrt7v62yX1w8gc15fXmSqvj8EzMB8F1RVRfgZsK/oI5K3CMxFGGWBKM6oNhfYHoCspQAAEVoCvFP1nRf9B4Q4irQrr1Cj956G9NtC4pBW+/IzcRUzW7urE8DS9ECnUPHgIIMwrkWz1oNuJYgIpdNhm23kEyMOPU2lsASNNHcUjrmubbGqxO77PItBRpfs2xCRiqH4EyEMTQaL2rT5TiKb+3YSO0VPY76rPFIJroxX/dazZT5FegBLbLlZqVbwV1oGe/r401VZnv87LoRbVTZSGV7hom6w/LvxHMZJL8uZt7XVlivs8UX/zEKu2kw8PP4brL1V8B+qD9igL0dqGX/En8R0wUloGyoO0glsP+QWiTxUOFP6rCD/mRhggqBVOrfMP75f5fdMHEyAJC0hNojpr4HNR/RvgL9WZsWbeCR+XneAV097PRVesDB+dRn1BuggC+QjxR7f2/z4RSPX6SiAQAchAbuEcxB4ouo3Im0w4HCBYEcbQPsbyASj/0BCoMktWXwGM6iei+o+g/yyqX6q7X9jTjNvhQ+2u0lrEG06xJhmmkdKcE6pzSIFtFrq1sC4NuCv1libmBera7ZRMJ+JPYr46NPo2Oos1+lYGibcplBajiL5Zoz06OuuoFS1EA93o0VdyKzQYTzZlHC9S5+66qCRe/0sgrVa6vWVIhemYdaV5F7Vz6Iqk9bKKH/elsEWq/uuzWw3jvvWkKLEQeUgqXLos3c9DpBYwWs8RYSMmeKjjd+WlRLuuOuKG0cK86pYp13xKWgb9GjgFfQrySpDvBA5aoT4g5cZ8aDbUH0QZsGFUf4PqvwC/Qlj70DLuLPTBBfIEmoq9K16GD0lXv2o+3Hi+tLr50FPSZVBPGc5QTwKsg34F/D3wBndO5Ft1SyAfnPI8/7AHQVSVwoJVBasbIvxK4O+AXwF3nJNEGsUhgSqkwy7ayqcKGz2fphm6EUOoB6aQTujSJKV0NmUJbLPe/2DzRq9GLtJ+krKfh7+iOkqUIfkypIBP3x115zmVKLp2okVJh06G1VQZorCJFgkapk7PCxq3R6CZ+4EmkfgptdP167yrH0dxEs+S76ridg2DoB/5D/0zPF15NDvLUrbqoO36+lb4KFkB7baLvUyk+lR3+0TnPloOP8v0giy6rlPwH8Yot0mv4+rtLeCvBN3FCZFXwNtOxt8j5Vn2YQRI1TaFVSwKhc7hfML8M/DXCvdwbo9b1GvGSExGnRNLD2/nSe+8dBb+uvI666RxlvSmy7PH5DKBh1TKYToXTW/Sm3Q+PeaeCSn7E0RXX0oqGhPSbefRX+dnpb4tw1O1wyQ5+SFQRXptYcqw06R72YWSxFcByAX9FDgAfWbhqTp/WUeXzMCZKTcfCIBUAsQiUOgMcEfhN6Buyy4suxApjZzEgte0QyjQ4aJ0Jsd8J3ShvphQiy9EKYw0BZ0r6w5b/hTUGyPiZZoyTVuAMOd3NDueK1n14k5akIhinYuUDyMfrhS9w0ookx0AnxXo3wj2uWKOQH4vMHo3uU5HH2wR3VtTzARuovwa9G9V9ZfAFoFjpXgRt3JLoCWm1ORiVze07tYwp10k9cNGC+eaCJOKH/2uytDDXx8/kcCV4Hl3OlEY9fiI6mRyevXzlpYd8tNlxujTfGPzXlecvsNtZ0qvjpsqdxAzse27i7/2t4629790IIWp+kmi/BPbzIucPpTaFT80/1Thuk1ZybQCbT/lWqYzj2R7p01MqbYL+Yv7aJNB6h738EfKnUv7eZo/af4vj1V/adE91O5bzA7I45jh90cfZBtvo/QLgi4IfCXoPyn6F8DND8XXWegDyd2p6Sx47F2V5X3W0VVvj8uiiyKFa3oH9P7gl1i4ZbF/oWpeuEOGHInwVtAP4pXqg0zUSrVopwLcEdW/EtV/FNUvQAZtzaZLK/O0MR+uwwQNK0hvKg01kV6wuNjKZxKCSXS4ZqF9GuQRogJpqdzawx9BFFXqxdC6GlsHndLxUx5e+zYLNMHC9M6OtHwNOIk0/N9eHXW16zRotP+ui3SZ0ryn0kunE5ehp2+G5UygRyW22PahpyrdSX0hrbWHfE6BPHrWFmLXPrG1IVpE7+OPyWG6UFQSVdTuUboRdcxfd72l0SwoOlS4Z+FXij4S4cCI/psR3T2DNf7SKH//WolWFicDuqEFX6vaX+O2qp3JVcnknK7pqlE1uV1Ua7uEJH7a5M0mKXPXdd1dMr3fCp1X4VMV/h70jYq+UNFdoO3L6z3QexcgqmCtRVWX1OrXKH+lVr9WWHeab5ujs9h6U78jtxXa/pxGu2un134bI5JU/BA9Jey2Z7i7vNFQPY0mOADWVY9ReUO0Jz7HjZaUWh+p0lP/s8V78E39Ooj5acfoTs/XqCPkEaGzVNqVPb0M60+0HWs9vY4vq8+egRuH9Su+3WL9NvxJecbtnnb/Q9BnupjvPozbf/nS5DWLLu0/XY/To4v+rbRVHml0cTakNEWeHe5P2nkmqM/1O4gIt8Tob4Angv4O5wL+MIWS3iW9dwFiVbGqYgu7pVZ/g/LXwB3cIcJLpcsu208W0fRM4hchVVALatU5fkulXcJ+FUVEEAMyxc7AaXn8ybZZQL7Zy1pQVfdJuw5C8SKmrHPptfRc05Uh10hGmEG4h/JzUX6O8NSK+Q4Yg3af67lk+lCL1SsKn6jya1R/gbDRzGIdax7V24SmGyEHiX9EmmkA71vxg3Q0sVDShxRiamfacrDWlU5KO4m2zMW599aFH0b9ckr8PvidAgxJ00iFYCxYq9gCiqJkXbSZpfz8cQeojCiSQ9YxmSXXVqI1isTiTPgtRHu9aCV4FgKH8FkiXjuvdqS0K5MqTqJ9E3eYCyCipfBQigKKUnC7qwWaLY2Vs8UKmYhRMiNkeSnAJXYWObGPpwRPpybcU+BkHG09iu8rV9IM+OmmUED5O3DA6M8v0XpGgu/Od0l00TXOYotE87ujbO5e9VmBz4C/skaeayZ7Kjw35e16RqdouwvSexcggswC9wV+gfC1wm3ekaPECYx8OLqsvC+9DH3iNJ13+NZpvyXyKMf2YAayXNzfQKjOHlkLtoDRGMZjpbBO8BRFqRGbq6QVv+uheP6C2rK+q7oHGAwgywz5APJcyDKXQ6FQFMq4gNEIxoVDKkWJWioZH56yv6arSALohor8Wo08L3LzWA0vsWoz+x6kB+9TgJTmdRU2UX6F8teofoqWwqNz/ITae0Pd9TOFVlKH9PWAdJyWzhhonc1Pj5vSLNPFYEsHC7XYdzxh9vWplGbfPAw05/ppqROWqltRKMXYabH5AGbnhYVlw8KyYX5JmJ0XBkN3QVAxVo6PlKMD5WDfsr+nHOxaTo6dySurJr5AkNSt29fMkRKbwk6pkl2EerTrM8Vo9/XeoVGijtFYsVbJMmFuTlhcMqwsG5YWDfPzhpkZwWQwLuDkxHJwaNnbU3b2LHt7lsMjy9iCySDPSiEvTebepsd+ek8C/zxtpt6QjE08QYdPdJez5RkNoMn89aadTk9hEeFzFXmhwr+p4QdVXiG8l2297xWBqDJQ1Yeq+leq+itVtqBrOAdxp9CI2nNd22Q12fjTnhRbYbxBlBJkqbDJ9Ho6ZZSeJp4Ht9q1J/PALNOVbmqAhNRjkknVp5YM29JsIsZpwIurhtXNjPWb7nN53QmRmVk3QY1HyuGesrdj2dm2vHlpefWs4O3rguMjre35xp/IQr6qepL2g2n6SZSGV/bO9k0k3GfqCfsA4e9kf6koNqG07pcvhYct3eoNh8LSomFzK2dry7C1mbO+ZlhaMszNGbIBFGM4PLTs7Ba82ba8fF3w/HnBi9djDvbVIRJ1aQdXW3j1FJppmkKE05y2gxKoWkGdRIHpXqiPnyfvLCfdPl39up96AkXmx8TzqK+myls+6urvdcCqgSQDNoAvUH4llkeinKK8/UkgkKrfWasDtXrTWvuVWv0Fqg9xV9YmqW9QTqIPCbs/Jsh/EV4rbUlwJpRi7DZIiMDcorC2lXHjXsbWnYzVTcPymmFhyTBTIhBjnNnq5Eg53Lcc7Cqb25a1TcOzH4WXTy27by3jU8UCuci5tNuLtsdlt+elpFcOqnGJ9hCYmzNsbBju3Mm5dy9ncyNjbS1jeckwPy/MzDg0V1g4OVb2DzL29izbby3Ptwp+eGx48rTg1Zsxx8cKFga5h0QmMjSN6E4rUZdBUyPrD0lRPXajlKl5dklkKHfE6l+K8kxUX0npbFEm4JqL0ju/E11EUFXU6lpRFD8vrP2VKJ8CK9WBtVTH63IdkdbyKg2/6sgShQwXPFuLmbVmldbim8L0aPat297a3CZvDowWctvqSb/rjCD9xLv47m0vVhea85+HCCm8z0Krb+4WtaJQJIO5JeHG/Zx7n7m/jduG2XnDYOhs8cbbazfMnDCZWxBW1mHztrJ5ywmc2YUxP347Zue1re30lOsiPr9RewTFbdVVqNX5nSKo7+bmwKCOvEqL2yiBGMI+EPTDOKRX10G/bCGPss5VYW5OuHU74/PPBnz+2YC7d3IWFw3DoZDnQu6piVkGw4Ezc62uZty8qdy+ZdnczFheHvG7P8Dzl2OOTxokAs7k2LklN6lBt22yKSQmQR2nDxIGdVvf6ue3bMo/s5eeh0yid6GJXPxnbf6SKCpEHuEtkF6gbq/hUv9v5sOK9Xj8NjdNNnUryoop9BsRXono98AThd13bVPMp3GFfhESEVDNVfWOtfYv1eqvgS2BD+tH/gz0PjWYs+R12ejsrOkpuEVv66aFmVlh/UbGgy9yHn6ds3U3Y3G5v5lFIB9IvV4yvyAMZwVEKEZg7YidbWU8dgIqNxKO+TKhrgwS3zsn8Z740+Q1zfvpLTLxu3KGcdcfuDllMBTW1zM+/WTAz3425P69nI31yTviK8EyN+vMXrNzQpbD6chSWMuLV5bRqcsrz/mwmxl68r4y6OISqLcs3WClIiPKLbH8nEx+rsLvVeRPWnrsFe2PfF7K39MNSGsCXwN/q8o3iEMfldsNIKEdVs8DjbAVqgwbrA0kUUo9CMswIZb2tdlg668frlNLDFCHn2c3YtA4z+jgYx9qaReh/S7UrMQLmkZ7VSF8HbFzbUHE7d4pXGrDWVjdNNz9LOfBVwNuPciYWzj7rJMPhY0bBmtzbKFYVUajMbs7BUUhmExLpSRdlm5Sn/ngM5YO4X3xRCGTOm+QpxCm1y27fNTcXSbFmf4UJwTW1zMePBjw5ZcDPv1kwNLi2fUyY2BjLUOtMho55DEen/LilWU8VrK8zbEGGrCvZ4fbjCOQopLovz3tEaSXQgHaEbaaM+qQ0jyrmzeBUurXAe/hHTb+23grfIU6gjT9sAlU0ZSzoyyJ9Dy2hsA9RX5lRX6wRk4Q+QHVEZZ3cjYkL+w7XKx3+89n1eoDhW8EvhbhJiX6+Fi0h4+Fz2noUhGIui232UBZWDbcvJdx55OMG3fOJzwqygfC2qahGOccHVrevrEc7BeMTtT5rjYO2bZUimBMpkwMoRklqWjU75pJJ0q3S6hGwtpXENp8RiRe3sFhpXpSFrdofnKqGAOLi4Zbt3I+/WTA/bs5KxPQXh9lGaytZnxy36W/u2PZ3R+xf6ClvzR8S9/7pZRFK/3zo6YLIhBKhW9Jka8VeW7FvFSRl6Ajp8q8AwQyGheXnqgjRURyI/IA5C/U6q9Uueus2OrWRRK9MUYkXWgg4V46SiSBAro015ZmlJ4YWvwEKlGSP9LvWvend+2sqtGARgqaNgkH3KUmx6768ybUOutAe0zy3oRRdUfS8qGwupVx65OcG/dzFpYvPs3MzgmbtzJ2t3OeP7G83S44ObWcngKizq7f038S2ln9zEbI0I8fljd8Ll6bB+8SimWztlX9DvOOv4V81XzjTEqjMczMwPKy4d69nAcPctanMFtNouFQ2NrMOTpWnr0oeLldcDpyJkosGJOWIPHuJ9IaPbS30nbdNe7HrdtP/A+PjzjvoDtTj0XtRhx1XGnSjFCAhF8S2Uf8NT86bzisxrg2edZ9KURwPooK+CuTm8MdLjwAvlfhTyB7CPourE35uHinAmTZiPxMxPytKl8qLLyjzM5Nl12ll6nht+gDqH5d/NbCQ92W3Zk5YXXTsHk7Y3nNTOWKZBqanRNWNgybNw2vX2YcHSnHh25Xlhh3ZiEUorF5pHkRTixpAZL+3e/rrEq4/J1EKx1xpnin1bOyDIMBzM8b1tczbt3K2NrMGA4vp4PMzAjraxk3tjLW1zL29pX9Aye4EEhfYNoDEYKnZ9ouK93pnYc+BFrpBwzdlXEuXl16Iuiaqn4hqr8Qy+9Q2Rb0jbyDKsj1Ha2BCDqjcMc6VyV/gXJPVWdq5KD9gyhEbOHzSe+6wngMRi+iSagO69l/gxlLAy1gmrzbJo4KMVRazwS+faonLK1/hju+2ppLO8HQVUuocXVpx5XLDFXIcrf4vbhiWFo1zM5frqRbWDSs38jYum05OVF231pU1W0FzppCnEWAdF0Y5v+K2yzuZbYDrbQ0w3BNKwqb+hajUgvlmpB7t7pmuHEjY2M9Y+Ec6x59NDdrWF3JWFvNePnKsn9oKQpnNvNRQ82vUi/3dJ7b8Pp8peSH6xGhRp16FqSSziOU6H4bTNgJ5coSqv096dX8pWxM0kI0ITVl8vIL5pWod4qQrqd2eqK6aSw/R/Q7VV4Bh7yDK3Df1S4sI+5wy9cov1DVz4AV96oN97soNaz6nvtPptNyGjbqKeMsVTEx7PkEc+dBv0RyndpyT6gkV51muA4OK7cZUG/DnSt3T112dxrOCutbGXeP3GLu3o7FWmUwkCTSmUbD70IF6WdpgZJKr9+vVTrdPj78fmzVuX0B5wBxZSXj3t0BS8uG/JLdkIqBhXnDynLG3FyBiHW7saADbPQUPEy77339ylPSOifz3kwiriiTmtzDfWVxYpBKS+jhr4fxqsP4CmpH8EZF7KsIXxmVoVg+McLfqOozFZ4CP/ZEPhe9q4OEMyAPgV8qfAGs88GNMB8g+0sgTylpP0zQ+4LolafXagvuzKz7yweXn9dg6BbUszxnZc24E+qly47esdmX6BkEiEwhQNK64qQ8YkQTCRcfqao33xhhvjzHcZ5dV5MoMzA/JywtCrOlUmC9/K/pQ9C55q8NVH8h8CfgX4HXXDIKeVcCZE2Rr4HfAPdAnY401cTXHrCxOak706T2GU4WYSDpySvJYdu8MN3d4F2TUKzO9QmL0NwY2tqnqcdWekEm/buTGrJl3mLcFtBs0HaSeJmU57C4bJhbEDZvZG5BV3vNxxG/V4lisRG/q6lraUEgM+4cR/4OjgIb4w4bzgyl3qzgvPgG/SlshMqUFTHvB5E4bPWoL+4UC+7dCDORZxBomrtcvEyDeH6HnAIx9Xm/7jSb9SG3rrLoHHAX+FKEL4HnOBQy7uHuTJRf9lBTJ5S2BL4C+QpYu9QMrjhNZwS63PQ+CEl7QikfXX424raYZpnA8F3lck0+JS1T1/Sx0gLwAKfQ/4BDIXuXlXh++bBU1xQeIvK5oPeAuUm2+qTGG9qVO+ya7XTUi9u2F05zU12YTkpb6bwjPPhMhjlLegmkEA7s/rvH21lFZcPTzLrQSpherQwJiEupKNzhs9GodDfyjqi5KKmLQ/H++180royoD3SLwdT27HS8fppG7E1MzRsLIoKRyUjsPGQtnJwqRyfO5buquyekGVJtuJvU3qO+Gdd90yzdhYjvQq/iplBK+0vfzYYxWknFCRJIjrdQ+5+MFLryjtPui5PKuzPPm8A3II8Q+YHLFCD2Ur3+yoy42wW/AL0HssS1yhjRR49AxJmvVJ1H3eMj5fRYKS4NGDc0HsHBvmVv1zldPD11uCc2l00SDj2D1H8SmgPqhYcgH9Lmy2lpkpkwGcdbhxgOheVlw8Zaxvwl73yzFo6Olf0Dy/GJ42s6p4rXdEVpCeRLkD+B/DfgEXAp5zdye5mdQnXdqPlanLS7rYKJbfMpTT8e3LV9/wwLnm33Hf1adQopdB2a80N1p9dMNGEZ+lBAxI+0w7QdMIbppHlphY3QyhRlaq27VPH9SbYUIOWlREeHyuGB5fjQovbyzoEAHB5Ynj4uePLDmDcvKzfvSp5LeSS1TUlNTdvveu8RDzW+4AR5qv6i1Pz8OsZXP2rUVjrVTopqIdtaZX7ecPdOzldfDLkzk1/qTqzxGPb2LW/3lMNjLde7xDlGnaCpx4ihz94favgd6xyt+Ok4rTAhqkiz2g6TWhuZAkV18lXz0g3P+sZtL191ntWriUhkDngIfCnwAPgjzpR1YbokBOJwrSBbwM9AfsZHsvZxUQ3/SiKEd0jVpCgCFM4v0/GBZXfb3emxvK7ML16OVqIKuzuWx9+P+cO/jXj1bMzJiUMF1TbeycK6eR6ZACNTZULIBMInGSZ4028KbAskX9JHSkQo/NW5zB+PnADZP7AsLrj7PlZXzKWZsw6PLW92LK+3Cw6OHF9ZJj3eZK/pipMBloF7Cp8L/AHhADi+aML5Wc5MdJLr6Qsichf4SuBzYLFTWw+1Od/VeMdn875HW0zEmYRA2msCVbrdeXZNHr7Tw9gRZA8vSbtqk17f/em9COQMYeNJ0ytv0FYVP4K4dRALx0fK9suC548LllYMw5n8Urb0Hh0qr18WPHk05umjMW+3i/oeHTehJcoXd6nSdh87rqRUnpLtUX1WEN1DhpMFiLR++VSpa/FBx0SdJ1C4VTg5UfYOnQuZrc0RK6uGmZmc+bmLQ7+jY8vrbcuzlwWvty2HRwq4u0RMLbDTawPtZ9OvDfSvG5RhOpBHGl2kUFIQKBx3KSQzRTkjJ4pnWQNJpBtfqtWHLiYij8C6ozeAnyF8j5FXRi5+LiQ39uKdToUM9JbApwgPgE3KLcLTaOj9UO5MnJwn0qWmd+X2yveZazpoqiJUKERgNFLevrE8/aEot9waVjcvphGfHCkvn4159rjg1fOC/X2LLdy5k/qK24Q1yXgTQ/VXLf5Gc3a18J5AIHXgYHj0jN/E4Cca1b5n2E6KTDvNY1Wtr6Z9u2N59HjM8nLGwrzh3h1zoa3UJ6fKi1eWR0/GPHtRsLtnGY20vljqGoB89LSs8BXCj2L4FsMTUazUA4Uzz7t5Zi9wFERLLVR0TY39Euey/Tap8yVCNDN1TVTaeheUTOJ402jg4ZOUC5KJdSi07dteWF8Tjieq4DMxmXXRpMk81HIjFyY96cW8d9VWunxi3BZbVdjbtTz7cczsvDC3JAxm8ol3gXTR6BRevij47g9jHv1pxPabor4PJMtp1lik6Suhq+qqu9UChO42S5qwwjDe7yh+GKcDVfal6zOS5MHrM/nAXeJ1dGR5/GzM7Fx59/mcsLGWnWsNqijg9XbBt9+P+P23I569KDg+cTdMGuMEc7e1IjG4L5u6Kv09ZD0VnUW6dpUlGagJGuUwVTqtsHMonwFPEP5/Ar81yp4U5fg5h4KQZ8UFbA1OgIg1xW0VfqmiXwNr/qTm2rcNKaOdLVMxrsGvWP08G9rp1gR7BVTQaOF9Ge1n0/CRfh7eC9JLrfzSAjISDr4gDmesJHwOaq50pJjl4jzEnjoU8uTRmNlFIc/g1n0nRKYeWwonp/D6ecH3fxzz7e9GPH1ccHSomMxpwVnulUs8vsLm9IRLl2KQXhBu11PfGA3f1b9bpop0v43bxYdU7cL47BmEwcAJ7fFYebtr+fHxmMUFw3BGsOru9sjOsKg+GsGr7YI//VDw738c892jgp1di6o7yNnswOow/ySY7TINtcdSGml134NOwkQUa2NxW3lmnM5ZOJF3lyKQNHd1UOqgY/AubYYLw/ozapB3OF5TiNo9HIiwKfBAlIcq3BxnHJKff0dWLsUFMK8KGJ01ovcs9uegX3IFPe5e0zlpCu3OGNcNigJOTyyvXziUUIyUo0Nl41bG4qJzsjgzmx4d47FycqwcHijbbyxPvx/z3R9HPH40Ln1fNRNZrV2HGlNisj1TORNJnjedqcJ4MsJHSf67rvQyA6ruQq/RyCGHP343wiocHlru3slZXjIszguzs2mz1rhwaykHR5btt8qjJ2P++P2Ib38Y83rbMhq5djQGSOx2e6eU1luu6XIoR7lJwWejjM+OF9k+WeB1kTsUctZLp/KLjRgANhH9RNzC+R2FmViDV1APgUzUGPx3ocrvPoT0fSKt9HxJXEevZhofIfXz09LUA9TUt5OnkzTFY7dpLRG9nXcSjbX132nuXmlMKB4kmQCTK3Ncljvt9/DA8uwRHB0oO28tN+/lbN3MWN0wLK0YZuaEmYEgRhkXcHzoznfs7roF82ePC54+GvPqRcHennPiV6EPMVpzpyVPU5WvLFuyX/p1lC5i8NbXKEN0kX4+bR6927sDqjYSYJXjE+Xp8zFHxw6RvHxjuXUjY2sjY3VFWVgwzA6dubEo4PgEdvctu3uWV28Kfnxq+eGxW/fY3nXrHs5dvjusqAEfEoyhZmD4d4Wn66ajNBOfR+Os2mTijcmmG6eRTSufyOY5xUTYi340CJNIb2IxfaRUzU9SvwnboSvd3q3mAlKwgvLlaIZf7C7z4u0tdk/mGRkFc8azXDmDC5wnUVkSuK+Gh8AtYPb8iU2Z5ZTP3lXeF5e3F8l/gmr6AajSnk3ufoxHcHignI4Kjo+V/T3l7WvL2oZhedUwu2CYGTokMR7D0YFlf8+ys2N589Ly8nnB9quCo3L7qMnayKNzEPn8fER0EX5N5tXjsTIaFxyfKnv7lldvMm5sZqyuuPWRuRl353lRwOEx7O5Ztnctr18XPH1R8KJ0224t9Y4rY3wG+/rcefrjBfvw1RkCU9F52/ldjHixzFLwiSrfHM/yh511/ni0zEgUsrMKEBme+xxIjsodlG9Q/VLR9crhGsGhsy7tKzpw5cWLrvX0EuzS9KJ8vBk/Wn85S3oJdNFcP9pKKol6+tFFqAV3aaEah5VY0wjroP5M9EQNvkW2Z/V5DrhOpCPikEKhyugUdrYtx8dOgMwtCvOly/dBiUCKAk6OtTyI6A4jHh4qo1PnFsXk7hY88bZDN30sqqYkn73tG9i40+7Yy7x9e3Xo1DKw3Yc9NplHD2KN+PKYaq68KDVUcfeiKMq4UHb33L0p2zuWx08LFuaFuTnDzIxDLEUBx6fK4REcHFr2DywHh8rxidsibKSs85bArlT8sC+Ix2+pKddjut3XJbkW0EYyzV3hXtw663Z6LQ6S9e9XcQp9il+kpqytIdWGNk26ibL0rfV05BnVQ4uCvLVCIs1NrFG0lLFGPARTVZYyI5Z7xvK1KJ8C/4PQvcmUEi9ncG4BMoOV+2r5Ri2fqmX+fWh/HxqBfEj60PmnKOQpy92EVlh3f8XhgXJ0WJC9Kb325uXOLQG1TiMejZxLlMKWu34yaXZbeYPtym2RvgS6cJGkcTZpLYwtHB4rRyeW7R139e8gb+pTyzCjsTAaKUWhDkEaYWA8/1qR6eoagVyErhICUXcmdMEod2ZOeLi4w93BKS+zEUfZqNJMpksrv8De7hUr+qnCLxQ+UXS2vT011vzqyqjdQ4SahnjSM9TgQvugJ4nr+8MDDclTT+o7xlP2xqTO6GuC/vu2+tDSWGptoZ1ayFebh7SG7/MQtmg3WknUeWijrfhR70nVDj5y1DC9gC+va/t5SpmelIhSrUMa4zFw4i5Dcof6qnuqq7suFAwYcZ3IsdTOI7qr3me34r0qixcobtd0nacOJjZt6vexqqO3UWjEH5rQjoMpQSXorx5/3k2TsVM9b6RJqaGKq6nK3cm4gJORe1btpFIFW1rUK76rMx4i1Avmte29rhNtGAwveSoXItRfEwhucPRruq7Jukxh2aq8xKu/9hiPUIDXdjWCSazRhPz56KrVG/y5IxyB3piMx1cbHqRRVFAWL+Ga42ANpJ1PM2+0yqlefdZNFM+1asBmisDG7CGfrr6Ury28GBzyKD/lpF3YfsqLcwAQUeeyXS0PrOp9q9XW3ZimQgw9zHZK7rNuF3jHdCkn+v30gk9Hknx62dSX+qScq/fVhJUhtRPA5k6JBlaLeLcYGve0BfG9ees89C5r6rLTPreWWtarSIMAAaxKU4c0YYyRei6Vaq4xpZljqhy7++EkjTmdfpDeB0AXMV8ycbidbcxPH/hdz2y2ORQ6O3vIw3zEN+aUR8N9XlQCZNqy5eNiOnYb9EAmyhruopI7oBvtkI3EVPzKSGiCwWfrXUub91KXRn43N0K2NZhaX/BGT1fevouLZqC147T1j9Q7P2Hfp1FbG06nVz4LNJlaK/MyCG2nvY4RA82t1thUo/IlLwYqWYzWegKNutWuQTqRb8tQDRVP801ochrcQdqqP/VaRJryhmPer6PwdkENnvsp1KUK2s5lHLRdx2cLUYcauaZz99+F17+qp/EKQXrlVwGH8hTQUniHypZxabvtva6GKg21wkO1NaFp3AgFNfXvNWDH7isJ0/e16Giy8tFC0AA1Wk7FqYKE7SyR9t/MU0FCiTM8TTs0YzMpcDxq2ikxRr11iRYv+HXbrptmDcTjMexTfhR/cNDoYZUrInUuG4b5sd4bHOnX5pTf5sfyP82Y3URxOinn+Gw6B0Ju4RbCJxhuizDnh2sarTvdXn8xXfH6zBcd3Gr8KMrnjKXvfhQm1Jr7Qs0q7lThr6RQnchtT537jEX8RLPkxPT6QqRMgpWgsG0O6ned5ZbE03C+96oztUkijpau82T+0/BzIYSk3fH9csW51s9bYetPqRFGo1Q0gfzdpuHEVbVPu8+klJVqxgqnwlC5SRXKF4GhSErFTQvtZC7B5JkS0lNRh9LUmoNCBsIi9M5T7Xe97RtlkKDEq+QGoKo5FWMK1sXyUJT7NmNVhRcyeaKpKZ8/nPIgYZmkNQzGA701yvUzDLcUZjq5b7F9QUo0yGVQqg+8M4q3X3SPmZSkjNJLhZ8i3jQ0ZaX49debY5eyeRYKYZAk8jxTP5luyHa9PU/eXfKtrx+erSXjVCLXJmepozMtkk6ncExfHk/RCbZLnZeraePJeYVOT4pd1K3yJB5GGsO0FCtNoqDlcgSG2zrghlh+NAWH0wqRfOlgOkakVB1HAxYODXeLAZ8VojdxJxsjbTalUYZaSb3omGjhlrQMqAKWnWaf6n9nXC9d9dskhr5xibrT8fl3z7QVJpVCbd7yFmlbY6WvDIk2Dus9Oojp3+nQgTxaWouGz4LakHjhPuIppQV11mdK002wWWvOWrehloHEy7PtvTnkIXjhhW/fLdPVn9sUj23/SGZQ51W4Vt14ZopWGfwcpBW2Nlt4W2BDPtT/4fcHSY3JQMtOeZoMFr/bHAbvojr30Eqg2RPUOUptxvTrv6qlrjm1qZvE4OkygfWG7cU77Vc9W5HD8qVc6YRliuvRn2zTk0+rj0Z9qHqgNW8qLAncEuG+FX4o4Akw6i5sQ/ncyQQBUs07CmowGFYMehfDAzWsYGsHqO+FLhmAfDBSxW1jLXch2XoltDT3GJwt28Tj6s+apDGBqZbbhdXtOmopIqUDQDHS+HKqInbQe63e9zloPhLyu3l1eVah1fdmkhTj3LlUW479bceXRT+lodZXltKcNUTZtDkPRnP8/mSeV+MhI6TUqXsSmHwjYfneWFCYA72lwr3C6C0rzEmVSaem5ms8bcmbLFAUv/xdKyWp0qRn2FTIri276bzjbzXntQacSKSthDRhtMlbcesB9e4k6wWuTgCrIr5GGfKeABBdGm+0mJdAGZ5y0rxLafJQSzUp3/l1EWtR3T1wmjoP82zVH00dWl+5V/e+dZg6qq+2htnW1NP9OdXDwvRbnSQsTag84tdjGTIZP6BoIb+tqabT8eMEaafcdER5dvxOopQ0v60aCcL4fVelESJqm7YV07QtRN72W+k0VeIhzCkEd9Wq4UJ4PKeRmNPSyKvdc0LE5edK8C5spzi9GmlFefpzVFn/3vZgBXekQsnFslkYPjla4t7bm/xwtMKBGjAFYadvUb436fa48vXwlGx4yqpYvYNyU4VlazDZZV6p/lOkcmZwe/NLTdk275xHW6j2U6p12pa1UIw9AWAa1xXvi66aFlbVYWG1FhhSaqL1PSGUiEQVW96YCNR1XZ2ylvLZlSvknynZenw0ioGIa9vhoDTRSSlcFMbqHELWZ1myEpVUaPOC7fpT6BZTl8FtK1u1woOTOe7ubbK4u8VzzSAfQ9+ltfn2ev+MVBgwCgv7zK3s6i1T8CArdAuYVWhtofSZTh5yq7WTQLvrkWHxllMvvSDXXm0xkM696y4RD973hJR3z2MNvQEj5YRXKIV1z7IB5ENhOOe81Oalf6iigNEJnBxbTo6V0QnutLA6RivYXqWtQd5xp2kjER/qR2WIDlv21UWj12j0pp1n3HZ4iJIozzCvxmTl6q8o3bdlOczMCrOzwnBGGAzdBDIu4PREOTpyjgZPR04gO6fVivHOnqj42mOT62TMlKjHBHLoqoM0Cg9RRepxoA2HSCQRNvzZHheTkUwYtm9i6toWO4k/q6U5slxrzQYwOxDmZ3DtmzvBXx2OPDqBwxPl5NTF08IJGdHGpJXOcwK/HmfxAcdE/CSa6MozRArVmAwYprsdem92rD8T80G4biXeaop7uAL6UIX71siazRDNUKukYV5J+e7SBAGSVeYrnR+M9N7MCQ+tsIFirthZvitJTmN2bj0UGMwIs/OwsGSYWxbmlwxzi8JgRprJ78h5qD3YUw7eWg73nX+jYgx27O7GSPS5S9eapknvfXQBq05oWGdGZTgjzM0LC4vC8rJhcckwP+/8bJnSueDxkWV/X9nbs+zuWw72LUfHZR2qkmUgRmLLzTW9V6oER3WgeWYGFuaF5QVhZdF9Ls4Ls0MnQEZjJzz2DpW3++5v78D596rWwzLK0/UftGQfnnoFvfcpAmqYFeVGfsyd+W22VFnQjIOsSGABj/Jx3l/N1ggqyvGsLu4t6YPTof18PNAtUYwpsWbb5hZqsZ42FjCS1oRDNBFo0FMgh96dS+G2qYRGHmuLYSoJ7SSRn6pDD0V5WHNmXljeNGzezti4ZVheN8wuCrNzQjZwk5m1zi/UyaGyt6O8fTnm9VPLqxcFu9vK6YnTxLPcQXopbTHq15HPfKJO4nJqq2762qPLzpqqp7PsYovxqiNbIrdxiTpm54WNzYybtzK2bmSsrRkWlw2zs0KeN3V4eqocHiq7uwWvXxc8fzbm6fOC3beW05GrqwzKi5d8xJDmJ9bqetamUrFC5NHTR+N3KRt+V/v69vmu9OPMuzTb/rvMOzLy8uhCZyKubcdFKTwEFmaFrXXh3k3DnU3DxqqwNC/MzQqD3MUpCidEDo7gzZ7yYtvy+KXy9JXyelfLtoWBNGavGsF2lD3Fb23i9MubbLsp2iF61xnkTO0Qjd9k2Oqdj3ba7eLuBQSxrMzucntF9d7ca26o8FiUk14Bko973lIlrqKiq0dz9t5ooPdFdRlETNEPDyOaAFnOps1eUPd9h+qJ0uwKstZdxTo7Z1i/bbj1MOP2JzmbdzOW1xzyyCsbbxVflfFIOdyHty8NKxsFs98bnv4w5u3rgtMTGlPYxJvn0hN3ks5RJ016cae9DKqQh8lgfsGwdcPw4OGA+w9zbt5y7spn552HX58aIZLx+rVlbc0wOz/m8Y9j3ryxnJw6wS4iYLq3dZyvJNfQfBJVax1WXR9enBdubwqf3cv4/F7GvRuG9VVhbijOvbyn9ynOjLV7oLzYNmyuWhbnLPlTy6sdZ9YaW8hkmvGRpvfTgh8CIwXzQcWCgFgGw0M2zBEPVLgHbKOcSBSroTwfTVgFF0B1QdAb1ui9cc7trGAodbSWzO6tkyBkT4jzxL3EmBdpV8Ftzx2Xi+UG5pcMW3cy7n+VcefznLUbjfDoSiQfOFPX7DzMLxrmlw0zC/D4W3j51HJ0qIidwgyT0ELPVbzzRDoDXz5V6E3V1aMYWFwy3Luf8+nnOQ8eDti6kbGyapjprEMYDoXFRcP8vHVmkZWMxQXDH/844vlL5fjYuUA36iap1OJrvROnpUo36JU4SlDOGPF2hz3D87OEPU86ffG74KL/riOsc/xYIg91pqbVReHB7YyvHxq+eJBxa8OwvizMDLtZGeSwOCcszgnL87A8LyzMwe8fK49fKkfHipVqUb1UsaeRCmft51118h5oqpmtk7+2laAKKwVrA6sPxfJArHxnYLsv+TwfT7xQKge2BHtP0VuiLINEyCPyH6XNmy4o3WUucM8C01XPYI3MIUkzV2ham4KfKJ1uD8M+VTZ7BOYWDFt3Mx7+LOeTn+ds3c3IZ2RqzWh+0TCcUeYWhZl5Z+MfjcaMnhaMy8Vh8c6KpMxt4a8A1FaF6y1TWCddpif3rCM9L3B850UzHCrkphYQZW7ecOt2xpdfD/nq65ytmzkzZ6jDxUUnaFZWDDNDd3Pi2MLLl2NOTxVVrQXxJHOc/6Sv/8ZFTtsv0nEnv+tK/2xxUnyVYXpNV2d4lwhb1b+IQx4PbmX88nPDLz7LuHvTMBwI+ZRtu7QAszOGhTllfhZMZjkdWZ68cqau0lt9bc6KqHdjQL8ZzqfJpkXvXTh2zlSfRKO0OZAYj+ww63CubNIARFHDkhoeGMsDY1kzKj/0IhBjJwgQZQG4J+hDhQ0RsmuAniZfc1aFwVBY2TTc+TzjwddOeMzMn12VzwfCyoYgGZwe5xzsKSdHys62dWYYK+VW4DRP/mcX39M+n074Tx8mma82229nZoXNGxkPHuZ88mnO7Ts5wx7U0UWDgbCymvHwoXAyUk5OlZNTdyPfuNyYYErt2F8XS/E7qU7PU9eT3k0Kc5G47zLvqB61NF8pzA7gxrrw1UPDN59m3L/p1rLOQgIMc7ixJmSZcDQy7OwrR6fwZldrQZWLuyrgDG6eriS9a+7VMI9wH+ET3GapHOi8pzDv3eTraK28tepTxLltb2s9gbYZaKhJJsNPX3pX8TsQQ3Iy6pWuHdqwFybaUtq4+U3wHiAt/12pOVe36c0vC1t3DXc+y9m6dz7h4dPisuHG3Zz9HeX4UDk9VfZ33EVMVCeuI35DPuNvE2929N+FddWJefoRXVee4OpvXLiNAssrhnsPMh5+OmDrhjmX8PBpZdXwycMBR0fKzq5lf9/dAe5MWaVJMMWfBv0nUb7GWtBt0+mfbCfbpeL4YbqTDcRK6Oc3kXddmETegVmkfVdP+bq+k6MJa2nOemQZLC8Z7t80fHE/4/6tswuPFrsCa0uGhzct23uGgxPL6Rh29hVrlcxUjAV8hWVKblhov+vbKt3nJXga5JFCHH6ctGueYE7qMVX6fSBkT92/GXHXk98HbgMrCq8TKQKQT5BpAqyBPAQeAEt9gf/cyZ31AASGs8LSmmH9lmHthmFu4WITHzh77vKq4cbdjN1ty+sXBTuv4eRUGWh50BDiTkG6A06c8L20ulGFdnbcfgTSIbTUmf9OR8p8LiytGG7fybl1J2N+8eKnKI2BtTXD7VsZP25lPH1m2Nu3HJ84DrK8GteTFZhOASL+M229rNW1HrRYv5P4hZqgNqtJ3ESBe0wujR+k+knnxKeJia/9pd1fAoFZh3XbbEdjtyC+OC+sLwu3tww3N9xOq4tSZmBjRXhw0/BmD17vWHYPlfHY8fhxY4/3RoIyr8qWCrcLdAvYBzlJBc4nJDZE2FC4D3IP0cUmj4rS0q9X0+qYlFzS3Rp+63cKQUgUqv4VDfZALW51sGQZJpVT62272UCYWxBWtzJWNy9n4qtodkFYv2HYuJWx/IPhzQvLqDT0VsJDTFMn8bBMaMeJuadzEosVl24BEqIVXxkL3lXbOisT0mDoznmsr1fbdTOGg4tPMuAW11fXDJubhvWNjL19y96BRQsFcUjO56vFJ3GfrMtU1kr7GpN2hZn6dxsZe0GaTFMooBIUAUrWqov5zJn2BN+kUt3w2LyVvp0YdR1I8LsqU0P1XRlVeT1hU7jzZA5ZLhpubRpurhsWL4jMfVqcE26tw50N4Yfn8PytMCoaf3PRWki4fTdpvWj9pJVANA+k66j3Xd8W3eB3Gt02yYdzVrg2Ezl/9cIEc+SaFX1Qgoc3oC8TbE0UIPMgG4jcAtaAwYTwf9ZUudfIjJvoV9aFxeVyfeKSSMQtrK9uup1dB3vK3J7UTgMrR4xdAr5tDmkLkNaEH2neQTo9KKf/eccvqTYfuMGeZbC+nnHjVs7qata72+o8NDtj2NzMuHs3ZzRS3u4UFGPnHSAzDWfRiPG9D/eaOptyhfH9F22TRCC1E6ig6wrV0HtwOw+JkqsFSCdKiZJJoDFTceU9awsQ8fgajeF0DDND4e4NZ77aWDEMLnF8GIHleVhfFlYWhNmhWw/xfWddbk/66VHZfgtWuINb+/4OeEViOPQ1XY4TGjcUbgBLYadvI4egAycEpW+maIXx7ctRh+4YyOqhgPAWNI+FytVKADh8xr3BHuYV591ZBtwCnaqbzGfmhMVVw8KyIb8kzbmi4aywuplx/7OcwVA4OrAopfAo3XR0uaBulyWtS/eix+pLnwkm+N0nQGqSxh8S6kxJKysZd+/nLC+bSz8xPjMr3NzKGY1hYcGwu1tQFEqetRFIRL5WX3n4C/1R9yC5pt8kBEjXOkTfwxAdtN6lMILHn8RCIaQWd5GmmhZMfmD/3djCaKzMDIUba4ZPbhs2VuTSkGVF87Nua+/SnDvBnhlQdbvvau+9waFZX9CFiLl50wPVoy5QoVFvNtHgnVeT0S2HUV1r/C7MM1IumsCRxSR0f+TNkSWf84rcAR6ArpUYN1ow7xMgs8AWTnis4DwEfFSkdE8EfZPkRfMTcS5LZuZhOMulIhDK9BeXhTuf5KxsZIxOrDcnVBA9LUDa/J5dgDRMxBFC4ZLaTt1H1e41pERxc4bFJWFu7vJ1xkEurK0Z8uGAzfWM42OL24tQCuDqWtkOBKEVwzSTT2+9hXNP0sQxDU0SMqnpXBK/yhBnESDRs74JNdISawUhLw8Ori0aFucqxHd5lBmYGcDs0H0aEcaVh8Yp6V3MDx8ZzeDm/1sKqzjrU7QbK+9Sc9QtmN8S5IYK80AzUZRzlHrPOpGw4g2WQKOfppXEy7SVaKzhprqzhg+q515gx2IbhuM963MDIt6XWmCJ24U1GJbuNd6BB92ZOWEwyFhZV2xhap7ia3amFyCp+ovfJn6GEXrmlV7SpruIOMFrssufYMCZyBYWDLNzsL5qnOmMpv4aN/gBtVyXa/xsEk1uFvoHxvmFaVKATEi9X4D0UE9gEVf/gyy9c/AyaJBDnguZEcQo6rsl94R3o7Rrjcia8T8ZETZnzyrEEQpQF1GB6C70QPFI13U4wXp5B4G14lziUFEewfyHevOc+8wVXQduOATCLHAU8pB3bB00ONRxS50Umg2LGJsrAkan6GUpyNaVXme81PMe7S5urCafuEyTKQ5TiiOldM1eP7pUEir37gJ5s7+96fTTZJjWTK+C9lWZGt6ls0MRpw0bEfIaJUaQY5qULpexs6R3WY3Wl+V50k7pMd73ylX7u6LqfrZowuzij26LRfysbbbqq57WfBPNcd3xp0lzmncTmy7VBu6ZQXUBWMctZSyQOJXeZVwRYBm4CWxS33seMKc0Eq+zM3SrXFMpY52xzkldmVVqb2cWXdNsrKVUvqxOT5TRqdb73i+TisIdJjw90dqTaZuTdidvSfSOjhyfDohRylTUpepKtyyttSCaPpXnwsyM+7tsTVXV2eNPT93feFz2Z9HaQeVE6lPXvUd+cnHVdOOB3h03nUyck84iQHrCal8gdctGxrjDfzMz4kxMl+w516pbrD8ZwaigXvuovJqk+PXXQLqpD1adIWySwpER9oXzkC+1U/n54ZLRh8CqKGsgSxAfKsyjeywcZc5lCTcVNoAZX4JGN9YlUH0KetVH7oM9pkkJHEDDaNGH2K1I+z3JPFJefbUUHhEqkSBOIpPWNrly8rFWOT5S9ncth/vK4qqSZZc3RIoC9nfUnQPZtpyeaqyxByuAOoUASQv5dAc8W4du2luDR377VFoj5YCfnTWsbxi2tjIWL3ErNLhzJm/fWt5sj3m7q5wcW7Sc3Hxh1Xd7Zver5kWnBpxMpF0pU9Vxap6aqBknmOkEXhIndB4BIs3VBpXzxM0VYWPFedyd1nXJNHQyUvaOlP0j5bi8L6QeG5XZKDzo6JmX6rmiU+g3/RQpD55GdR6rc1G6/lwp1Vhrx2vuqE+M33BuS8rsqpwdFh2vecP5r9Qol0A2RGUD+BHY86N3IZAhDoFsAqvatX33HULQy6CpTFCXWYZSmFoLRwfK7rblYM9ii8uFHyfHTnj86fdjnv845vhY3XqBr8lF9tXu2kh1qupLdAK7T+h3pXcWAaK4K0xRFhcMDx7mDAbC3Jy5VBR3cqI8ez7m2+9Oef7CclQKkCxzpsFGzwiQnE9TeLGszSIhIJR2OPetUlyqSS5KrpsHf1GvrtNOzTJKsPfUdSRAwsJ46YRhvOQqV+x5DqtLwsPbhi/UMDdzeQJEFQ5PYOcAdg/c93EBgwHO3Eu7PaL4PsMd7y592psmwbMCmilpCnPYLLCO6BZuXfwAbzdWlwCZV5E1YENhGbTt/8rrP0lp6oVJIoVODTh+lrzZMHiXRg7BtrgAeVSdyHcdoBrG8NPv0Qyq+hAQ4yDz0YHy9pVld9uhkdlLOIkOMDpRdl4XPH1U8N3vRjz5YczJiTIcipv4Kgo0l746JgzTEiBViBCVdacXT0ZN6C4nziqNALHW+cJaWDCMCmVpySGQ5WVzaaasnV3L949G/PZ3I549LxiNHEO1AKnZDNrd+97svopRcrcACTTfBGm968IfLx2o5Az3dWhY6X7ZIgTineeYIEDagi545yVcn0Q3sLwoHJ7AzNCd2ZgdXs74OD6F1zvw4q3y9kA5GWlpmnTb6+OiNDNzM68I7Qqp+n4sQiKBUwt/HzGEdVJ+1n3flw7VWAyQQ29/CeatOmzK4WegpPhvA12kxENDFd1Q5A7KOu48yGmVWp5Y7TbAIiKruO1bs51Saoo2v2SBeXk0hRA7D5nyFPjxkbLz2vLmRcHutmFhJb6z4jx0eKC8fFLw5Lsxz58UbL+2jMexAAmh71kESKN1+gPFvbVJmBykFwqZAMX4vAQ7PxpXJqfKwaFlOAcbG2NWVp2vpIv4S6pob9/y7HnBj4/HPH4y5vUb53/GGMp70+OJIe1fSIIwacjQrsr2RNNuheqdbb/zBEi0Eb82vcQTYexptkpPG56rNx1AK9XekQklMVemFA2r7rZIBPaPwIhlfRnubhlWFuRSDhTuHTp37j++ULb3Gq+/8XbsdPwrO199INL6PKDeQlhTIccXIIl6nAHWVHVdhRWFvLNSNYEUok4VH5X3orefe8yk7ucOcorTa02abW0hlYf7rpHLjVB7SqXX4qMqurhtp0UBo1PnLffl44L1G4a5RcPa5sUOFY5OlTcvLY+/L3j6Y8H+bmW3l6jeO22eJOo90FBbE06dXjqN1JPwwFVScITP/JfG/Y0LZfuN5YcfRiwvG5YWnVv3i9DhofL4yZjvvh/x5FnB3p6lKEofWEaQqj9M6LOQ6Amxn4iE6/NKQw1TaWuOrXcpDb8KGc78/lpebedPpRcIxroIiYb2BFiSv7R9L34iDuEVCken8PKt8ui5cnfLsjwn3Fi/mCnr5BSebSt/fGL5/rmyc+iYz7JKiPiCMxSu/oHi8k0wD6RqIPYsUL6fAhn2Wlc6Lt9LPe/ro6GCELaLc7sTItSmiygMRdkQuK3OmW5rOSNEIALMA+sIayDzyVKcga6aRK+7/rtAIKWmI4CO4eRIef284Mdvq8uj8vMJEYXTE+XV8zE/fjfm8aMxb9+4iW92TmrTme+DaSpTU/jcj6M97yalF66/JCJ1pidOU80HLt7JqVurWFgwLC0JwxlYWjJnRnOqbt3jydMxv//jKX/6fsTbt+4qg5kZ1z6ZEW/STZelD3VrakLtMelE8aPocdhwYmpOPDdRtP0lMXmkhFbAb52+F7cjrF8mCcqZqrexdZP9yRievYHfP1JmB+5im63VsyMRVWe6evxK+cNj5dunyottt4Cel7cZTtoOftXmqStEOW4dfAtYxe3Mal4GEDXDnf+4Cawr7cCphdiuyaiL2nDekZTPNTVzJdLvmvhS6nKXJu5PbvG7WDNo4gRIq/yn3vgS4+zoqrC3ozz+bowi2AKKImd90zA8gynmYN/y6lnBD38c8e3vxrx4WnB06IwZWUZzUDFCVynyyhbOHimHfH1KJpC0X4RhvSrrnIirF8a5Vc+NYC2MRvB2x/LDoxHDGSdc7t3L2dzMmD2Df6zdXcvTFwV/+MMp//77EY+fjjk4VDAwMI2WGirXVZEqryXtQ6FtKdiMJQlD1M4Ok2AgDB2FbTTT0PJlwyr3NlKEblN6KTjkljRpdQhBSfU7Dd55YXKBInf8be8qv//RIfxCLeOx4eZ6/22EIe0cOOHxbz9Y/vU75fFrODhxfBoj3nW42t2Po7ZLzENJjwOBwhGl18ToVNw64yUULe99rLjF6UU7ybwO6KGMDr4UwKiwAmwirIegIg80mgHu4Mht3PbdMztPDPtsa9IIw/Ql1PHysjSFyGyVymTa+anVSG5LbTYAtW676PYrxerYTYiFMjrJWd00zMxKuW20Oa3e7ERSbAGH+5aXzwoefTvm+z+MePakYH/PmQUrm32dd4nQG2EcFyld3KAyfBlTfZ4lvcTdGdVvDcJE6ZVfjFDecaKMx8rrNwXyrVuEPT62nJwM2NjImJt1az9GXB0KTR1a687I7O5anj0b84fvRvzx2xE/Phmzu2cp1HmGzYzPU6CBh+U+YwfsQ2Gtck/II6yfye/rc8m9eXW9S6uKqQk0HTEKEzzIc7BWOBnD823FqqWwhtOR5WTskMjcsNlWXSN7LX2mqVsr2z10wuPfHym//UF59ELZPXLmyLxyMFpnHy+id1MC/U0d97yx3g0Omtzu/fmqMIsDFmu43bl1lYbrGzlOgNwFtiRAIOdlsjt0d4fsSi8e4t2hpxkw7WHWLzFSinlXbsY46V9YZ37afmUpxmOOjyw7bywbNzOWVoTZecPsvDAcugmwKGB0rBwduTMkO28KXj4rePaj+zzYtxSFYHI3yU5b7/F0kijMNDNDV2B/N1tvChM6a5CLMa4OT06Vl68KRmM4PLK8fmO5cSNjddWwMG+Ym3ObFDIjjAvl5MQtwh8curBPn4754fGYFy/G7B64S4aMEUxWrnv0cnVG8iv63cwJndQaHxO1bSbzl0yju8NMVVyBrDQrjQo4OlWeb8PYWvaPhde7yq0NYW1JWJgV5mfdbi0jpQJxCofHsHukvNyBxy+V754rj18pe4dujaVyiukUKn+gTOAwpfFGZUwdue1Jb8qs03lNkXaPUqGtX3G6boda+b1S+uP0BHex1LpaWcFzaxIKkCEOedwRt4V3mOIvBZFSzEfMhvCs9akT4FTie5SeDyfTk0L0TBKVXH9MMF3Rbgg/zUplyvJyW+pI2X5dcHRk2X5dsLqZsbwuLK1kLK64CVAyF+54X9nbs7zdtrx9Zdl541BHfdgta7SylKanpNul0sLq333mvY5ypgSHL4xT1NWmqXfNYVP3y5THh4sSzb16XXB4ZHn1umB9LWN9w7C6mrG8ZJidNeQZjEZOeGzvFGy/tbx5U/D6jWVnt+Dk1HHpfJRVtw+mOnGg3CRm5b53dZjg3TQ31jVxe9SU6JzFZAGelAbhmkdfWTrS08SzsE5S486I01gLhZOx8mIb9o+UlzvC1qo7aLi6JKwuCguzrs+fjNwOrrf7yqtd5eVbeLWjvD2A45FLOi/9p7WuNegoV7K8kdmorx2C53XchHDtMEclx0VkEotHYFc67XzCeatqj84R3bU+uaAqa1ZlQ915kGNA86Cgc4KUDrQme+C9bOXqvOldFT5SJMYNFKswHsH+juX4CPZ2LfMvDfOLlrkF565DDBRj5eRYOTxQ9veUgz3LybFSjBUx1W6h6cza3UwF30O1P/xeka/evifN2oi4wSPuQNhorOzsKodHlrc7lhevhaXFjPl5V4eZcWGOTpT9fcvunkMhR0fOFGaMc3BpLtm1zDWdj4xxzTuyblH9ZN8hku09ePZGWZw3LM4rs0PnZfd0LBwew/6xsnOg7B66w4KFdWkNyvXHd+lD7UPSpQ+7KeqpzHOosKKim6qs4vxijfMAjC0LsokzYy1EkshX0DvMJ30afqhlhkaNXg214iVxPLc3vVBDiM4kxBgzXJTv1uYbSZ7a/uhrCCYrfysUYzjcU46PCnZeW0ze2O+tKmrdZFmM3TqIVXWmlmrBPKj7FLKrZYKnYYV4o+Knb32jq83aGq9G5U3Wkf8ybKugzksY1ypHlgki7g748Rj2DyyHx/DmjcUY9x5xvscKdduAx2P3W8v1jsZVia9x9qGKoPxJsBJq2ZORSCqdLo23b0to/y6xC6ColBbatUNrqsOM4YumXNX2XhHXbqdjGB/CwTFkby1ZJvV1zRY3JsbWmb+K0mFpZiAzjdnKZdHXDucob6qckfafQB5B3udBIPE4mTze2u+qcnaNOz/d9rxXhs0QXRG4hbABPAFsntl6C8+somsIayq6rBLeQnNNFyFTTf4qWOsmtdEpnKqzx9u6zUu/VpnbPWIytyPJ3/3Tp4VMo6HUC5FW63vcfe+lrcuyhMbPlnfQrm9OuxwtKTaMVBsOjDZ+lU5P4VhtfRGVrYaKaQ4GZqVwMUZqR4nvCUBd05SUZWU7AVbdDryTMdhTKNC6f1b3tVSKgCkRvpFqfLUVqGu6NMqAFWOcABFhBuEkz20ObvPfkmI3isyuW3TRd3sQHRKk/elTyrIWH9oJUUBKQy3fVRIzAh4997L38ZfUTkLdPAybSCf67Nc8xPvuRoC7ENRquWuzRnclGhF1NvryUF1lalKPryYfDX6ntK+mjPUuJcX5nSo/tUyp3trsC49ykFLe7GbQdn9IINIQvbRqeYq+VKcjYa+ozr64Lb9hIlIKPidApBZ8XesGba2z/aVPe6/5CyOntMRI0+1BNFXcXo03LEvieYe2nUYFHe9S9v8+xNEVL7kFtkmvHNKVzuIUlYot9bZRV32x3J5bnzKvshOI67rFSOtjqjJ1rhPFz1K3Fnb18di1jDffTYEYovmvZ77qSifV9zvm0UyENWO4Yww3JGNWhIPcWIM4AbJohRWruogwUCG1Gn9N5yR/nhPjWsOnaoC0LuuC9uHAKfOpSRqBYS3YwiEdLRMWgXwg3lZJaXUipY1SihI52ULrclSDuR7Ewpm3unaVxJ98W8iozDtDyLJgf1lZgVqyEx+8u6arSH67mEp4ZH7fd+0oXv+UIN51275TMsCyCJvGsJrlDEXIcnUyLwcWrOiyRedVNINGY+zWLGOaxvlhlI6vnYTnAyJ3DN05TYcYzqIhXE564f3pVefvMMN38tC1w8OfQH3njtVva916gB27dEzmtrzOzAnz88JcuQCdD5oDdUq5pXjktsQeHyvHR5bDI3eiezxyqEUEslzdzrAOzS8885Gso1TZIy2xKZMPCFrBepDCJO3d/9GJPFp1my6vpBlKxkkx0ocConqaYg2kjtuHojreJbX38N1ZkFIrz652kOZ/WF29q+MdyKNvF1VH+1R5p/pn/3zQRtitd9J+Mo379fp539zWcuGUTrcznRSfiXclzSuslQcLZ4A8LzIrQI4yr6KLKjpD2z506XTVNYX3wZ8GGTWdrA01z5xm9b1EHVquFSAwmBVmhsLcgmFxybC4LCwtS3nvuGE4I2S5W4xU3CL+8bFydKwcHlgO9pWdHcv+nmX/wHLsXZjl7hPHLfTLhHE+FfUnUCO6joq6VDf91/RBqIU6Az3tp9S+V30+rEhhYJV5LAtSMCvCTF6YwlAiEIUlFZ1TLc3yoQYYJOgfwIpOvXrSdpKG3whtL6zEIrerokOp6oeL8UHMQ9+7+Fk4wcdamYaPo1GQSK9Dw0hjtupXO70K0juTkzIu3I4uyWB+QVhZzVjfzNjYzFhdMyytGOYXhNlZGA4N+aBZqFZcGqOR84x7cuK2F+/uWXbeWl6/Knj1umD7dcHevuXkVBkrZOpOGUtpIovQR6cm5ddrO1AoVFuCY0If7auviKmk9t5unzCIBO9c20uCkXTeiWs8PH57qBOyepCso/M3efp7MAPNOaWGRsgoYsprui7up0cQAbPtnz0Is/kdoDOgOvkTC6QQRtIgEO2be4K+2VFH/jwTN51vvYh5bv2ecl7pyqHZzdqkkZhqk8mWa6ezWBZGVudFmMsLY2sBAqygzMHl7cC6uHS9WAr9E9Xl8Xd56V2QjxJ52NK8NDMnLCwZNrYMt+4MuHU34+ZNJ0DmFgx53uyqEm8xs0pLVetF98I6B5G7e5YXL8Y8e1Lw5MmY58/HbG+7sxZW3RbkvBqkZ5jgz1jUNHWaRc5LabON7wrHajt0LVDOkve71KgnyM0zv7tIpudO9zIraLJQ7Nsu+25p+hESbX0/Z3t2CY6USUvRYWGZR3URWMzHTvbmgiwILAtTCBDfPtdZ3j7df3rJ2STnl2pSJXsqQ9co9ibJSKmJkj9Do9JTqrDB+5JOwaieZJVqa6tbn5AM5heFGzdzbt3JuHU3Z+uGQyCra+7k+3TUDjc3KywuGRYWhJUVw8amYfNJxuPHY548HfN2x7bugc9yaRTyZFn7McPUQQN+Kw241fzTxA+7Zu3UrelTthLSaLl7rWp3J4D97c7xBVhBZfR2mIaVbtbDTtudYJhG5TyypR1PxOzTUkc607RHYnh08TVF9Z2Jv/Ond3EeLk/5TKV0aaWaQXVeYRFYyAtVI0huYDETWVFhXmvfoW120qLAG2CJsJro/p1wLzCK+WGSeXe9S3TAvnvTI7jYl2cYJ4SExOVq3zgW5N2RV7rO25Ojn55zLucQgMlgYclw627GZ18OePhpzo1bOQuLhuFQyC94cU+ew9paxsKC4caNjBs3LGtrhpk54YcfRrx+Y90Nf4UTZLXPLulrD2nVx8S66DBXpMdJGpWkdIyuvq7lLKtI7cyv3vYcxlHQct2ppRyGpiWfIb9uqjjJxek0IkqVO3pXVq54Zi6t8w3SnWarbj32JX6XKiNxvXpspef0suL6vN1OnHj9sBo8iLT4xPJviEq8wd45NyYRTMccWUryqeY4T+Pt3mQyRTop1yhBOzTPWykOcVd+LAGLuS2dx4qwqA6BzJPsjv10edLz/NQn6ICkKtev3V1xEuo7xKtT11kuLC8b7jzI+fSLAZ9+MeDWHcPS0uX67jCG8obAjLlZw3AIM7PCcAjmT2NevS44OVZ0pM1J4g9S2d0TV0VJweQNIueGXym0HL/GHWgzxjm1rDYNaHkAzqoz941Hbr9YddI6r7ZLl+k7578pIdHD35TlnYbOAOjOw8j5KTIJXHrC754uC8hdPcpUmANZABZywIAOgCV1/q9qf+9J6QfNLWg0cjPUSrruK3fpBpp0r/ZeZR3r6G2U04RRbzEvRDJN9AjQ99zmlyhvxGekNsXadv0hUbyojpMHr7yw5SxUnSi3CmLcese9hzlf/2LIJ58P2Lzh/ES9SxrOCDdv5swvCMOZ0sOtgRcvC05OnJ4+MG0tu0FuIapqAoSO35rFar/+quAp05WASoMSRKP4Lk6DXppL66qzJ9XZGRcry52QnB26rc/DoZCX5bXW+eE6HcHxiXJ04txtWCv1wU1Uy/spKq3aQwOeFuzXTbvsbZ61LlPzX32zmxdWQqSg4qVb1XEQJ9H3a/4i4ReXRcJ+7A+c4HKU2C92fFFv7f7EC9e0b/tdfLhPPEt4O2+8egg18mjmkfh7N/JKHTdIz5FtFyRBvZ3BmWIKEUZoIjHn9qGo6rdCpiozqCwAi7lxd37MICzg7FpnvgPkSpOn9dZmiHCur/r9e1RQINFg54jv/EI5r7WLy4Y793I++2rI518OuHErZ3CGi3kuQsMZYWMmpxLEbjKFl68KxiPHX/ae6/dcVAo5a2FcHpwEmBm4MzOLC4blJWF5wTA/5+5ozzOpEcVorBweKweHyu6+sneo7B24Z+MxUDhEVnmLTW7YCqj/fajqXgyBVGOjunu9EqitVKdCkhdo7CTqSad3rjH0HpBw7RpI2y3zIeaZqehsdTJUmAdZyMVdFjInsIAwp6WXCmg6U6w1+pKy/aUTeYiPFKoobS0qnVf6eaMzefz4GlFobywFh9qQv6pRUxI+7snddkZfV9K2th0gj8rdfCudCHnEGpJfFicIS0eBwMyc4fbdnC9/NuCzrwZs3szem/DwaW3N8NlnA8aF08JPT5W3OwXWKhRtT6mqffUZb/+WRF2EaC/SskWj+KFmGuq9bo1DKQr3aH5W2FrPuH3TcHMzY3PNsLJsWJhzpjsjlQBxcY5Olf0DJ0BebRc8eWF58sKyveu8BGvh+MppBE/JfLsGEhNN19pEv8NFrz68BxI88yc8fzuplO1UeSqQUKKktssGeaYPULbbIxptNRxscEEz/CXRP9J5phBruC5ZbX9ue35oh+l3FdL+qbjdi4XXtpUAkXq+qrKOZqMIcbXSllbQCKH7aUXII0Jg3pyTQE/hc3UFmUFZAl3KRZjHCY953OnCdy2cO+nS8vUmqHrHTOmSw+8vaBO28q0kvluOd0wXKW9la1dVBgNYXTPcK9c9bt7KmDnDda+XScYIGxsZn5zCXulK/XSkHBxYRmMYiFsPeF/UGhQTKryaQMdj9znIYWnRcHMr4+GdnAd3Dbe2cjbWhKUFw+yMRLusVOG0PIB5cKS82jZsrhUsLVoePbU8fwNHx8q4XGQ3SnBN7lkpnDbPTvUYqZSslOCiGiONA8P+bcodfJ2hPdrJpNM7NwLpSOBCY7IUGLXg0BLJBRN+5TGo2T4/Oe13NScnAd7kzGYQXQKWcxFZwq2oLyg6REPNO6VJE0vcTsTga4Sh9t/WXPp24DT5qbdWUT0JIpZbLmsfToXW5yLEuDshEG/AlAIGBaNaug0nIa09uV27WAkYbmkwQVn60osQXNCitRbonlirjAvXCZeWDTdvZ9y5l7F1892veUxDG+uGhw8H7O5b9g6c5j06tm4HWGl7d2MshT1IIjhfk24r7eJ1s0ZrmsbhoFR5VQO/cJPpIIf1tYxP7+d89jDn4Z2MzQ3D8qJhYU46B72IM3fNDITFBVicF1aXDBtrlo3Vgt9/L/z4vGBn36EVK5CLE0TVrq4m8YRmX5cypb2X2nqkoXozV/VKm3osbPMnUnq3NX5fa7wfi3V30lD5c2tp5XG9xMjDK1O4JhWE6Y8v8UiJkFAMbeIxGU9cDUoJy1J9Ntq8eOUp1F1ZXZ0LMqUnaMEhAMW5obfWPctEycS5APL7bxsBdqGLRBmisIlD3NoOk3Z5H6KVVh0I6GzpzuQgF2QJWFbVecIbCsO0eyVT+mU/3OtJsOtV6nkI5Sxgm7sC8gFkA2E4KwyGpQPBzAmX8dhdOXt6ooxOnVvwoiiHotHWgOgrfnITXvSoO4VpXTP4g95amJ0TNraulvAAtyZyYyvjwf2cl68K3mwXnJ6WE5GJu1ZMsUrUJZh9isPECkxXDuNCsVYY5LCxmvHpg4xffj3gi09yttYNM8MYcfRRZnACZx7WVpzwmRkKeQZ/elKwu+fubDcXUi/PF7ma8CqTVZ7DbAazM8LMEIYDd6d4ta5zPFKOT5yL9arvQbdr/5Sn2TOXpOWGuS0uUqlPPWVozFZ6/E2u26oe3bkgyDP3NzuAuSHMDFw/qITH0cj9nYzL+0zKuPmU62GXRwnp2CEwE08bBIK7JH0J5yhr4AfsaqyURpTMpuNZX9c6S7fz0/MViQpxoDCYMSyuSH2F7PySYWbW+XyyYzg9gb2dgt1ty/ZrYX/XcnLk0jHVDYDJhk0hhSnLUjaWr0mnypSKW7lfd7uuYG7BcONWxt37ORtbGYPB1RAgAEtLhls33cn3p88NR0eWYuw07+pa3kr7P0t7N5TQnvriJjpwpQMXVhmNIcuUtZWMzz/J+PmXQ776NOfmlmGQn79eMwNLC8KD24Y8yzFGGBfwp3HB3oHbCKEizZ0WU9RGui664sXPrbpNDgrMDN394+vLwsYqrCzC4pwwyAS1cHQKu4fKm1137ezrXTg8ce2Y4wmRs1ZRakKhY0wFQGG6hCdTh2Ws9SgEKb5JqrBwWoDa0pS8AJuLcGMZ1hdgaU6YyV1aRyPYPYbX+8rzXXixC7vlTj1oTIMtzT+qm/OUsnuecfAoeNmRcDVfCcwiLAMHOUppwpI53K1Tndn1HvLS9u80VwHU6krMT7eO4qVc2R280NXbyp6LODceqxuGG3cNNx/kbNw0LK0KwznDoBQgx8fKzpuM1y8Knv9Y8PyJ5c1Ld4bB+tphCVcbvjp6siZqL0bJ5WdCfwp6a2sBS8sbC8ugg6GwtGzYvJGxdSNjcfFq3QGW57C8nLG16f729ty95ONCyQXE+OigpCkOz4ln4on6WxQ/HnIS1KkzYbrbDufnhLu3Mn72xYCvPs25sZkxuODBy4oW5oQHtzNU4ejYcngCY1twfOqUHjJp3SGdVMLCuqhNWalRn54JagVE3HbkzVXh4S3D/RvC7U1hfQVWFoRh5raJHxy562Ofv1G+ew7fPVWebcP+cWMGdhvRtKcdJfqID4/G/aF5EpqjqvHRM432VElkMegzc4VhyjyregSHNNaX4NMt4ZNNeLABW0uwNi/MDFwah6fw9hCe78CfXsMfnsOjt/D2yCFRtbiL0MTLNaV9Bia2kD9thw7SSYyPRLxU+SslTGEIsggs5agsAos4L7xXawZKULKQpRZb2bBRmJkXtm5n3P0s5+7DnI1bhuV1w9yiuxO7IlvA0qplec2wvJaxsDxmMIRXzyyHB5aicGYsk6ft3pECo4l3PR05jB/ZkAMZUyEQY5z5anlFWF3LWFo2ZzKvvC+anRXW1zO2tjJevirYO3CL6kapJ8tWEb0fElVKPKg66y8F4VLxyuuDteR1azPj4b2MT+7n3NzMGF7ypvaZIdy5adjdz9k9hONT5flry8mocXvSOdZ9Ct6lzUiBwJTSRX/hns3Pws114bO7hq8eGO5uGjZXYGkB5oZNguNCODxWNlaUtWVYWVAWnli+fw5v991anDuNXLIlTTuGelayfYN3rSYLJreobjwNOorfMzH2jrO+vEs9uLDu6l3FCY9bK/D5TfjmDnyy6RDI2jwszDTpWYWDE7ixBJtL7v3Sc/jDC3ixBydlP8zPg+YSNBVYOx8N1CGQw1xLnyYKQ8TXq6czD4RIodlSW71PaNnhr0SQRuqF6QUBq+eV23J1J6I3bmY8/Crns28G3LibMTMnDIaxEDAZLK0aZueFlQ3n4nwwFIwZ8+yxcnigqFWywK/Rme511+DTSyVGI5oO6yR/s66TCwsLwuqqYak0y11FyjNhZcmwuZGxsmx48UqwaimskGncy/pMFBrNEFp3vJT35vJF4rHUaRRWGRXKcCCsrRge3s14cDdnc81t0X0XtDAn3Ltt2D3M2N13232PT8v1kGqzh/h1EUu+SGFJjSG/S5UTbbVYPjcDtzYMP3to+OZTw2e3DcsLbv0jCxSRPIPlBWF2KKwuKWtLsDhvQJTxY9g5bN9N3sk7YfsG7zq+t3+HM7//NT0G2mMzPQf1jl+/kkvUMbYwsspM7oTFN/eEX92Dr28JW4tuDSQPdhsagaVZmB0Ia/OwsQgr8+75qVVe7Zfbx7W8hFTqLPvn3r7nHUAwDAuxEO05SJmVcmM5R3Qed/r8oztA6FdUvXtmCCsbhjsPc+5/kXPrYcbCBNOOiFv0Hc64A15qnQvzw8OCw0M4PVbMmPrgV9WoPhe9nT9oiEgI+t86/OUgjq+TE/dkYUGYnXcmrLm5sy3uvk8yBhbm3bmJ+XmDiKvb8bjxGNwyH/SaHdq/feqE6qkzRlCva52eKqdjGOTC6rLh7q2c2zcy5ufeXYUKsLpkuHdTefzc8P0Tw5tdZ8oalf0sMx11UZWlY2JITo8itampWn9anBfu3xR+/onhi7uGrdXunWUVDQducX124IT53pFl7xAOT5WDYydE8qy9TbtrLHgsR0poFyJNlrvvXee48971hSm7gGoTvtqqW53vWBvC/XX4xR34+W24swaDCV1nkMFgzglxI7B7LLw9Vk7GsHfsEHGWlUjkapIAs8Bsrk54zKmoEyCeajNx4vMm0nBrLWFY4o6SlKodFyqlJtQqX6U85wHMLhhu3su4/0XOzfv5ROER0vyS4dYD4ehI2dku2H1rOT0ud2aps9s754AdfPqTYfClV9sJ7n5PCxB1tnIgG8DikmG5RE9Jx3tXgIzA3JywVHrwHQ7dBFkNxBCtR14C/HfRFxITZ3c9tK++rXxWCYgyOyNsrGbc3spYXzWXbroKaXYIG6uGrTVhdVl4tSPsHbrJI/Dw0S5DOOtWZNKPKwvPuHATvBFYnINbG8Jndwyf3hY2ViYLjzbvwu0N+PxA2DnACZETtwkBKqUghfzabRAJkMrk1grfDh3PGRKH9eYGaOaU8kfrWeq20CasN8bLf2PbmAAXZ+H2KnxxU/jipnB7ZbLw8GlghJvL8OUNeHssHJ7CyVg5OHX5VXLYIYmG0aa+mnnY5709v7bD1PWYmmc75vuUixVUB8AgR3SI87D4Ho93XQ5V0M5W8Dl3Xmg3bmfcuJexuHK+SXVxWdi8lXHzbsbOtkW11PzFXQfbNmUFPEmqk7fDhgMmjN8O4wnrcg++GGF51Tjz1fK7M7VcColbTJ+fM6ysGNZWMw6PnN08HzjB112fMYpwYUwUZDoE4k02pQAZj119bq4ZtjYM6yuGufdkDpwbwvqK4eamYfdAyXKHzEzmthInr2LtZC0xwUolQITTcvvtcAC3N4RPbhnu3XC7r0KT1TQ0PwN3N4W3+/BmDw5Olb1Dh0AGuTfP9FXlNOiiK0yfEtExobbSCd/1KbXe+9OCErHCzWX49Ea55rEEw3NstpgbwJ1V+OxQeLajPN+D/dNygZ6o+FeJBDC5qgyAQXkPesvtfiTRgvUN6HNAGFOnTS3xfSICKX/Yyl+RwGBGWFgWVtYNy2vmQltal1eF2/dzTk9gfkk4OtBSSDWHvlJ8ts1bbabjDp7YRRT9aurclqY1EWF1PePm7ZyVFXcV7RUFIECzXnNjK+Phg5y5ObeN1WSlAOnivXNwJybW+lXwriVAmpmyUjoK6wTcjQ3DvVsZq8tyabuuJtFgIGysGT67l2FEeLljGZWL6ecVIGHYSoCMxs3ax+1N4Yt7hhtr0losPwsNB7C5LDy86RBIZgw7B848lnum3l4+I4TZ/a4iGzhMdPHSWaTuJw/08s7Dgu14zaR4WjghMpPDnVXhq9twb11ai+VnoczA5gLcXRFuLMH8jGIOFUt1TXQ1tqVGIp1zY1huj/XONdukcNUgvbhdyltrJVe3lTunRCCxJne1qdp9JcatY8zOCzMLcmE/UMMZh0JMJqzdMBwf2vJsyAQE0sdr9SVl5uqM48NvGI8VRFhYMGxsud1XFzmj8L5obla4dSNHFW7fss4Wb6j9K/VS9L4nQviqVX3NS0vTd/IcVhYNt2++P/QBrvxrS8Kndw1L88LOgXGISMoF2CSanZ4/f3Ko1ghnh7C+KtxcE5YX3KR03hLPzsDNNWFUuLMjh8cuMf8sQz9J66Oln/YgAj9OH/Wul3Skl0TA3u+xdQvow9yd97i1KmwsXsxR6OwAVudhed6h0qz07FxZWHqF5SXSmdIuXXvluMXzgYZbeL3OG+6MabtzT2feN1kGZsd6kpREmCiur5Vq42Yhy9y6wHDG7aLKLnpp0kBYWTPMzgnrN4y720GbweG7MAj57OpL52v8Nhap2iLPhdnSG2z2EQiQmRm3RXZh3nA6Kt3PQ21mOQulTH+NshjWctOrQhNW+RCTwXAoLMwKM+fUyM9DRtxidp4bNlbclt5qY0HVz7rQ7FTkIZhqEX2QORQyP+sWxC+CXI3AygJkmbC10hxMrGp8ctpnz7yeO/x5patOzlG4SdVbejwiE2fGW5hxAuCim1jmhzA/VIa581zte/PF6wsphNSsm7aRg/SF7TPZhQ5dW3N4nYczYZVrIAPOuwbSdaBuCjqL9p6MHwywCjbLeRILqNqZNRgKC4tue139Lh3jXPnEbE7HuJTQ9qruvgopM8LCvDA3W3bCS1OlphHXE9pGGueA79MUKOJMQYNcWJwDq9Kcyr9kPnyH1fWJ50ugPHNbUZfmpJ70rr46Eyux4fNJJFxuPbb6nze5N0KjZ6bo4CFpFD8Xv8laMYDJQTMgYwqfoO8SPk2bfnnHW/NA3AniaotiMXaHA6dzeTBFfqXmpvUFCV1TU3eGfazIFGH8sD4euao7ryZRVaeQMDMnI/SmlkwgNbgaxUJb750OdA4odImklA49odXDIxNGUBddx19SGShu1GuY6CWQfyq7mgMnifB3PZ9MQ2dWWst/UvWbS6rHUQGjwpnIikq/utrD25mwtFkDMdXj0IwUw53UtzRpx3f3uy1bk3Aq4KGOV9awEffOKoxOleMjy/GhZXSi5BdYRB+P3SHCowPnaLEYawPL30HDTtuRi9KTZz6AhQXD/LwwM2veq4v085Bz6a7s7VtOThsTltBdp2cb3KEA8SVUnLg/ERvjTl4vLhiWFuS91aUqnJw6t+/7x86tTqH0bywIqVcCN4WsbOqZcb6vFudgYVaYHZ4fdVkLhyewc6jsH7mtwjWa6+QzwV3SLtUdL5nGtG/PYFZLOUitTIFG3HrS4ow7HDg3PEObBXQ6hrdHzk/W0Ugoys4p0uaiq6zhBqaUmasJG4RJLjG0tbswvRIVlSasZgH9gxhDLqqFVLhJx26r7cGesrejHO4rM/PnN/EcHihPfhjz4knBwb47f1EJkL5F9BSlhGBXmElIZjRy3xcWhZs3M27dylnbEObmrq66oupu6Pvx6ZgfnxTs7BbOz1jyPoQEpuubjer9/JIMolH48rltFtLzDNaXDQ/uZgzyjIX35NHYWtjZhx9fWJ6+VrZ3bb2teDBhET2cc/ucekLjQTcrDxHeWhMe3nLnOc67ALx7CE9eK9+/UF7uwPHICags82s8ZZCveJ5M4Tbbs6QRjbs+xFA/75+wC3V+y4xx50BurQifbbrDhDPnXHc9OIUX+8qrfXcGpFIS6/0loVJ/dYa65Irbxou3BhJXYNKa1vGsHNCJg0ShRFfVpkICLB5Jw7LWnENDrd+J4G51F2U0gv09y+uXBa9eGIZzwuKKOXN9Hx8rr54X/Ol3I77/45i9HevMCqV7d99japfU9l9W1q8+RsJ0ktvrrFtoBVhZMewf5JisWkzPruxW3tEYdvYKfvhxzP/+9xEvX4+dC+tBs5YDicm+pMjZXrKcAQJpncaLBUh1gVJRTqq3ttyst7rkrqp9H3U5GiuvdpTfP7L84UfLy21begRuC5BWl4q2KSfGTTTpum3TlQPFxTnh4U1BjLA4D6sLZy/s4Qk8fq389gf47SPl2RsnQAa529XW5FzxHafRKAjd+cfbbNvzi59SNC9VVdN341/IaMoC48V2rmAUjFv4frDhfIUtzjh/WGel0zE821O+fwNP99yp/soTeCVAVGgvflf2wbDaorqK38VKWTMHh4iwV/Etp+N6FxYfgSPFJJUVKqUZ6+BAefG0YHHVMDPn3JOcxU/UaKS8eVnw+PsxP3w75sfvxhzsW+dM0Wg94YX7qlNCIjpV7jVauwAJc16CZWvh+MTltL/vzn+srxXcuHG17Vcnp8runuXZi4IfHo958XIM4jYpNLqDeAJEA2hdCY7gs3zb/Ccy6XR5qa1s9qOxUwqOR7C1bnh4T9lY452fRAdn8nmza3n03PKnx5bXu4otXY24cyBxnOZsR/Dc/5HQ2gvvGoCZARyfwuKcZWXRMMzcrqyz8P1qF759qvz2EfzuR3izp4wKd7bF9wHl9+cU3z6fqUOCXQf9egVSEKb3IGHAQ68AkfI+G23u/tg7cYcBNxbdrqzlM9SjVXh9AN++gt+/tDzbhePCu9DL5yukD64sulrJEYbAUN1iOvXygreo2Afp4koOJsTezuBp8Rq+01YY2tNL86SaUzLBlL6iXj235MMxwxmYmTVs3czIpzgXUhTw+qXl+z+O+e4PI148Kzg8cMgmR5GW+9gGBbXL3/yohErYSdO38E0WIFpedqWqHB4qb7ct29sFR4dOa7mKCKSwJa87lrc7lv0Dy/Gpu/Wxuh+9Pfn1GPNSGmXQb7o1LZ+03jE0Gjsnhrv7yuu3yutty9aaYW353fsXOziCNzvKy7fK233ldOTYtQKM07xrh5+TZB0G23iB2hXHs23l94+V+TnnWv/+TWF+ps/GU6WjTng8g989hu+eK2/23Ul3pDxvkoiXFhztRku5QQrRp43Cev2lQwOvlQhJvGuYqT/ig3RNfboNIMJY4WSkPN9V/v05rMy5A5Sfbwmr86nCxvT6AP7wCv71mfL7l/By37lKyTIwppn/NFE2n8/mwy+nxnNlq7zBN+0R1lW3CFFLgEDaBwmvKHXxZ0rnc0UB+7uW549hOHTnJcanyupmxnDG/a4nLnUaxXikjEfw9k3Bo+/HfPu7EU8ejTk8UEzm7hVxLkQgNF3VfPmVPgECtuNKMmxSWKvTTitTxOGRZaeclEcj/WD3oPdRUcDunuXNtuNTcWcu8oE7c9F08u5B3rxLTDSdAiSFVtqkuPo8HTk+t3ctT15aNtcsiwsZM+9QgByfwMu3zmy1d+DadDgQ8px4ET1VJ0G5Un0qhdhGpQA5HsGPr5TBwNXU2MKtdXeQbZCXk1g5RorS5f1o7NyWfPscfvuD8qfnyva+CzM7I+XaR4UeO8ZJgs36XXKSTMdPKlidAiTOrxOBVM8SSMSnsTrz06iAJzvK/3zi+tzYwoN1tz4yLG8nrNrSWlf/p2N4ewx/eqX8jyfw7y+UZ3vK0bhcQzJN/h9kPk4gwZhKBKLowH06E1bK/Xqy0cqZMkYeJD7bqKT+iCZdbSL2DJAWKiklpzjv0qV/I2V3x/Ljdw497L613LiTs7JmWFguD98N3JbfkxMncHa2LS+fjXn8aMyzH8fsvLWMR26CoTp9Lk2eIV/VYr6vHNu64wYFbrVQoC1Ku458ElEnyMoyHhwq228t228t+/uWwSC7cudCTkeOx+cvC3b23EG5LBfyTDCmESCt20vL0RP2u8a/UhOyOYTaFi6N4urUJ20i1NufldLraTlJvtq2fPe4YGPFuCtsz+lLbRIVFp6/tnz7xPL4pWXv0NVLnjv39zVJWSqvU1naBazKbVsdRlrvGkeLUt414XbBvT1Qvn2qnI6U3SPh/pawuaKsLoq7kTB3k97RqXNX8mZPefxK+fY5fP9CefHWTYYmUzdR+gpW7XKkkfBhl5ZgzgjYd2bpWiPoGCeJeLFW4f2s72F3FJmeI23bI9XafJ0raC5YlN0j+OMr5XgMeyfKZ7twa1lYXxBWZktzqFY3EiqvD+HHt8ofXsIfXimPd5TDUZm1lMptKEB87b8DZUf1SzyGoquGKySj3e1ArRT46bgv1Q6sZhfWhcdMwMa0dhW/tD3p9e42keYaWlsoO9vKycmYvZ2CN68tG1sZK+vC/IIhHzpHekcHyts3llcvCl49H7P92nJwYLGFEwrVRVJ9mlOyLMRFT7qr7kizpQR470zmEtKxcnKi7OxYXr4seP3aMj9vrtRuLFXYP1Bevil4UV4mpVQosPHxE06SFUn0ped5UJHSZQrzJgfBLVhXtu3dA+XH5wUbq4Ybm4a5mYy5M9i0pyFVeLOrfPvE8odHlmevlZOROi/P4f3iiabs6otTtbo4bXhgGlTxdt+5s987hmdv4PY6bK3B6qJz12EV9o9ge8+ZvR6/gifbyu6h076zUnDUikvQYbvasPddrWe1z8O4R5qO41E4pvrGW1vR8PNORPLeicBAnAAaFbBzBCeFsn8CT3fh3qpbVN9YcKgOhf0TeH2oPN2FH7aVR2+V1wfuIikjDrGYun07Ctjb0OFceQZKpdubVyVAtBQiU5xK65DrrXfT5d5OKdadvC9dM2wiPbdTqoHe45FDF6NTODhUXr8sWFh0i+omdwcOT07gYM+yt2PdGYXyKtssc5O1tAbGBDbwxk9f651njvcqRnCaUFEo+/uW58/HPH2asbJimJu7Ogvqh0eWV68Lnr8oeL1tOTpyODcr0QfQXRfiv+wZ3O0ICaHdXdmKE2JZBqhbg3izY/n2x4LlJbcYfP+2YeES/WNt7ynfPbH8+/cFf3piebPnJuk8x0O5CZKOcRLWTb1Nh6i+KuW6qnurTojsHTrz1O6h8mIHVl7AwpxDFaoOgewfwdt9eHvgrrIdW+pL1kzqAESgFTesSGJIB+ii/TRZliknoXbYhOWgU3j1pVNSJTRNaZraL+833y235a69VmfKKhHI8cgtur85coJk56gUwsaZyjMzQUHuKSKkFdSG93KO7JG/nVNcai4un9XbeBuTU8yiBl+aPprwTR/EaRnBJPXOZ9S/VVl7wmrDRyJMPSmI221zOlLG25a9XetuTKtOOqlb5C2sEyaFBRGpB3O1TuLn3iz8BxyFlievFbripOqvH5Y2iRpT7cpSXr4sePRozPp6xvLy1UAhJyfKy9cFj54UPHtZsHegjAtlkInT+mm3cDRwWhqgpMP47+rB026rpMt871Mo29kIYpXjU3j6snDrM6Wr+fu3DHMXXF9Shbd7yrePLb/9U8EfH1tevVVORs5slWc0Jp0O5SnVF9p9yhMerfDBM5XaYaMxTmE6LWB7H3aPIH+jtZsOpdzuXJ6UrtbfBrkTHPW6YD03VIaXnjYL+AtHRf1ciZBB59xBPB+009OWEO6diOvPIO+qfao5oSxmViqaBW5tZPvImbIevy1vaCwFTXWT4di6cEq53iSxS5R4HvAEQEIxSP7249Vh4n4TxQ8Eux83rBt/ET2is0CgyQq69r4NI0/OO06veqJQ3+omVecfK/YE1DY7cKo8xbg7EaR01S5mMoiYSBdOwFFXrVWmuvFYefOm4Mcfx6xvGFbXDDdvZAzfo1PAFO0dWB49Kfj2hxEvXllOT6kv4+q0z9GusqlKMFldmopMiYwKdfda/PCswE2FyuFxxq0Nw+qSYfYcbrv3j5TtXeXRc8u/fWf5/SPLszfKyWmj7FQO9M5OHShtCjJS9nXjxsjYwsm4OW1d5yDUB2iz0l27qe9c7eMppjMV8RxduBJfkECjU8aflmw5Oqstt6JOMIwttft8S3uuqbboVgcuM2n4TArFxOdljuyLTlG5lhdKpSRztNOhuqHLW/GMkUdbwrXTaGub2uql7fwjD8BJZBRqr1p2oEZjE3HwsLJbarmyXV/WUj6vBlLafYCvwQVSuXqeVI49rcF/7nszju5RiTVybf8rBaSQifOfdHjkUMh3349ZXnJuTW5sZeQfyEvv/oHlyfMx334/5vsfx7zdtfU97lJu1dAaBqcmwHZniOu2wepd/c9/Egmp6E4Jx0ueA+VW6d195bsnhdsxs6t8fj/jwW24sSYsTHmFsFVldx+evHLnPP742C2cv9xWjk5df8tLl/ZOqQlRWKwtxgvPYdm88gb3wTdW6laKtXDIxaEKx4t65g6px0jtgr9OqUR9tVbcRn21zlpqrwm91zMztueMac56+M/ihWetA9TPA+0dL64LmtLM03Oa+nlU9ShuW7SVRimoF+pLQVOhu8qFT+s4Q5RHgEoTddCJGBLpJG8+jQRtgLz8uSiYr3Lv7ydFodQXIy13w9NK+6tKYtyuh8JCMYKDQ8uTJ2Pm59wW2eFAWFvL3ruPrIMj57LkD38a8/2jMa/fWE5H6nZdZT1K6xUgETehg6vXvUPl0bOCo2Pl8NgJlVubhrUlw/ycOzQ3qNbKcINyXMC4cOsph8fupPmPLyx/eqz8+LIxW1WXRrnLyT4M+fkaE5wkTgC5/u3oPy06j/UFSoQhuMqsJuBQEQqV5fMyeQa+OukM4zGVXrV9t+k70p1x8sarKJO0ht62TlePAg0rkWxUyRJ98d6mnnVQ6jAabQ2mralqMkwqkQosRJpCKu8oTHvkim93TBTTGHdGZVzA69cFIuo029yF39h4f1t7D48sPz4u+N+/G/Hb34948qzg+KTis5osJbDjthFXqwXDtg61byWSSP6hr4iisA2SqT5UGnQxtnBwDOPXlqMT5cUbw8aqYX3ZsLIEC/OG+VlhOKDc1OBO3R+elFus99UdFNxRXu84U9bpyHkz+P+395/dbSTLui76RAGgJ0XKt7qldtMuc/Y6e5wz7hj3w/1b98/tM/Zdfk2zpu3ZvtXyhqL3BFAV90OWSVsA6ESpGd0UgKo0kTbijcyM7HQi7lIClsOypLXPWHn91NwOJJH0xPtmC416AdzXeAP+YujCz8BO2LNMVNw6/cROv4nTTB2CPzz8OUOs8oSIv+LXfx+ZuVrK0GRmo0Y3ejOnRVB3EN9FA046vvUiwnuqnPZ25pjbqRifzvsyry6p+fA9pWAyjrx7V0gpzSBiNObjY2VtvaDTHdDtiUEnOSwvZ8yc4017wxz29wtevM759ocBX3834NmLnL0DNeivI4y+LODtU9X+1c6iTM0mi/4Q1raU7f2C1xvK4nzB0oKwMKfMzQi9KXO/Z54LxwNl/0jZO1C295W9A+M3alDeNNjrlgfuIoP9MlBS6bmiiWgcC8fb4CGgU04LXYUB5i/I3pKh5ZPQJtuEdj/95+63uE3RDtbcw+6wkMi70pZS6Cci9Vt4T0rtRNrRMDaS8yFsS96+NubwHJt0SltqpcQcHyuvV3Pyos/BQcHBQcGD+z3u3O6wsHD2s/gwp95t9f2PAx4+GvDsZc7efkFRQK+Xuecb2jRm3HKHGnRr1PKdr/FGtPc2U4ylrZrFY6On5wUMj40w2TuC9R2Y6uX0ukLWMVwXhZAXxifUYGBMVYPyKtlqR1eWlcgjdYjO5iuKoiqe0+Vs4scjx53jtaMz88xjItoO7ru0dqxBWVq9MNSfcTSgNr7y2zdaBnfuaZvcU+jERWNjzEH+HBZrS981e6Ie23iO8+fzEo4L9SwjPg/uO/O2C/TLvys6A2rrgGeVXuxdlplreItCOTouePXafB6V5pSDwy63b3VYXOyUHlNP7nG22tV23De+o548H/L9oyEPHw15szbk4MicU+n2zHmbbEQ5LiNV1pNOBllZUcb9u7kDvD9U9MCELKj8DpXOIbNGAHU65bbwyhyaNelfkU8nq5VxUdNJ6/x9bqvTlq2L6AAYqK3yJ+2Eaa0plFahJG7uEY9Lfye9WmtvbHVuWEuCjqW5+NSUJb1uE8atJpZGgxGHXxt5hOip+hlBY3U53ToehZjEClPtNssLY4vf2CwoigH7BwXrmzl373S4c6vL8kqHa4vlZVQTbPfNC+XwUNndVza3ctY2Cl69yXn+MufFa/P76Mjw0us12xvd9kloqG0ab9thQH9HVUpDjwSKen+1+KhBUwnvMi131KiJYlzCa+2osEKDGeUWcjGCo9rlZPMbpaRrjzYU5SOR+BhxyhtBeal2cNFZfKC1+SZTfxBYPIRatjtbuHzEUbjNUnBbo8eSrZH73oWiW6jrBGJjXZ30/B1vcQTizjNuVxiBPCKzRwrdtc2HUufjzGIun4nP2LzVxZivhn5kh7PWaolTbMI+L038JHJ0nBK1CZTJa2R0uu67tOBI8QKlq4qe8UxcKGxuF+wdGHciL152uHs35+6dLrdvdli+lrGwIMzNZI0fJsFp9qKAQa4cHSmHR8r2TsH6RsGL1SEvX+esvsnZ3Ck4PDKCq9s1p8zrg5iTV8+J6FT5pGC+H6wUEN0SUmmnGkiNQCplTY1Aqu+n6S/j0IVqyW06R4vJJU1p7keVyxVw3ruWvGOOG5NpjxG2bWPM6P51ca03TrlT7zTyrIs5QJljK9ejUo5pHGdGnsZyTqmfmhINUaffkpGrsZ1erDoNV2m7GWhuDhoeD5TDY3NXytZuwZu1nOsrRoAsLgrzcx2mp2GqPKdRu7ooTPyjgUEeewcF2zsFG5vK+mbOxpZx/9IfKIhxkFgdiotAxpo/+7t4FRlq6BcwuCboz9V6UyUcnCgx9HRBc0M9arxRfLF0thmPU3VnXb2xSf1M8mgTZhMkM17YCJI7J+qqlifwhQLojHL9kHwXhaG+KUG9sJF0vXT8ba3NYLUa2IOjbby3dZAUJIynF+dLI20X8mDFrSG0i63b69wHnh64LCeRLCvXOsrT9weH5j7yza2CmZdD5maNGWt+NmN6xpwdqXyAQbnWMTC3IB4eKQeHBs0cHpq7EIZDdQ4IVgvEjqmkRfvS+jSn9dyrP7HSiC3s2ulFX45h/olrsSlTjhXH13XU3+ZqxU8s7rdOCLEwSd6b334RgrqJCboxFtHrd60mRTfdNoUgXCCOmYHU4aPVTJMQ6JOlF0H+ft1E0EbabKS166foHDF2Gaq6CeuvlQd/U07iUGSMn2ideM+qXVg5xrx7eTzxjUFnoRlcKPS/IKrKVLll6ajZHZTnxi/YcV/Z24dut6DXE6ampL5JLssgK31V5Xl1D4QyGJgdSP2BSUcyE77TsballrYav/ML1O5jtLpKVs0p+vq5NRnbrjOa3Us05qAUunlLdEnYMPTW0Mf50qWq43eSzsey01VhgNmFlVM7VfRQRK0l430ZgSa8J+NtmfMlraeRR7WntvSqeOo8aE3Pq2w7n6YKPE3GTjewHfoopQpgaegJ5OGWUb28XNTiPPO0BsmEDKVbOpisLtPq982dKVT3vdtlAtAqfLVoWF56VPoPC1xb2AlYnGjJW/1dFS1hL+rWn1Du3Cp/VPHELVX9LkrjaO9+v8Yqyym0d5sC7XUM03DbFt0UirJbPXW4cKxF9InK4idnjVrfPUkk69gY9H/Hx0E6bjxMbFZz40cdnfrvxkA9/iai+pta78QPixs28i5WhrBOKlQhXqhwZmtHcKn6kqBOu5gF9AqBvJd0pb1gbSktJ89KiHh/NoKokIBBA1L6C2vu8fDJEZ6WkMqLEm3QpNXtQSezTF91NEHVeIgtCnPF5zBXdCgg1Snuxp8QVZ5XjWzoEiCQq6b46VAXZQgMVdQogzGpWGuHriR2JFJKarVoE3HEEE8nAn6SuyxcKe1q7fWcI218eLZYpwwaPLN/tx50jMb10F7iMxrG0SirevPS87VOO28RREFUHc8JTpT6T+qDdbaC49pzPQ1VS19dBWhh1lampoS5GTGXX82YbcS9qVKYiAk7GJg1lqMjc6r74BCO+sa1SAVFBNBOLGsfNUYEXaDgRzR8L+E27b2JG6njRJ5W5mHeqbK0vGuArISarh95DBRVu5ZpKUt8vcBN1wZ0ri7chEuhCzs9n9+4fd4vQxp5NNYEbztuNA+Ph9Y6SeXTXs4gb+9JDME1Idx5JVyzCPtYe95Vo/n1p3V5KpHg78J6L+m9LdgJKOamWygdTZaj3BkgsQk4VqHSvCvU3K9SlJP91JQwOyXMz2csLgjLi8LSYsZ8KUSmpswW4kqAHPeVo2PYPyzY3VO2d5WtPdg7KIxbkIE57Z0V1ZpNq+Xlii6Yzmq8XY3bS09aLaJXZizEMmGk3Sq3jVbX9ml/S3WIENk0gX3JK2rLV19DCzX8mAPCKqTaeWNJXo+vqN2x4s+3edoaYvJkk5VuQsPyF6Bt0xJentGdc54NOrY00vBVapuo5VbT1+Sb+Gqz4KmYFeLIh0rWEeZnhOsrGXdvdrhzK+PGSoflRWF+zizeT/Uo70c3SRXlVavGFYhyeAQ7u8radsHr9YJXawWrG8refmFuc1Nzp0K1HtM0d7neYgOGWGHqzxJq+VqcDVmjFeIk7FWxvUk53g6qinNgxMrb196jeVYH2KzxUZVFg7BVnk1xfYohhNS7mLv5aB+34p8GMbT+tmKOQhBOjKBZ3R2Nblj7dwQd2jx4KNAN7E5KMQtHkj9r8LWf6XA72iQuW8J1sUiY8mcXqX1hnXAN5PLqCeNBxHFjnqSkbbP2WdLZpK/lP60HsBLPqvWOYW6e9aaEa4sZt29kPLjX5f69Dh/d7XBjOWN+Xuh1S3MY2HOnk56q2fF1cKhs7iovVnMev8iZn1Verglbu+aiqjw3cbpyhUTa2u7cKRB4DV3eWcKlt8nn2eV92k4wNifa+MIS8jBy3M4al6oppkMI4LuVbuVwnJCehuW+i6enEb3dz8vXT0dSKpCvxZapOgOthn6+VifxERnhu42FyXpnpZ62RKomC6nu1jaTfVHAzGzGzeWMT+53+OSjDvc/6HLzesb1ZeP+fBI+el2YmRYW5pWFOWFlMePmcsGjlzmPnguv1gr2DpV8aFjKOkRuPRynvBEN2SpnRa57c+9dNG1zDqBuTT/QOOdB6vy0Ce9puI3loKW/BOjHip/MdYzeFXscQcmSCpvI0T6saacbpBNYA3AHrYaPUgzHSzu6dUJ0FsvC71s2KhXbi1RL+nVNRvKKNKaPeiZwAz0iSAEUtjfevMq8njg9dT25Rc35TII6NNJI5nfZ49WPQwRORXzBVL89XzVO/LoMPu8hZB0DurUcgqrKofV23fqsg5WWPQjqBf1Y3VfhIrxEGzgYcHaduM/8wBo8F8KDSH5Yk3aFAmZnhTs3Mz5/0OXXP+vx6f0O11cyprpm++9Jaaon3FwRluaFGysZ15eFuZmcThderBbsHZaL9SJIubhu6tni02szsRrAbh/zqGpPf7C65a5ScoJ4eTpbm+vJrJwJI5ApvHXQ60Pa8FUdUsu0KUvNUjCxxKRqunx13lZZ3OepsR5HQorbb5p5JT7uYqboov7t5l3JTHssxagRvG6esY0toQks0i4J3iOpBRsx3LiJOoikO2qjUVsZYi3WtgHAzs/lvREgOZDLBCasdslkac4nDnHSvCcPOzLMCEU8mqaW21dVKXLzaZ6VCVVXWmaN7V46NHdmqPNxakBqJ2JfpzteupFQVoer7hwpCpiZEe7e6vCrz43w+PjDLrdvZGd2oVUng9kZKXdvGaEyPS30ujmPXhbs7Zv6rp0XxjTYCLnC40xq26KEtjhmn1Iqp42QF1J+UjtwrK5htteBqvWkZNe9JHa+NnNbxXu1KWNYmMOnuVpbzinLnjV3jdfl9xM7Z0qN1QmnjpAusqlG5OUhOAWKLmIW0FUrARK7Ac+T1pFaCe7/tqRtg0CsVqfRImLePEOvvuL8svlpFhI9qWvPDP5Cp63leQUKNBjBRTU2P97NhkqJ7ag0Luqal0zr9GzTRYHRIO081IKawaFF3M/oNtToIro3o0Y0Pfu5G7Zphzrlcs1DFaZnhDs3O/zysy7/49c9Pn/QY25uvLvDT0LLixlTPTFX+HbMBPP0ZcH+kZlwQWrvxGF/Ln/jfoJYCD/eX2zx62+bDNuhjKM09eehvMaMFObtHLy00xNz93aVZ2XqUapR5rZzcM+Dxaf4nma9EriI3+uHMW07QCniPI9p716O9XcjPIy3Y7vpTPlr9kzZxY5TdX93vnHK4OUZ28jTvBPnXfze9LAMYRl95OHOae7uRy++ZbP057l4Xl4Z/A0Pdjlb2jNIr7l5UcHswhpiEMiphWU0w7cc/6JI1ew8qrRDEXMfxvSM0Ouae8qryTQvlOHAnHcYDAsGQ+MuxByqUzqVV9xRNJF2cnaqTNUmuRr00evBjeUOnz3o8uvPe3zyUZelxfNVnbIMFuaE+3c7HA+U3UPoD+DFqnLYV6SAqYyLUbZH5dH2PjYJlyhjaPWlXheme+azV3lOBgo195MMhsrx0Nx82C9RWLfTuJU/KV3o+CuVrcrVjVP+Dsx1YaprrmvuVGNJTXmPh9Afmgu88qJBJl3/MjN9d+aUGPkC60Ipkmc3g2OFYwTjGq8+UyYRbSKkULsLNXMtVXp1H4w4Tu8+CKW+zZ+HkKrPKI6tkJKHYlIam1ZaXYQfacpVqNbwutOBmZmMxSXztzAvzM1n9d0b/X7B/oGyu6vs7OXs7BYcHCh5icuN+UVr0BBqNT4vaW3TXQOxFzIjaz+xtZHoDYkGfRSFOUW+OC98/GGXv/95l88/7rC8dHH3185Ow/07GYdHlePHnJfrMBwohYrrndZ3U1IrY2L1O68uAkd69TerTnztPdIeNbwIESC1tlwiDpW6L0kGc9PCtTm4Ng9Lc8LSHMxMGy38eGjubd85EDb3YGvf3Jg4zJW8MO2deSjFdUXk8R60t9X3fUd8YXEj6RD9tMneMFKhiLxEH50M5qbh+pywMg/Lc7AwAzM9E+NoCNuHsHUAmwfK1iHs9pVBAVoImUDH4ldFfO59ZiyNPIVWLApQQFud+OnEkYTzrkY/Vh3VPoequSyej5tO9dtPL1KuuumtuEH31QLQbi/vHCp6OMx0oGLsWGcp3N5lBNLW6eswpRZeaT1zc8K1pYyV6x1u3uqwvNxhaVGYX8iYmTIT63G/YG+vYGdH2dzOebOes7aWs7Obc3SsDIZKlrl3Z0fJlYkj6OxatSiaRfOZGeHW9YwHH3b4+MMuN5azCzexL84JH3/QYfcA3mwqO/s5O3llyioPGp4nA6PaYUwEUlD2pVJLnp2GpXm4swy3l4WbS7A8bwTJ3LQRCsdD2D2E7X1lbRdeb8HqFmzswkF5ej+TZp1gUrrI8VdouRW8MIJzcQZWFuDOInywDLcW4Po8LM3AbKmMHQ6M4Ng8gLVd4eWu8mJHWN9XDgYwKEovsReFRlvoNHV5KVCT21dzYNidHmZ7hbCnMuznWSWxQq3f/HYTEojYlT2pWEvLdHqhLLS5DfWF6kmgmXu/xcnDy9vTQqkRRUxrangRWxNQszBeCY/5hYy7d7rcv9/l3r0uN292mJ8XZqaFqWmpzQ55rhwfl646DpU3azlPnw14+mzIy9dDdvcK8lxrT7TVimjQieo69ktNMGk1oEUiyC8V2EUe1cuqzL0erFwTPvygw0d3M66vZLUn34ukTke4fg0+uiM8fyNs7Gb0BwX9oZmQeh1x2tYDcG49JNgP10CsdzXIcFFaLFNHm/e1Vy0nTxHmZ+CD6/DJXfj0rvDBikEes1Pmr1deSTws4GhgXL3sHcHqNjxZhYev4OmaQSTDospK6s0F1a4uu+h2ORuEbvPpacwRC8Koe7WDEV7+U5mtcjUIfHEWHlyHn90WPr0J964JizMGjcx0yzbFmKwOB0ZY7h7Cix34fg2+ewOPN2H7yIRBzKFT40/N4sMfQ5qeV/yyWFUQWUeo4W04ByXmGXvG89cs6k12NcOxPL18nDxc5GHP5WF543xW/bjk70jhsJup7ILuonKsoFoe4R1nGngbUvFSSOKShqWWKx1YXMi4d6/D559N8dmnXe7d67G0lNVbV33tp5p0hkO4c7tgZdm49sgyeP5qyN5eYdZToEEipyl8BFqflKpdZlM94eb1jPv3zG6r6d7p0z4p9bpwfUn46HbG2payuy+sbRtB19HSZh7TMPCfTwTrxiAvPa8dqma17f0Lc/DhDfjlR8KvHsCnd4QbS8JU14QP+hJAafb6aB9uX4OlOZjqKY9WYX233CmHWRdy+DhDOk2N5QUM1djUl+fgkxvwDx8Kf3dP+OQGXJ+Xej3DZ11LZW6Yw/19uLVozFzdjvJwA7YOTf0q5TmhtjJMWC+XaT46CbVaV9LPVWFfYb/b7xS7iu4Vosc49Rdq5E7CteR2dK0WFDC6ql3tpB39jJOSLcn9dNoufgrIOahYrnkUBkmAMj+X8dH9Lr/8RY/PPp3i7p0O1661rwNUbPV6cPNGRrfbK92km07+5NmQnb0CHZp1hqzks/Z8YTPuJOxl4GtYQuQwm/fFTrbWnsVp96zcUntrpcO92x1urGS1p9+3RYtzwgc3M15vKC/XlI3d0lW9peJJ2YYQM2mohTQSqMyqu7Z2qPTHZt3Ay9NGeYVZ/EZgYRYe3IJf3Rf+7oHwyV24sSS0AbtKk+8K3Fg0wnSmZ26Y7HbM5Ly+S62QhC5SmoLZSDXg03uVjEt6vMaEX4W8FDPx/+w2/I/7wj/cg/srwvX5dNmrLETMAvsH14ReB6Y6peKVKd+tmTWS4xympbkwzdb8nTMZNaL0ymI9Vy9sgCZb+I0jklGTkJePhSDrOdiepup3bqb+bxeNeZnbLLn6Tx/YFdjpHnXzPYwAOUTJm2NYLRRjdFTgsSgUNyeR8KeJ20plZTfuyZXpaeHWrQ6ff9bjV7+c4u7dDjPTky8iX1vK6GS92sRwdKwc9ZWDQyXPtTYlxIBItJyRNvIfJOuniIep7xFRYzaanzOny2+sZCzMXfzah09TPeH6Usbt68q1hYJux/Lia5WpZrN8FquHoI7rTe5hmNgc0qK9BQHy3PA4PQW3loVffiT84yfCp3eF5YXJ1y6WZmH6tplQFWPaOhwYE8+g3KElWbwvxcsWVwHbxpn/LpVPtWuxwJjm7i0b5PE/Hwgf34DZExw+vTFfOufsmHwPh3A4UPb6pYnMDhwx4STn8kg7NKal05Ol2zS5pwRTCy9BWAi1xjHix8KXqRwLug1sdwedfE9gD5UjtHJnMoqaDpXMs4UZX3NxA5/GhDDOVDBBKpEdTVrdT6FKtyesrHS4d6/Lg/td7t7pMjuRqw4naRYXMz78oMdxHzY2cjZ3Co6Oc3Pn+JD64GGj35btYO/rr8vg1a3VMRt7dAuCqUJL9cy4KqkEyFx5BmNxQViYk7cuPKC0nc9L7ayx2xPyA+V40GxykFhXs8jfo1/X56QDLhXG+l3fw1LuXFmYFT66Ifz8nvDJHeH6QpzHcWi6B/euG6GxugPbB3DYN2sFYLbCZpKekKLnNryw6oVtix+rB1Wz9VhLfm8uCJ/dNAjkwQrMndAkKgLLs/DZDeF4CG/2lPUDs923oNlYcJJNBXaZ3Nq5BAPgBBTzJjAGHYuwC+x0gV01cOQA49JkNqk9xLZ1BQzFmEykV/82oqg17hgCqQlrCyF3Qoh55w35czmxJ9pCtVzghvk54e7dLg/u97h1u8Ps7Ok70eJixgd3u3z0YY+1jYKDQ2Vnt2A41PLK2SaPaH16ULUurlXusF2bdz7ZYSoX7ZKZ3VeLCxkL8xnTUycp6fnQ9JQ5H7IwZzYvdDrNafnK9XtNdV3ZnaESylWQSEdvE8B2ACL9zVJZczWIIBOYnxburggf3xE+uiWsnEJ4VDTdMzu4Pr8Dm7vGjLN/bHYmSUZ5gXW8r9djwEasVbm9TnUiBKJl+asNKDNm0fznd4QPl4X5M+hTyzPwyXXhZzeFlzuw31d2jo0A6VamLFFrlkgIw+qLLxRjz1oP81W/XXTh9KOE4B2njlOL8/a7Om5MQfAOH7fUyTGwA+x0KWQX2AX2MbatM6ETybULpBPhm8qEU0CvZ+63uH27w53bHZYWz+bsgwgsLWTcudPhgzddtnYLjvuKHkOna3bf1Ahk5ERmvYto3uobeasw1tkArX6WZRc1NvaFOXP+Y2b6/E6bn4Q6GcxMwfwszM8KM9PmHvd6K6tjoHXr0aax4Pw4CMSL06QhkBuFZKoL15fMwvmH1zFmqzOq06U5+OiG2Z31fNPsytJBecjQ3iaeQgwxAUI8jvPMEzbql0chUxgo9DJjdvr4Bnx8Ha7PcWrhCUYwr8zCvWvw0TKs7sN+eYA3G22oPxVd9vnvFKSKHqPsAbtdctlF2FXYR/QYSUu9+ITlafi+SxNoQSt2HE8TSmnSQc4h8og6/wrKMFpTsLXF6k7wiq9uFxYWMq5fz1hZyZidPbtZdGoKbqx0+Ohel70DBREODw0C6fUkMtgtE5ZXbwFZrin8dMQSNkpY54OB0RqnesLtGx1urmTMzwqdk9oCzolmp4WVpYy7N0yb9QemZEkB4jxyy9J2y6BvHlT/eYTsthrm0M+FmR7cu2nMVreXm0NyZ0EzPbOw/tFN+GTLmHH2j7U+zR2YHhMHAN0yeL+byFZdeOjE8/NWYE7RH+dmW+6nt+DBDeHOkjA/PXExkzTVgRvzwgfX4Pqm8mpPKQalqyGr3cZzy+I+d5FDot4cS4eLbv248Tz8dDSZR+AaxcvfDVvlE5vL23lQ1SOUHdDtLrkcIRyQ6T7CIaVrJq7IIaV0aoeB/70pcy3r0lLG/PzZOQwE006LCxkf3TP7NldWMo6PzKlcx83JGAik5r8OEoat5WTEzGVTPjTl73aF5cWMD25nLC1cjvUPm2am4N4Nod/vcPeGMqhcvXuH6drXgFzFqLWKxzrtaadqnht3JcpUD25dEx7cgpXFxk3HWVBlHrq3An9/3xxCPOxbDhfF47DFZFKXISlAWp55cYx/KzGbB7pw95pBH0uzJ1+bSNHStDmEuDxrBIrS+Kq7oolJgWNF91Ddq+4DOVbYQ9hD6CvMuDq6p8VHtXcXebSuWfhaSqQlkyjIehI6ahvHJhtiGf+db+Otw5VedUUMApmdFRbmMubmgk2fp6KsI8zPwwedDouLGR/fLxgOSw++jQXLorbcfa3Hkg4TMl2d7JbMeMOdmxUWZuVMJ7yzoNlp4f6djOVF5bjvem6NIViHIqYb53mUxq9Ix+asRgvvdMwBucVZYW7amJfOkmbKtZCZKfjkNgxzacCCL0Ba+K0pVUcOAmknLf8pMGc/5qdheVaYO+P1tE4Gi9PCyiwsTAvdjmtJ8NF2bG3Ud+/iIta41m6nMhpVWKFHmQklff1E4Fo+Fj/IR5Nh/XQtxN1H2UVkt0tGgTBE2McsqB8DM2HRQnobEvxtaQ1q/SHGFNLpGZNS7xzOP/S6Qm9BWFyAcrXzisak6lDh9aVLBo3eEomY8xULY43qiVI+4buLI8Ggjpmu+cysSXLcueQyIZVLwEsBclzKi71u0SkUGCDsI7qtyCGwRMQyF7WL+lKrQiCRdYjAPlqHDWn0pSkt9tZI+OZTbFacjpTOK01V/MsxXK7oiq4oSS3rAYELEutZHA141olA04+k45v+Yggk8TtwrtiSd2wnWLjxJrEeE0vHWX+RoSAHmI1Xe10yVYxjrD3M1qxyHcQ+UDiB3DvpTHrhM7Cmf43gRTFbQwcDpT8wp52nztiNR1EYNyf9flEvXl/4WoPf4a3+1OmUKKknZ17209KwgH7fuHfPC3WubjXkV2R6wJ0nVcpHhjn0N90zbsvPfIeQmu2yR32ziJ63XR13QX3MVjizDKYzswV7epQD0RPQcekv63hoxhHwDmt8bx2D9BUOENkD9roiWmDOf+yhbCtyUJomL85uUpvl05Vz2mpLoYxx4vhbHYvcCI+jY+XwyDhGnOqdXY8sCjg4VNY2cl6t5qxvmK28WcddYPXdtIxFscunkmHdH9XEIxh34jdWMj683eHOzezM7fYnpUKNZ9pnr5UXa8ZZZaHNPelSGf5tiiyMJDcdxBZRJliTsmVZdedFryvcXIB7N8xaxdKcEdBnRf0hvN6BR2/g9baZTM1BOrVY9a0ENsdhGeywMWrrW7U5WE0d9LpwZwE+vSl8dM2cSD8rygtzeHLnGPb7RpCOva4jDZ92kGh/STEQW7McY9hONk+FHfFM5GQssmhfkX1QI0DyQgrMpVJ7wDZwgFA4i0mnmL2jcK+NQVIvQ3AXmqdS+bdwZI2bVlOWmN1XUpi9+/0BHBwUbO/k7O0VzM5mtbfd01JeKFvbOT8+GfLtDwOePs85OCqscyAlX20CxLkHpHrWPK/L5UZyPtzdWFKeRDdP5ueEj+91EITlJaF7Bocoz4IGOaxvK189KvjbjwUbO1rfYCdZdb7CWwx1DlC5UH+UMIgFiR0Ms99Vj4aFmdynp8xZjb9/YO6vmJmG2TMSIArsHsHjNfjvh8q3r4xrE3MORINNGcEYCO71acK3b5Txx7zd77Q+hd8vzCL/5zeEocL8lDDdO7udWMMCto+UN/vK1pHWnnmrvh345opsa/VN5W74eL6xe0FSZKcams1azPNJwRSWwV9gb50rU2Uyf8eKHoDuA/vdg0FPQYbAfibFTjfTw26n0MpteTGpe8oJ6G2CsZNIaHuwDYbK7l7BxmbB1nbOteWz08LzHDa2C56+GPLwyZDnL3OOjgu6XaHXM1zbdlu3u3iapN0rRgkQfzRVAqTU2itXJnlhJjlVuHenw9GxOQ/ytkkVjvvK5o7ydLXgh+cFGzvGK2u3A2RSTkxl367raoyJIWYrTgiZ2DWmtmZfhTY3CUKvpxwem91jN5bg7vWz08KHQ1jfgydr8N1r+Pal0cirm/0a3qqJxheuVrmcT6uMsTCB4KwmY/vSKOVwaHgZ5HBrCT5cOtvdWIXC5iG82FHWD43AOo0bE0OBTfTM6TJa2hQozNnPQzEHzw+6B8NegRoB0u3kOzMyPOiihWAd8ffgXXMbn524NO9IdyTnXZt2HNwY2ARsOvIkUtXDmgFUJ0i31kYtW5aUtwUWBezuK69Xh9y60WFlpcPczNlIkL0DZXUt5+VqzuZ2zmDYtEVuMRxzy9JWPtRvj2ZQm18RPF4eFqjNDhifWAdHwtausrFdsL2nLC3ouexGm4QGOWzvKWtbyuauualvkJtt0YopQG516Nhp69S2x9iI1oQnvdgh2rBqpa7PYWFOiD/fUD7ahI9vm7s/zoK2DswJ9KcbRpAcDc3EbQ7yUUPvmq+Kz5YDwYUTVp2x24riy2/V94qHfg4bh8rTTXi8bC6Nmu2dzfminWPl+Y7ydFtZP1CGhTaXa4kRmFU7gK8UuI0XGzv+onbqvvI6ScI6ssMm70xqmUeDmyIjSmKYZ9iwDWpq5lW7BhQZFnAAui9mrfyo0kFyhX1F9hSOgNyw096CZ4YgUoP2lHReCKfTMeL14LDg9WrO8rUhN292WL6WMTN9ul5/cKi8fpPz/FXO2rq5obDbNduFs47UJhinbGNMar5b8eg7f0K1rnX188tzsyi7sa2sbhSsLAkrb3nb7GAA61uwuqHsHpiJbWrKnH/odq26Kcn3/VOjNCJ9xzZJlEJopPkiEt+uY8XY/6tJdG3HXAJ1/5a5eXBxdoxCt9Dx0Kx5PHwDzzZgr1/ep17eLd7JWib8WD1EJ0Ch7SS1T/bzAswOAjWC7dk2fP9Gub1kXLif1h/WXh+ebikPN4wQ2Tk2ArHjbee9KBqV10XyMi7Zba3miIft9mrYne4OtTFh6XYnK/YU+oVKgyrq8WVr/P6k4moscXcn5a/mCrfmeT2wUqiimRhD5OEhhlqztviIaet2+mJ9V3dCdY5Uijn4VajQ7ytr60NmZ4XryxlLixl3b2dMn8CdO8DhkfL8Zc73Pw548mzIxlZBf2AGvDmBLuUc55pe6oFMHSQwRVRxxCqNf++32KuF3ruGjBArCjg8Vl6vFzx+mbO8KMzNSH3v+9ugnX3l2Rvl6Rtle9+UpdsByap6q4rgCQ6p/6k/mxBuX3DXDPx2cOPaYZr47ttuR+q1kM09eLRqXI/MTcOnt08uRI6H8GKzNFu9Up5vGtNVVk6e1bUBDTcVn3ZvMqWqvzm3Mlp1aJ/Q9JWPQHu3R7S5u6PyyvtiR5mfgpuLysocfLwsJ3brcjAwl0n9+aXyzRtldc/k0euYg69S81Sie2e8lNNlAjE4teOVqxlToVD1f4frElbnSrpGsVLzUG27WxIfMdnzaRXDQz8itb6kaAG6K8IasAnSB/LuTDev8jkANjPRbeBQfQFxnvSOIZAsE1BlmMPBkbL6ZsjDxxnTM8Jw2OP2LWF2lrEX1fMcDo8KXq4WfPNwwHc/Dni9lnPcV+PCvSPO1s6qm8W0PH9uq3/6A9wOk9KYEzaEbsekk+ewtlXw5JVwc7ng1krnrXnmPR7A6pby7E3Bqw3l4Lg87CmN246aQpmYeBGGiV4i5de19V39h140EdOOnVKIrG7DNy/MRWOCuVxqdsoghnEoL4yrkldb8M0r+OqFQR+7R4aXqU5tlWwtp/0zKIPz20UgqXSiwBfjFReMm5y9Pjzfhq9ew9y0khfCvSVYmDan1cehQW4cJj7dhj++KPjTS+XJtnIwNGX2+8JZzRHjpHMZEcYoKkUpGMC4LbAKbGIQiHb+P//3/7c2c4swK8JnIJ8rXEeMD83mXnNH/Wq0MfGRR9mpyjiV7HNsdhKuZTiMV+nWcZqsQ3tepZ2bPKvfxmShTnx/HlU73QaCNO/sMlXplfVR3Y0xGMLRsdHIBwMFjIPBqSkxyKGFhgNlfbPgybOcb34Y8NV3A568yNneVVSlFB7iuHEXrz1EpJkUyoa0w/p3dWtdFyUusdGGPbvUeXjvyr9czVmLQs0C8LVFs5h+lluax6GjPrxcL/jmScGXj5Xn68pR3wjwTubWTShJwmcGEUvdzoGsqIVBYlzYzNVplOl5AtzeIq4I/Vw4GsDBsZkM83LRtzoj0kaDAjZ2lUdr8Ldn8OfH8O1rWNszu5E6mXrmm7Jv2GPHrQWHdwdcCGWciCCNVHFF2vS6pvxirB2Ve/uDoREC/fKukEyEme5oIXI8hJd78M0b5Q8vCv77mfLdWsHGodkw0cnE8kCszlhw5yb3mT8H1XOGWNYQr5y1UK3nI6sOvLpWp6/575p5tErQ2eFl8WPzFb5z27BpFw3nwqAsAsJAhEcCfxb4QuCZwLGt1wyAbUXWQTcx9q4zWMq7XHL3NNz4oLTbFUSN9rSxldMfmhsE9w5gZ7fD3btdVsp1kaxagMcInjw350e2dwperOY8ejLk0bMhL17n7B2Yu7x7vcZVur2Y6UJea7DjaAzlu+aFWnGiVG/9tbCxF1zLYLUZb6hsbitPXhXcWMnNltTbHWbO0KNqGxUFrG0p3z1TvnuuvN40wgPBbLuu+LfKEpoiWurPCxLrP+qlE4RpqXIt35u7Xsykub1vJtLjAewcmsugdg6NaWt2yggSscpSFCbsxgG83IAfVs1uq0drsHlghFC3PEMkXhlD80z4O2mCibwNrlAdIz0ohYOYe9Ff7ylHOewdw/YRbBzCxyvC9TlYmLJ8wmHGxaCAowGsHSg/bsJXq8rXb5THm8r2celButu4yG+fA852vjrP2e8cN8j6OYE5bL4FvALWMPKh8IHxIcIm6DrKrsI00PErIQZ/Q5t7k7k/4TUaftULpIlpdQzntxXVkZh2erg8OPx534KdCmpxWkl8O88YShejHRWZMWdt7xYM8yGHx8rGZofbr3JWljsszBsh0i3tucOB2ba5v1+wuZ2zul6YA4ObBXsHBaoGdVTIInTuKM5H5EfQSNVuE9QKWWtJXr0JuGpO2K6SlcItN2V5vlowM13Q6wrTPeHerexMD8PFSBU2dpRHLwu+fFTw8IWytWfe1ZqmPdNW8RxbvvkW7MIJo7nIA6s/Wxo90Kwl+fGtuPUEWwo205fMJD8szE2CTws4GMDmvvJkHW4uwdKMcbg41TXxhoW5cXH30CCNV1tmveP1ttmBNVQzOTuu2y0eQi27rAdrdgrGThDHr0VqlBHcCyKuVlJ1NcGYG4ui3JV1YMq231de7Qk/bgg35s39HsavlUmjn8P+QNk5gtUD5dk2PC7dtu+UZjuDurQcSxXC9NslUlp/DKUUBCeMm556vcytE7eOnPVJfwK02iWcR+N5O+l57RFrVV+xEjfsQGEbpDJhDYgIkAHoFvAaYQNkGedEeliB4VbSCSrZ5XdkvHHeOyFjgm7iRD2dLTJPd7tCpuWp18OC41fK5lbO81cZi4tGgMzNZkyVWnm/r+wfKHv7Bbt7Bbv75kT7MFdExKRXLvy6gssvULyuLXEcCFs7hRCNWCmJHzqkTgd6mBPqm7vKw+c53S7MTBnEdfO6ORR2HpTnsL6j/Pii4KsnBT88V1a3jOv2Xldc9ME42poL7+shGqtc9wuBePU1LHvOTPBRpVAhkWF5gvp402zxfbIGS/PG3fnijDFpSWYm0INj2D40AmP7wGju1YG5qU6L3V+cX9Fytna/RBkgUt9O+Rt4YkaW1nXeK3ktFHaOlIMBvNpTHq4L12aNS/aFaZgpF0+Ohmar7vYRbBwpW0ewd2wODEom9DIhy7RWxM5ufvHKFfwOK6v9bJG21nWoNI+maFkk8nJEnyw/j9QgkHXMTqwcoOtFHmKky0s1Ae8D07E8T0VnAr1Oxo0v7/x1j4nzKbXHTvl9ODSH2fp940Zjc1uZnhKmpjN6pbge5MpxXzk6anxpQbno2zUL5rYQuKxUmbIQsxayuaM8fFbQ7eQcD5TPjjvcvSEszZ9Jg9d0eAxvtpQfXxZ8/bjgu2dGePQHlJsOCJYbXL13RLnOlNvxSamQiNIB8lw4Ln047R7D+j7M9szJ9V7HlHVYmq8OBmbxvD80k2+nY4RR2+FWPeNONpYe1vYeaywVxjR1ODB/u8fK9J4x4c1Y60GDHA4HZpH8cKj0y8OunQy6mZ6Zd4h3kcZq2vGqp8B4Ktks/w6rF11P7g2BDZAXCmugfXDtwD5TPuQKJaQV2TfBxBBN9ekjmgruBTFsTTqssgBu1/xGOBDvmR0mMG34KqW5NrVCI1o0W10Pj80JmzqkaH09LpQTXnlKWvwjshL+8G9Ec7XLCESyyx1Lz8/MqXs/vvu7WtzvlucZ1rYKcoW9w4K9Qzg6znhwN+PaGV08tXcEL94UfP9C+fpxwcPnBW+2zSTaKe+MT+24inliNg/c56hVzhhIq7Roz5TVKJ+RHYwxM6GdrOIcQpMMuqKmL5Vd8WgAxwM1w9dDFAXVxCnmvu/Mtvn748Xq9YGm65pMxEJmo+6qUFtKxLaoihvG3kDgpIsx53U7Bj1U3g/2B9S7qexjA6b8plTdDESk3KqsmNNs1kHYqKfalIbvzTZOx3Lnu3Sd+Kjeziuczew+ZMeP3n6YzDsySybQj9aKVgQx1Z/SxwiODUG2MeYrAHwTVl4GfE1j57r0mvBlIRGj+XSQeodWXhhzS1FY9uFygNcTXtnpIS3wLjOZyc4ITHOYz+xG6w9zDo7MmYy7NzIW52F+RpiZYuxT63lhEN3BMeweKKub8OhVwQ8vlMevC9a3jNZtvAOH1qN3jew+UlVRJRxyuz9V83QpKCQzk6dtrjptH3qbfdAuf1X2YflZ3QxahavOtXSl8XkG5z+W3kr9XHz/VsojHhgT1gFW0bteLRQY+9YbgU0Vjpo0bLRhpR501hhGwNHKmoOEftwWxOBJfLsmU8f/nfQ8tfOk6YVaehVGgseVJkRH605dvqh3koivMXvZjNNJ23ZWhe3Q8i4SKKkxe7+Na4jqkCXs7MOjFwU7+8qrjYIPb2XcvZlx57qwvCAszBpTzFQvvNFQC+gPzW6qg2PjXXd9S3mxrjxfM39vtpTdA3OveOYtEsfay7agBG0+Rp2M5Vwx0pCj0wtDBojaYrNjrREAkDWTqLdbtE4hqR07ANMfk2a8GlOgr4l76URK6c8VUfdHgUYeJNPkJ2Y3j5SKWWHViSm71OEsMWyhrMSYbtPaU2Fi/WySOvF5sL/5iqSHRGJ9NTX3xkqcGs8mr2jYoYpsA28E2UQ5tuP4CEQxrky2MBJnH9Ne0R3Y75KWfFFkC9dqjSALJiobjpbxLoK5c6YsM4ughZqJffdAOewr2/vC2pbyakO5c124cU24tpAxOw0z0+Y0ctdc/05eOhg8HsD+kbJ3aM42vNlUXmwobzZha9+sd4C1PXWsLZrvLomYXUoVJSddSU0gJ6O3XZ+1nKyESPU8UODaJugrOgUNMfJgFeOtfWC/7Eak/rAMuK7CBua+dMehQiPVY0jBIwkPDLbFCbX/UgIHzt10DB5iW4jL3wnk5IaJiOnWNQXwtXcpH0ksbgtfqfwcTmPvUjYcS7NMvQvXRMI8RvFnxnnp7kS1PNegHA1gc7fg+RthcU5YmFdmp2B6ygiQauG7KBoBcnAMB0ewc6DsHsLuoXJU7jASzKYDyaRWb+x+GS+L964FVSTb1ZnEE2i0xY6Wctdtp+drm40+PUJLL+OmhIv/3BmNQb1Z402aV9Gx2iLYHI3Xi08ybHpUhrf62SEq3qt2CeebVPyo0EnVX+R9U+40kkmvWcT6n8dXDDF4YZP52BSp6xFzZB9YE+UF6Lr6AiSWB8bOtQVsYFDIDJFRdtYS/n3UGJxOZ88E7yHVxSvt8Z2OUBRmYe2obzYUrO8qU13jM2uq1yCIavG7UINChrlZ2zgemL+8MB26m1mHwrKmKt/nvmP/HqmwXQBNlKd4n6fM8zTlP2ldvY99q6IxytbH7Mh9gbFKDe2XKQFyhEEhawrbau5In/JtgTEGopLXi5XUjJzYni2wZRdWkE5Eq6tjjmEyCjRI/9Bhwx7+yIhriC0ab8BPXKt18/bzbBmdLbt/wh1bYaBUeeMeZ5uHFeKSrFIEzel6LcxdKof9cqeQNNGqrbfVBoRCjQCq3I5XW4brjQcRPlKoIM57DFWk37nvI++iiNWNN55G6acbyd8fizFt2E+/ihO7/6SN3wB1jq9lt519CCwTY9VJFdZGG1UdqPUsUZZEGdrdpad4scImnR/GyuJpkk6YEXxJWG/JPualHS+LHSBahmNR1kFeYQBFbieXEiBDYAflDbCBcAdodZOXnpBPK7/TlT1uzCu6eKq05cp2n2ViXJdDvYXZhBFnSzNQmzs6Yp8oN6f+K7dBMW383af2El1Meb1cxhhvl6Ud0mrtu0CXkmfFWKDWMe5L9vEY9c+BVJQDO2q2865hEMlCkLo9t09gS0hZckL84UpDIZ684L4MtMhEHudOfiEuhb3FYiLFT6iUjEivJZCU6xWYf0QFLS80cgSHDcrK/lTtLqq+uwGqbEcwOFFZzpESfUE10kvrsO6IUCJjxterbG3WByeTmJFOaHLyeUyNdedhYny4zZUQbJE2bauTUX1AI2FjaGISStVJNNmRdTIaPU5cJ5FnZd85BjZVdA3jH3HgR+kW8RpVjAnrJbCq1slDmz+NcN0K3SKZAK5Job4PxO/9CVFnxW+26tqzURpum/dN2CCMb/7xwvtZeQxHwsQgqxfeg5iTLqJHeY6lGzGj1SaeSHp13lFIPKpO3LleRKiuJm/6hstP9UsE67BTOu+w343fDm0bC4L6ipov4m1ox0+ZYkiVzQpr9+CUuVJj3wPTRstYaDODBGGqOvfHaBMneU+GE6565z2PlLt557Z36mBgrAwxk05gcrNf1u/c2dwN43KZ2p7t1onf/0Ls1F4nburBsxZBF9ZJQiAJYO49X1OzeL4XSy+FQCoB8gp4A3KUCnRCoXw2NEL5vaLLSbbMCc5uvNUONQ6dX6cbleo44+1SDYeqqoQTVdsk5T3PbnMReYxLdp2cc1vnCLtihMcO3vmPirqFFrHnCuyBvEZYFdi1q8/eJtfco11K55YFupSkbDvuH0vHhBNXgqsleWNXbHoZxJwLJjXSlEYdedm6iF7/imn/Xt5teY6zyJ/I23UnM4b2nkQuds2K9y7OrwQh2gfBRO2Q0NiiCURRlM9LGzKs7lFp127tNEdqfA7PldZq99UUMnfjtmrHddgmcnNbTzydcRaM/TGkPp8ByorzRfBbA609tU12bHQRQUt2WDd+jGu3PVJ54bWTgxQS224DXiN5Ny1m8ZdEUWpNDe6857ieitSJCEcI6wiromyrhuYrSBwQLGkIugHlQrpnxhqX3qZGdKm0sQi9Df6k/o96QTo6s0+Q4k+N7OqqBIlzEPqKrugEdJnmKzXrH2/ULGNs0XiPcajr39HsUWXGega6qsg9oFdlYaPSsdyJeE9S0jaWThBG1c1bnFfN94QErqW2HdbPI6aR14/GQB6BeSa0odZanG/LqaF/omCJ9FL8+fm5NgW3Uuz0xF6QsF7G7sdO3rtcRRUrLG6QesFX7fyqh1UcOze8d9Eso+iiwVAtcZuGKXkvsUd5si5EFiGpFS/JT1Tz9ZlogqZdB8X6QoW41I1Urdz7CCryGfsWtJ3NO96PuptZGq9PSdTT9NEAeXhg0tHwA34jrZOY9lrnohNYV6J9qoW/5BbklmuD033JvucmjjSdedN6J7CnylOQhyhrKu723YpGubTrA+sKzzCS6Dq1ABmPrhBIms6Nv0oVVhynjoXi+CZydjvZZzLEnaxGZ/b+UzWVKVadlp+BaiaNU7/KueFPo5au6DR0iearQg3qeIryBNghwV7qHEidELAB+liRp4jeV2QRygGhMa3B04ickeNJwYhaGGhWtYYaivKR0t9KOJC4tlJWHSwIbIGhxlvvAvHSaRCDieEULWWjlNqaHt3Oap6rO6sH5bPKWKUpzYRXqJAX5sbEQo2rkGoirExYWQaZlpcZQe2YztV4PW22bhen4DG2EgfsqnKXmr1VSRqrCLtO7FcVqqkrVZ3nUWTQsmuqWRzzymvVcV4Kj2GuDLURKlW02ttymUTWRK/TcNit68nXssWK473zyuL0rTgAjNRb+sa66FpNMD7CfELHi1Y7i5eGD4yCuAEL1jzhTh7qvPPSa5He/qE+ifARODR04sfTi6+p+GXw0o901radc009xeZcjYYN5+sIf8YTySsVeYzyAkkvX4wSIGCkzxPgMfB3wIche2dPJ0n/VDxFTmSmw46V4PjpjUs1j+3p1Se561PcwlRP6XSkdCFv2FOVEp2UAqa8wySjcRE+itxhPB5/rRQR/qnB4FvXRic4Ll9hqrY79QKDMGamykvAOuV5FRq0NyxK1+ulKxf/1H2KbOHiBz11LzonGBTly88rNmGdV96Xlcaok0tABVpsAC8ge4Wk1z8AusXoSWJPhceCPhZkA7RQJYudHIYGKYSSU2i07Xiz247gfNt2q/2x0mQqpdEOJO6TcBeLNar9+6ADVGTFCzJTKy8ptXdXM7B3I/m1E97TTXP+IRAcripjo4l6osvN5NXtKDPTwrX5jOUlYWFemOmZWw8HufFPtbsPW3sFO3twdKwMy2thO+XJbzNRVzXn8iJVALX4izhY1OC5ukGDmTUCT8UPaqm0EstbcHe8pEawi1r8oLZQKNR4Dl6chZV5WF6AhRnjn0sx/rv2j2BzHzb2YefIOIeUEuF1rO5mwJvVB2q2xPsd9hcHdVrlF+uZr8lrUE5pduME2noa/dT8230f91naealdXrf+3XUcddCZeHnFXHAEv2KIKdi55PWfOn54kVaNmGKukoL1vyafUe0xCXJo5hl7zrDjB6Gdd/6butdIOVYK3adQs+6d6TpIdPtuRV1arrws6UjMQvpTlFeq7CpcczrTmJI0EAE+lGuLdEJpndRQrEE0Kv2xNN5mJkzGD99I2Nl9hkeprGXcav6unBGqwlQPlheFm8sZH9zMuHMj48ayMDcjdLrmGtrdfWVtW3m1Lrx8U7C2BXuH5XpJ7mrXbpnczhsbKG2cN/3HmwitMtVhq4Fbv2rqOtW+wQQWSVqDJ0T6pNTCQwTmp2BlET5YgY9uCHeXjRCZnTJxDvuwtQevtuDpBjzfVDb2zN3deanH1dfMJsZOw18oNmLlmZRchSjV8TxmrCCT5d0SOiXPW1Jpy/ss6iSqLPpK56nrJEExmTjG8D913k4/1G3V4jHwGJWtUfNPN+u2Z18qtXsUvCpyea6wqso06Ew1gE84t8cnjZPURoIBtSaYcKqxBEdCZQlZsbQy0VIZkAYCVNqBWpJ9bHK1kXhMif+U0p9UofVi+XQPbi5nfPpRh48/MAJkZUlYWhBmpowpazBUDo5ge0+5dzPj2UrO45fK41cFm3swGJgprEYiVqXET5uXwiDS+eu6rDVeN0wQx8qgWmYJgKvY6caryHXC6eUZFqHWepVyvUgNUkNgYRo+ugmf34UHt+CDZbi+aBDIdM/E6Q9g9wg+vG6EzKM38MOqESZ7xzAo1Ligl2YTw8lmALfAkyQRE6bpsBrkdTKaQAxG+9bZ5Hi6sOkypGpo/HRTdVsJr7ZOO24ehPlYwqMMsa2ZPEJ5hOiWjXhi1B0M2jtF2b/zIpeNfCCPFR53Ml3udJkWUamd4dVsuhXqaoLlu2RdiAUXR2tfPlwWa4ZRETdva7K1H2j91ZqNIgtrVYbNwRuPv1qIVEk1eUvKnUpki64/MYtqCVVt+BOGVTVasqq56e/WSsbPH3T4x591+eSeER69nrlnurnVTliah5vLyr1b8MFNYWWpoNOB758rG9ulB91ca0eGfoXWxlF7wVf9+msa3Nf6tUhMgLYA8Tp/YddtnWf5rXBfxPpfEYwIj78yu2G9hmSExP2b8I+fwD8+gI9uNKarjnX/eFHA8jzcvWbCfLBibl9UUZ6uw17frDmJmPUTtxBuecNxEtZJ9GCdpyk348XOSJ1nfv039+/YY8oL42vmdjqpQ4zOmHSVJv9gnMk/nlfbgnaAJhz+PCUxsc06lkPMPOcvwqcO98V4d+cxjYcNUE94v1KQV6Q9wjqx56oyNWGovWxNuzxS4QmZ7IwSWN03b9rX0SsFaTiUnWIoz7s9fby4UHwy38tvdjrN9tCzoLZkTp/FabSnGA8R4XQqSiUyRuJqBlpemAntxjXhZw8y/v7zDr/4uMOdG/FrczOBrGvWO2anYX4mo9sR+gM4Ghb0BwWbu8qgbya7bsfpx1XW1u9q0nHD2Hl783s4SYbzff08CBOZaFKTp02tLsa1ed8fGt4XZ+Hedfi7+/CPH8Mv7sLSXCRhjDDpZDDdNQJmrjRtHQ2NQHq2acxcqLm9USKD/TJRm258EXm/i2mfJ423tX6SBK2vHfbzOXk9XOw+zWfkDcJAksvnhrpvVsc71jEcyoEqz+fmiscz07ouIp9kHe3mqthHCluRR8hz+duaeEZMAO4k4gbyt2cKSmUnCA46SpVZWiMKB3eDBqSEdrXGWqan9kG4QMPyEE1QHh+p+jOlmx5qtBFVRdVowXOzwod3Ovzq0w4//7jDzeXEnesRmp4S7t6Ew36Ho6HQ70N/WLB7oOa62q6FJnxtzJmE3Wf2oneIwvx6iGjEzuFC0HrjR7Ma0jgFdTNVsWvSTTvKO9SIulDodZXb1+CX94R/+Bg+u50WHjG6Ngef3oKjgdDPlYOB8HJLGeRitkDWfSem4VefVm149Z7UQu10klp2qA2Hd2qE63TjLLgHZYhuhfW0dj+Ox6ubHgH59RV14JjaZhvT2oO8I2XwbLspJ4hOmPqdRJ768bw+a9eV4r0joHhescj0VeR1Pi/P+re7rwbXsh0ykGG7qO2OEsX1nK70M+FVJjwR4Q1CX2HECsrZ0dkhkJOnFEcgesYIxOevPXEtzK4r1Ezwy0sZ925nfPxBh9srQnecjdoWzU0L927C8SCj31fIYGvHsDHVIxRGUT9c/sTcCEIVv5x+x/ahdaRmWgaKn0xb9aUgf1EKkGFutup+fBN+9RF8eseYpyYhEbNb67M7sH0IL7bMDq1BeS4nkzPqPpeA3lWt/kzoXW3ESvcv2Aee51PyfLjc2RzczMzJ83JuSVH35vXoCfWACmUg8Lo3pY+np/WlKtt5zlyh1AvKVX6GsZhcdcmXjuaHK8l91FKHtEwNzWQR0V5r00rEnhKETmjX1tsaiUySXksIP2i7A8FQYy4wpqtMYHZGuHFNuL2SsbKY0RvlZyDGhsC1BeHBXVDtsDQvbO+bZqkud4oiGo1PyMGDiNZaRnefjyNANJKufxAwRi0uYCoBQvk5Ny3cuQaf34HrC/EdaaNoqgu3l+DeCtxahOcbcNDX2jNAx6vTAHnEEFxCa7fDt7kAr8KF77w+LwRjMHV4LppXsBbSRJZWZFQ98+OHFPIVH0Ma4T3ML1YnMXTbzATROOLHTb9zZoxE3brugeJzZMjv6DoBUKUQ2EB5DDxTYdcJ19LnuzdvDNNvXSqAfYRVyfRFUbCqyk01hxHfVfn7zlOhxrY+1YW5GWFlSbi2YO4bPyl1MlhZFLoZ3FrOOOqbxeFKeEwuQCYhC9FMlI43muyBE/gQS6fiK1xTXZifhmvzZs3ipDTTNeas6/NmTWXjEI5zoCgPbZ486RPTWSOGS49AxqjkE5fh9AaOM6exWDECIkd4Q8GP2RHPulvFkQrQARm2J9TtTWjiUHQzR58WyhNF74rIDaCb3lllxy0/A6kaCeO/8DX0iNiOT2BGYo/UPJx4PhKxf5YagK8pRPMu302iDfvljEYVK5xSFCadmWlhaV5YmDXXx56GuqUQuTZvzkEE8/IF0DgDYDx+JuO6LquUGw1SQnNCmukJ8zPK3LTQ7SiHw1JgWWjaaMlxdCH1P6HWHcMAKWeRdVwLmNdPI7byJPLwc5TmV4haImM9NWfErmNIhLXXDFPl9NFayHME9dkvA8QgNQ5IrXmMtUssOleEeZnn4QhMHg6M1VXCGWUZ/pgOqwIPu/vFM14OD3tbZae3t9hGqEs2qcjUw0z0OfBQ4WNgWXUslyij0jUf4w7Uk2inp0woMLOcMr2zooqvbsfsqHJ2S52WKtRBM+FcVAnfllZuGwuEsxEeYARRr2NOsmeZJTzG5u3i1dvzyTGe6knyejsKv3s6xmHk3Dvt2ZZYTUF2FV5T8KxzoOvZUd4ftxzd7tSIfVo+iR6q6AtVHuaF/F2ey8/ccyBlMPwvjFX2kUEmSU/GCBNL+yJ7ZSrPUQ3oVHCpXWgzIZ1FEQ6PYe9QOeo3p6gD3HjK2bWNT4l8838m49v7ekey6Grt1RpINzMHBOemzXbc7mivDSNJmaB9vL7RGsd32T4mL35W/gPnzvZJxsck/brOa4yEk3XiwKloXu1iy0de6TqprpJQMJ4UYpFimZ2gTmJt7wdvrhqIpJNIV6UMX+ixFKyBvERYlVwPyEH8/fYJ6h5F75lKkyIDkFWMh96XquwDwcbGWFn8gzjjaFTJRSCIwO0wbNKOHp344qYrJ+8AHqdrOPT6muLXTtdPLw79K3NaZWYBc27h4FjrNYvTUH8Aq5vK87WCjR1lkDcmFGchOboLawxqq4vTUDC6iLRZOnqBWVMCZapjtuzeuQYfrggrC6djbZDD0cD85daaEvUcFNFsSZkkIs8Ae9tt+4167tM2T7sj+XEEuju2Qy/dIYXmpFBLTPOgwbNUXPV4dd7FzFwt9ee3ha9Ax5SclOkqXie+6aolLy/dtvJ6+SoZWyo8QXiGsKWISpdg2TBF3cdPJlttVZVCle1uVx9Pz+iz2bliY3q6WOl06NZS/O3gyp8kiTTmkMNj44dp78BGDCejgyPl2ary1x8LXq4r/bw8cS3iCRBXe7ep1u1abb11QvhPSL1rE1qZ+yI66Y4QIINyY2IngxuL8LO7xtfV8vzJAVeh5gDh9pFxddKvBIjN18mSvqK3SO9km6lBGJqRF9PyWqf5VjvyGJG9sVCMRd2vv5mZKEKRC6oczczoy5u3hj/euTN4NDWlN0X0ejU0Hbuu7ZLC0xrivIoT1nsc0dAJRrXaX6wj+/E8Y5OR+K+aMIkZpA0ptd4/kVjoTNZD+c6+f6LbNTPR/hGsbytr2wW7BxlLE55ZqOjwWHm9qTx8qXz9WHmxruRqzplklQ+nmmcbnfkaW1s9JjKPmqdCLSzxxhIgVr0mNOZYeyvKoNo0oEZoDAuz/fbWEizNJvgeQVsH8HpHWd2FnSOD6MwCvdZaZVJD9bR4883vH1UZ7Ds+4unEDyZWvz2tvVX4R7T2xGdbH2jyCpWIdJ34c0jLFufo2K8QkmcNifWtBJ9xRDgaMcT5dNszeZeJh1bduBHE5fFnslXIQbtykM/J4/xa9mUxJY9RDicWIM+fTU0UIc8hz9GFRd3pTcnjm7f02yzjwyzLFwvVqSv0cbEkGXQwhwmP+rC+o7xYU16tK9fmYWFuMpVZFTZ24PEr41Tx9YaytWt2sZmDhOIJEHsySgjy0wqQCUxQreaBYCKIhBVTl0ppchrC3Ax8tKbcWRamu2ZdZBI6GsDzTfhxDV7tlP6wtLzAa4Lm+UkNrTZAesF0CVg4WzL9WwthaziVPR7Mdr4vZuQNBcNRrkt8mnj3lKX5HvV62ePpqe5fez39iKz4oBgWNwz6sMWdLRFT9swYqvDCjLMGEkEBycaP2uATaGWSdY62d7GtjF7Wo5CHy1/pyiMzkHQ4NJ51n74uuL6UMzOV8cm9DvMTgMzNPeXHl8o3T5Rnb5SD4/IypNLHk9Q2dnXML9YTi820pha6RFErgHnoOyCVMeo6mHci2nuVTjNWXI28U/bZvIB+rrzZhW9fCdfmlKmu8MnN8U1ZhcLzLeXLl/DVK+X1DhwPjb5crYFUNvVRNm2QoG+2ac6jtXaLgnT9vCPox4sby7vhL933o65WknWSQkgRTmNlCuaVhKbfUoZY/bXdppiukzBwih+7nOPXicuDjbU0Y7/IeDaU7IcBnUeFyjYaXQpqpe79+2MfJAQMAikKmJ9Hb91kbX5evul05BfDQv6xUK7HZ/orOk8SMUgEMQvpq5vKd09zul2QTLh3U5idkrgrEkx7Hg1g/1B59Krg6ydGiGztlf61ZsQIkI43mVkfkEYIKSht/x5nUhsHecQmYVs0xcL6/IkY4dLtGAFw1Icn68rclDBVooaVebMu0kvszOrnZs1jYx++fAl/e6E8XjfrH2AdHrxCIFc0AZ1JHxAKFXlTSPZ9QfZoWGQb5JKjTOwZt/v3fz+ZANHSZfhUDxaXZGdhrngoot+rFi9UuQuyYDsYq90YamQiaEEezaD3tXiLl0Tk1hPMrYcOvXTbEETidHO8+t08xX4e0aCcUJF0fe29etLpGKeCuwfK49cwLAqOB7C5k3H3hnFzsjTvLoIfD2BnH95sFTxfU354XvDdM+XVpnI4MJOluQZXbA8O+GtLbUVwXY6M6KB2HUc0tCBMDYn9hMLnAS6NCDq7a3Y6IIUwKGBtV/kaZVjAQR8e3IS7y3BjHuan3ZT3j2F9H15sKY/W4MuXyrevlfV9GBTmhH9WAS0nU4c7Yq2e0tqbaxDSSMauiECoemFjYyutQbtpp1Lw37SvhZbvLbRt8xdLL/pc7Pys0C11Yj+zv8QVjhHaf+xGzAQKSubhPA/H0lgeG8TOSfYge4hkX0D2CGQ/OdZGUPfzz8bzhRXjJ8tkqOjGYJg/odCHwEcKs0Jzz+GV1nT+pFAuphsFYjCErT1lmBsBsrUL9+8KH5RCZHba3AlyPID9Q7Pw/mxNefSy4Nkbc0PhUb+ZRKu7LqKH3jT6NRUkJkXLx+mZYZwB4l9rbCeRHowhf7aykwlIBzQ3ZqfVHXMh1H5fWN2DT27CB9eMi5Kp0qHP8cAsmL/Yhodr8OMb5emmsnlgnDN2Mvc8yVmPj/dhvFVtcGXLOFuqxoIIW4J8mxXZ3zpDfdXtF4VWLyddA5mfn6zL1RqLln6YhnowHPJMRL8SuK+q1xVZbvD5OKc9ImpsbQCvpLYt6SUO/6NSNKXZu+mZLOM9NnVfuYnv6XA2Y9VOIF/DtHemeXyJeOmVLS5Oul5cS7ERhCwzmvLugbm8aP+wYH1HeHrN+MmamTKCoT80AmRrH9a3lNWtgu398h4MXORRT6x1XjHNykdNaRXVBzKx2SK8/Cdsh6Qzy6j78CodJ2TQXeqBRmMeFDVmqfU9GOTK9hG82oYbC7Awa+7/ACNodg7hzR682lbe7Bmz1VClvCvEuvxAGuHv4I6qnDHJ6Wm8/jpRzL+kr3XHL3VKpKN2D/faLmDOqutEuzQCXQK0Euxu0mY8+HZ+d6xqxarDVxStpVByHdZ+5aM8u7LVCZFSUhp7gVpoxOXQzjOFHp01wnp6cft4ZBNb80NMOIVjMl6L8n2n0O+nDnUrK3LVTizuaOoeH59OZykKpVB9A3wp6H2Qj4Flj/12U1ELjeXDaiw6vTrjKkWnSK8l6lh10vJcxNw6KJlZ2zjsQ39T2dpXnq4K01PldtwMhoW5POqwrxz3DXIpFDqZkHUaH1D1oD9pW5yyvOPEaRvA9uQ1Sdqm3OYulK5gXOdj3LLvD+D1Dsz0YKqnNaoYFmbN5KA8MDjIzUDvlUgucC8UmFis/H1B11rO9rKkwp62vwFO+46aUDV40kZtd95Hgyf5SlGK31HvRr2ZpE7GSC0SKi2+U2a+8m8D4THooyzXV72j4qh7PFbGUeoeHE22BmKTiKCqFEWxXRT6raKfgPwT8ACYqhhPtWNQFRPOyemqHD9uLGs/XUdjTLVyM0/FE/XSjQWPRm7Tnjyytebq2tphbry+Hg2oL4aqJrIC44jR3Cci9U6rTkfqRd40fmy0n9HtkEaE7XfAnwEJtjqdCBRBU442Xe7MKoXIsIB+H/b7pZDNtF5XKrS8pbNMoZMJHSl3skUEQjs/En3aFrZtvE1G44v2k6qgI20TYwmABtOEEU6jHI8b9zSzUCyvsxwJ/ljjAHgCfAs8E2VPhjqeC5QEdY/7JxcgDWN6pKrPFfkBkUcqfAbc8zW/emjWWMs1eRhtzDdb+F+qcHbEig8vPetHykVI7B6GJkhkANfzup+XuPlG58wIf17lBBBdQr4ak1haCxGkXgA3aMRoc4UqWrjxO6WwkEwcz7P20FTPVjLWombrhOn1AQdqx9uqTj9Sf81d1C6sdyA/8c9Y2oHZsfxeoRHR5uKpQpvNKxUK7Iipd+fgZTm7O64w6hlfIgvj7vhp1ZKtagw08EAzD3FAUnttc43i15WlYflqRcxzbMOPOO/cuvdKXafj50PYznW923OHtoeNpuf1qTq50Mt3UydWh8D7mrwv3iK/nME406CdU+1klWEN+BrkC+C1CsVoRbadusP8ZIvoPn8i7CvyAuEh8HPgGnDCs9ARGqVEnpLako2+O6WiMKoYUb1mgjzriaw8aFiUp6sdBFUKi9rbbubGb834VOVPRz6n5j01VXxVAjajRBnqClpo6tQ3Y5xHPzpvmrg9Lnl5LpwuQX2UbVgAb4CvgW+ATa0E4Cl4PAM37BUJIG9QvgZ5gOgt4DN3ELmahr2AqtWLemuaj1Jsqe2ih1CCpzX9eoEy4sMpeRjN4s91fketGmjltlTsFFzty9+SbCOaJitP21H7WQT1WJxKWYZKqXXrKgKTS8Ehfl1byFH8mbBunzL1qKuaeNs1gZotoWItLIaTrFve+H3abt41f3Wn0DG0TbsMnubsaZ0OB4rbfna7WFqqw5/Hg+lUXtpeH3DwQqAVuwmL7cokhUBsPuqwfl5N3Qf3nAfIw0aP5ZPo5hdfw48jD7fvx8sQcx0U5mH3H3XHW0JrbxQsO12/D7T0wwhisruinas/73i17KUbZDkaeYg1plS3QJ6K8h3II0X3va5zIuqKnIGP6ppkD+Q74D4GhTxgEiH1FqX1WAikZSCeZX5JmhCBOFEqYTFGOsEkMmZeo0kiSV4CFW0MSqEHZyxH+sfIunkLxZ+k771VRPhudA3g8iLnko6Bl8CPwHNgG8jP4n6Zrp6pAGEfkR8F+Vrh/1Th1wjX67ce9Gg0akvHSjgerBdbWxBNsI+t0t6t0V2H0GZG9auxkehVnJC/SsNytqE6vDWZNRv5IijAT7cuSqhZ+WEde1QifqOVhfVX27ej2wHbUU9dj04xalgR4dzUj3qqeNCFIxKusQOL89TJP6mhWjH8MLH+V/OR0ACdNo7fjaLBvza/Xl+Iatkp7TOibfsogHHqJCyv3+dD/iPpeZq5M1KC+rPT8/u+l5ddxwFyi/DlhQ3rHO9JW94h8vDrLbYNOuA3lmeN3Nw+EO3XXty2s1BjlGFdjNnqa+A1ZjPhmVDX+MA4M8qBTeAp8Bh4BSwC47mfO0+NIzanhT/HSiOljb5tai1LpPyjyz4ZAhkdWiJ8JBpmjPwuA7Whjdhi/0XwcZZhz5wmqZNTjqmLKKc/0b8NHlJU5l1g5uG/YYTI9lnmcYZrIDUVCKsI36vId6ArAncBSaOLCCUdl0n0ayqIn4ezbuJp1YEWPzKjtAYteJqKHcdfV4jw5zyvD1O1o7NYAqEpK9xbH2p+YR37cWKHLsO68Nqw1rbNGoitrI1zb3ytTzn152lsgZYd7iLyNfpWDTWZbkSzTOYDPsqrf2uYa4iUYkgzrbX7KcZcmdTv1AsT5B2Seugimm9QJzbfXh0k4jglT+3UKkdalOdInfhrZXhh43n7X0JX6sGd4z4vThi/34XoMS2QNIJY3bhe7oeiPBPVL4HvUPbOUqydhwBBYU/he+ALjPC4DkynY1g1MULrGK/o4nxE40+k3biL/GbCGz920NnGyHyicp44fjw9d4pMCMEIF2lhbw1ta/uzAqpK5cFZcT0p1DlnjQxpkzOTU8L8EL46UXpj0Tki1zQ3bQWNT6wjEhw3wESkrfPBeVXcGGV4G/3kZOlX6ONH4EdUV4HTn9uwqHvKi+uipHCgKj8At4DPRPRnwHRtwkj5HLgAOrOsJuC91cTjp+P9Ni7bE4PF1ozGvYilzSGkk/C4NTXOaLLSk+ZXUZhDd8OiPEths2QJDKkOOGbl+Qqsyf40ZpAzMpGMlUyqne1nifSjz0b0m3FonKChfp9Wnixscao6aevKyVsvx0l/bMZOEdbj/aRZJ9MNjRdtKsC6mEOD3wAvUYZnLXe7xTlIclUGwCuUb0T4RoW/Q1ikPJ3e7hE3NVnGTCYpkw7Nl6TKOgEKcEwc8TxD7b2Fr3HCWFtrx5oTUuWs0428b1Xnx6s3jb0LyuLGKyrUUbZPpwM9aU7IV+5TmlPd5RSmQq7mDIYkFrnDumq5oc8vmQWQYuaF4NeIvF0x7Jtt1A0YTcdTtKJtGP4OTUJ+Gay+OmIyct5FTDkB30FZYrXi5RbtL9WXKo+UqLB4SJWlzRLh/Y4L7Xj9AckNAM3voDVHmqmifEWMFyPi9xF+BP4EfIOydR6grXuONwgOEF4gfInwc4RllPs0l45e0U+NxKCOYW7+sgxmpmFhBpbmYH4GZnulW3qFwwHsHRnnhLtHcHAM+dAgkUrg1HSBKPZS0yTgcQw6q6Quonkuugtc8i63Dfod6B8QfiDTw/NguHuupkRhh4yvyaRaB7mGshxoMq1S1UcraYbb7+AejWziGlBc66zfBclK9KvzIFZef/F7DGN/HFUk3sUQXIK/6NbcIE5b28XbwXhwFgo1k//CLNxehnvXzd0aN8s7x3tdgzx2DmFtD15tCs834eWWsntkhFBR4MD5trsqAu3S5ysWNqHNjrM9OJ52Vbe+QSiWTkIzR0einhg/KUQS79fxNEACVNZeJ36YCPJI5RVB/E2dpDX+1PyoMRQQie/kE03Hng+8g4l1mHQ6Qbu0DPGwTsYvA8Ie6I8i+oVQfAn6So1Cf+bUPdtdvBYpkDEg4wXCn4D7KJ8DC5zT4v0VXV5ShUE58Xc65g6ND2/A53fhwS24fQ2uL8DijLnXJC8M+tjYh9crcHMdFl7D03XY2DNeboXR94pPonRdco2y1Ml+2nSaNrrs7XtGpJhDg38F/RL0BejxeXWcLt1zqlbT21WELYRvUb4AfmXWQuQ20GndyRSsk0Q06JZ3dZhxtr4m84wyVqYbD9SmvUfzDjSYeBwn7zhLYdowYT1GEgy0G6+8bWWpHws5zYVKK/Pw+Qfwdx/BLz6EO8swNwUzU+XFTCUtzsLKAnywDB9dh1uLwuIsfP1CWS3vFq8vfWqxp49EIPb3ibRsvDChnT7F1zhae8hTGD/QS9W6OdA/5BaN6yM28cKO1qTbypCqTzvP1vobWSfW+2Drf4hWgnS89FoPCVbptfYFL4dI/0u7tUnz1ZZeXU5T/m2EL4H/Ar6SMz734dP5IZCGcmADsxPgT8BNYImzdLR4RZeWlMZbrYhZ5/joBvz9A/iH+wZ9zCU2ePc65m9xBpbLO8izzNy3cTQw6KRQoMBc+pTIfxJeLzNddv4uglIC4CRx30PqAy9BvxD0L4K+kvg9omdG57cGUpHhfaDCQ0R+C9wGPgDmU7byJhoTabzpdYmIZh9JP6WJx23FLu8aBhipvTv8jUIO7kvzTpyfY6XnhEmgqLY1mqCcbXkL9f0ZCMzNwAcr8PN78KuP4H6L8PBpugsfrjRrI3t9czPgft+kn4lBN37Z2jTe+HpCAjFYpQvXXeLp2pQOG7FtJxBSm829eaFJhBB3WS7uszYX8kEZfPTSgpDGqpOq34xTJzYa8K0AHnIYCzHZ/TlELi6fFgUoSoJQaeRhp+SO6baDolF0qAy0PHEu8FfgoaC7nDN1L1Asb6iBVvdF+QVwB5jhyqz7XlOhZoKf6hkUcf8WfHYHPrwO82MKj4qme2ax/bPbsL5vBMnRFgwGgBq39edNl16LvRpNl4Iuup+oyF4h8q0ivwf9LkO3y1WEc+XmIhezc+AF8DXC34C7KB8Dc9ETp6PWBiLvxL/sAvHleJCBY3UNdkJVXyLxAn5DNadtV5jPe23CTgdttMWWQEGettokPi+J8kaCjIWiInVQma+6mVnP+PAG3F0x6xsnoYVp+GBZuH8DXmyZu8cP+qbttWTPGTKerdwuQ6gjtmjt9uHXQOv0ubTzSoT1MooN89YzLi0afiov33mfROIH9nonV/HeRRBDlVcCRSGRrhnwacVLaO0aCdu2Q6v+rPNykUfjICHiDj/BZ5C2w4uTjRff5dN1nKpeWDd9CdpDy3UReZNn2V9zOr8HHmfoQGq/Du+HAAE4wlyp+EfMKfV5jMv3CE2uSqUX5SMvUh38tHRSDXCSeBeqZZ4gs8hk1usaBHL7GlybNyfKT8SNmDMjd67B9QVhumeGXHU74LlRi7mwjZI8nXkbtpQ+kVdauRqTWhSONkrXiWd6GjvvE5ShtU5OQ14KLaa7sfIcEbYUITsq8kMunb8MpfO1IptjHj8+NZ3XHqw2egP8SUVvqfIA4QMQz1uv1JpBVRGVthTqQw1p8NyGNq6tV5x3qfhtlFAlT0oxF+1VNiOyiAG4s6GmHSYtZ62ZlRN7JzML6Mvz5vM0Pq3mp81OrsXyzEi1M2Wy9ntHaVThxugv7wNdbDHH71nnzZN6glPQfZSHIvqFIt8Ukq0WZIVBH+c/Ei5WgBgNo3K0eAfhV8ADhA/rMOrZWdrqINjymgocphcc8GrlO/E98sAxtflmihomh3ymTUQN5o+ZK6o49Ts/kK/B+G5wQzYJAsTybHmh5YSOlv6tAMnMZD/ddbfqnoSmOmU6HaWTKS1Vbv1uppxRnmyrMthh3XZpzFkx01Ms/7aDYQG19PmUsS1m3qrfBXmFjkEC05U3PuxnrWVI1UnMxJZoh5iJttWjcBg8mm78WVijKcU0ml5y27Ib1qmTAFWEPCTNcJ4vO0VfAX9A9b9F9amoMV1dGAK5kFxcKoAdkB8E+QvIA2BB0WttkU5SHSl36oZOIp3PRqK/MwriGSkw1eCp/V+dsgLqtKy0LyPqOGkxT1M9l71vnYi/MYTFWeb5turwBHweFcgThD8q8ldBNzqakyHvswAxw12U10L2F1TuKHpDhX9UyCpNT4LtdaHRydUuLW3Kltrqpufe1BcuSdnxI6p+qCuk7uqwovt82mijUYR8TdeKnEAMUi+Gpm+Ca85m+fsxbHRRPtWKvxKlSFPi9O2PDfl1WYNJUfLCHPw76AtHA7Mr66ST/vHALJwfDsotwlWGQoBGxnNaGJYh1Cjt9nHNob42G+tbScQQWUD1NXFHy/XU5GChXS1raIBEqjA2qohr0G1145YTpyHTWnbzbVQYh++yumu0UldROBZHrS1o5Kn6dY1a480aD4Tld3j284p17mCNR6ywcScqQfqqZX3IQEWeK9nXCn9T4bFocdi5YPHX1XP0phinelQcCPI9KtcV/bQQvQ+yIol55WRcnjUCeXvUVv5x3p20tO0obgwqow9z2D2EzX3jomRp9uRM7fdNOjuHRigVXMwWXjhP7TQ2PZ02pYuhSfKbiLexTHlnnOdlp0qgClsF2ZeK/BnVR8C+oN5O1POnt+mTyrh8hy8V+SvwicIvBUpTVqkxJ7UKCTU/775ysLSxYK2iTiVIO7w/XAJNwL9z3E83lklsDSTQRBOoxc3bj2sLCq/CfNSCRLSjSGVg6rFCbogbNqqNBdugtXbPPijMpP9yS7l3HW4sCjPjXXTs0DA3J9BfbCvr+8rx0OJPbB58jc5y8RHoomEZAhfeMZv5KITpxKu0TS9vVat/+KjbQwd2n08hh9j8EfSXdBmi5fSfBAhn/PqLatnRw3z+uyrvMP1Kg2+4SdS1nXZkDJmP0BXMOIg1iW4jhyJTt0qOvHlSSkuKyFCFh4XIb0H+RMGrSnBclOmqom43uyjdrSLFNFNGRnaM8jIT+XMOdwt0DmVWYeoyag3nytMIbfzECMQ3ZY3DgxXW3w03DtkhMzHuR4aFmfifrJstuLevwZ2lqCWslbaP4NkmPFqH1V3oD00ameeSJ2UmcShS3lF00j4wOl4kRIy/UfU1Tn2eMfg+tzqJmoHcyGc2Ji+7QaISUAUDFXlRZNmfNZP/Bn4QOKyCndpiMCF1Z7sTHgc+NVUCxKiMomyp8JecYnZQFMsDLa4Xqvea8NUMGNf4nTD1T8Uy4lv52hNiRNvx7D3OxTFVLF+LTd21Kk1CzdZhT0N30EDK2KS13V38sljrJb7eHaKBKmRYN74Tu9iBwHANpInja1B23llmYG6hsHkAj9fMVt6bSzDTg+U5xqb9Y+XZpvDta+XhG2VtzyCbTgaZNKs1dnljCK5th1VwZ3nicJqbnld/1q9R7WGnGSIPscKqFzbOr5MnLkVRdwqVWX0g6RDSD4tGypvS4pXAuuCPBbWeJZES9VhL1Yn3tDVPdfqCh3ZqlBciriC9AHmEyN/vP1W4gJ+y/VVFGcqLvMj+u+jKbzWTryTTjbLR3wp1Z7onsCOcBdVtIoUIT4da9JD8gzzXe7nqgsLS+LLUU0sig3w0KxI8mSSNKE8tGq5OmG6au6jICd61wfC2TP1F9ElJpLwgqjAOEN/swg9vjBDpdODTm+Y8RzcjikZUDXo5OIanm/DVS+W718rLbbMWkonQ64yLZBKlb6vciSguSMbLe5wCjMHcGGWZpIgXMy/5ilUbhWN8ouRH1En65sN2mqyeJqzVUt8jZ7sYytfFIPs3VfkzPVbJOI9LZcembucC3PFGSUw1mutJpdCCpx0pfi9wS9B5hX8AmasCV3pzRe2o3lO1TjgK2ibq8xpYdfeteQ9Ll8q7TSg1wyLd23wte9wprS3PSoHKMqAwO6eebUC3oxwOYPdQuLdSHgycwVkX6Q/NTYSbB2bt5LtV5ZtX8Ghd2T0yF1N1K+HhaWHjWH1aBXEIwsYmjX73UMUI3uKM2amZlqyO9cRcobfxNUmYAH2dovNHL1pKJTvhxDiWA0fv1WSKVYjsApcjZzP1RJQPPUB5TC5/YMh/0eEhykE9AN8WArnwTVgOaTmgFFSPVfU70CWMu/cVFfk5EC4aA23mqdCkRbOwXpttQl6CBff6IzSDjFR5VYOwvlnFnfO8nhe9Ez0Gzf2BI9a/dge36sYzW/j1ZbNZT3he0ADeO3ypFd98ZmJcs+eY3VM/rCp7x7B9CJ/egg9XhJsLxk3JVLlmsnNkbiR8vqn8uK48XDWL5ztHJt2pbimYSoiPRNpVwjvRgzq3JoaYN1W/ikJt1Y9hTTQBP+5PtRbRQzNNOGGF+VXbsyNTYaKv+6eZnViRNnRDxtINemiQbtzNkK+peHlKWPZwMT5WO5G+6WUZCNzIfNDmz8sdlwRlCFvD+ua3s9MPvTEuCmgf4TnCn+jw33T5hk55x7n99xao23aF40VSycU68FcVuaHIh0g2B3pHTrtb7C1CvEtHb6kuBGOyQg2y2Dk0twoel/d6PNtUrs+V5qxOcyPh+j682oVXW2bRfP/YDMBexwiPsUxXZ6A5V3Q5RstPg67qGiNEM9nSjnxRZNm/q8hfdSgbdIEeaMdIWT2pc7lT0uW6WlY1B3mlwl+V7A4i0wL/F6p3Km3dXrRq5oWEFqG24u1p0kEqkfhNMmGY5M2BbQ3pmi/cVx6qiCbXrs7aiCa8D6R83paev1FBYxqkqyXaB7oCT6IRk4KgRkCoOcPxelfZPoKnGzDbg6kp42ixUDjO4bBv1joO+uU1tpnQEVt4pDS+hqoQQd14bWb6Vxx5+KgglpevsTrtIX6eLfwGGqrHTPnVfR9KyfTW2bAMMTQR49eE9VFLLOUUDw2fdV22Imo3WtAO0YHSInpGIBhNfHciWx8phNV+INNHZ96Asd4q7KnI93mn819FJ/sNUzzRorQiZMSa/UKp+5ZWQGqq0Jc234cgz1TktyIyj+ptjFlr9gpKXCydR58UKe8xVyMk+kOzuL59WLZ/KRgUI+xzS4h1K9QBV13hEtIVYjgr0krTPQZ5qCK/V5H/1q78iHDkS7m2qy7Om96GN94oedrWJvAFqnOifCTKkgofIzLjxAnqTeLPlWbCGQMptN3jkboHJI4qPL5awoQ2aO95JL1Qm4rFbynLGHmmkIdz62BgR3fTqXX/sh2kzLISGBTGZAUeQhTzWzKzhtLEDe9saEMD6TsqQjt/LL4dNqqhRpBWGKaKX/XRNC4I6i2CGoOtyNbrFBqLram02/ntZ/ZNh+K9iadl8xdOcmLVm4tc0ygyLK/TP1PIzSnLiL7agriaNMR65/HVglgtTkPebT6bKM9V+Y3CvwBfAbsBSHnLilS3/3ZX0WsEkqsyhGpPWoERIt8Av1GRa2ruDvnorTH6E6RxesZJek8VJxPoZQZZ2M4RAddakzKJnRN/PxW6qpvLSlogbKN8hfIbVP+M8galcW99Sai7r8XoUOdMUpozcoS8cppoHA2+VPgNyJyiNxCWVVlo5pYE4oisayTXBGIPA3tmKObD3TqRMIk8iWgwfvy0Q0dC3mP3upeBAueCrTcKVuEsLS0Rfixttm0Xkd9EQTZaK6nBobSIhh9qlL7ma901l7gzuzKlunl4WnakDG1rDSNdmUT4SGmzYvHermVX6fmac4TfRHewy9/ESyAPO4O6TjzEVfMZqaU25DHilsHYOG5Pr+In3gdiO9T8uNW7mMIT1r091ke3HYBmsgl8ifJbhT+J8gzj+unSUfewePsCpCLToc2qTFmnx4j8oMbd+4egt0B/Dbyl049XdFYUG0RteoAT9pzobSh2F4GmkvHGMH9cImV3JL1LvLbQUDvyuMiy/wB+i+oTRI40E+tU+uWhbv62ObDIs1RUdKjIDyryG9CbUCwIfBbqEE3M6E6jlFbS5pa8FXn4zJZ5a+xdIm4kUIA8YvZ0jz+NPPNJJeLNKqVlRyCB71MrZjP2tUxX+0zZiKvH9nuvJ7Tt+qn58dLXsG6CXVIt2qtfJv/AWDRMpAz+GlSrrd1DWK0XZSU0cVE7Dw8xaCKuRX6djHVNgZNQCrFFkFeqL1iBwn7i/nbCpdBJm+uRoE6szP086+dWWTygoX7mPo8J3sVEHiLyUrPsi2Kq8595ln0h6CYK2sne2lbdNupeNpYS/GyC/FVhSURWUF0GVtLBL5JSAuVyUNT00vLM0Ggz11lTTBlo490KNtnzljzH0mDbBHorE6fXj8dJobV9To04Eua31jrRIMxIHlrCnqbNotxPVCejhWDMFDsWjwqi+kaFv2gmv8l7nS/yXuclkFeedmtvzJcIal06AZKgIfAc+CNwR+AW8GvgJjTah32o9/2hs52ETtsBL1HfPbvBdOJ0Qjv3WdJYAtQLrdUe6IlzeVdHjj29t5eh1vQvHSkC+6h+i/LvwO/I5EWRZTkZSG7KKJTw8m2fvbDoch0kbKdDgUcCv8OcCwH4J0QWbYtHVdU1BXA9NA1VlNry2gbjG1OF/zzyLoyc5G8c1w9tpraK4hsA/DzdsOOYnOo4EfbG2qrqmwx8050Vv03rTG4tHWOx2klPRpQ7ZM8qi5+X3b6eSSeoe9u84j+J8JBoaseMlmzf+HPzzhUkbSadsE7C0kzilyoMG0kvxUMU/bgljIfx80731TCsRUl+RteJxdaxGrfsvwX+DdWvUT2UMnCNxSfTKC6Euhd9g9WJydTmjqh+I6pThTBVIIvA58DiZdQsLmPNXkaefvJ0GTvvJaD3oa+OKoMKxwXZDyL8p6j+u8DXwC4K1gLfpaXu2zzFOC4pUmuYgqyqyJ8KYTonW0Agg1+I6pxB74nypMrZajNuW0BsX/tQGo1DvEBt6CJESpoOE+UvjnrU+hLfsthoYW2HqaJath/fz9Phr6obT0us30f0yJTma5dlJGKyWsxza1M5NIyXO12WYEtom/YZvKl4oakTP/02HoK2q8pk2XGDevPbt7qXBwspxRGTk1eb1j4Csbo8u5+Mk7dXBmccjkBwcT7d9Gwcm3RPEkkw2PYd4cXv44oUhciTIsv+A5X/lan+IUPXx7r87ZJQN/evcruE1AgQRUWGIK+HyF8LyWYEupkWM6CfAhd9O9Y7R+9Q37yiK3oPqR6BQ83kWSHZ7/Os889S6H+LyAv0EhzMm4C6/c67dqTCNEABzxXJu1r0hGJWkC7ogwKmEHE0CSd2sE+RRnOptZAxNH3vnXpB7RhVnlW6QqjhiJ9AE7nWUp1nNNqXTGIzjokQv3hR+7erfrW5BE8dKHTSCfK269FHO266rW66g3SbBwEa8OPYfSGIHrFc13uaPSRi85zKK7hr3mE1SkKkDtoQEvGw8XUmtwyx9YTwUGCEw3rgJVQViSAiL71oeyTa1zoemk7HolFrM/5hQTtsLE7y9sdo+mq2WauimbwsJPtNnnX+HxX5HaLPgPxdQh8A3eGF34l+NqTQF3hCwe9FZU7QrkIHeID5nDS9KzpvuvzW0vHpfSrLWdFVnYxBmgPrivy5kOyfVbL/UuGxwOBdEx4A3fPa13/m5CmAtalXeILwb2KeTSNMA3cVzcDXKCyy7dcJ5NEgh0aD8y9YCuzqZVhx8i7fSajN1QqbpxmJpc35h9hqviLpReysDl+xXUT1b8+Oa5chvAO+BfV4YaNaXRR5uDw06bWUoaoTN6iVXgsq8OKgET58W3uk/sKwkTIk3IDEEbD7W4OaDXkIIXfkQrOg7mNlcfuNEyaFACepE4nix3hcJ36830j0nddXrQyT42MMFyt+K0gkjL/+VHFX765WeaMqv1fN/h9F/hP4ETgKMn9HqPvOSb2g7+oh8C1oB2EBYQbVDLhDm050CsE5TpW1hYm+CyYA7/kp8zyPeA6FMuJtcHE6aplY2+PFQ2kizVE0aoI9afyTxZqkAFYaiWgT8TZG1qcdi2HY8UNPli4KsqfwBcj/D5V/Q/kBOJggmUtH79I5kDbKER4i/CvmmE0XpQfcSEcptQhn4kvbssFouyrEO3a1k8d56AY8hWxwJiM/XntHjuV6isk6aV+OaMm+NhbRBCN6biTMBGVICeKR5HJ0+knYb/sQPflRRuWZTj2mJUcCt2YwusSThfA4tHbxBexMJGTDMeVhuoCbKFc+E9G1m/aRpsETkuNDYUPhbwL/gvLvCN8CuwHT7xi9+wKkaakDRP8GgMicFDKr8A/AcvnMhApMRc2/obmhChtOKlJvBfV6ovipxmF39aWxOFRmKS8ve8R5/TnGl29yaSYuseJ5fPmmCcck4ZoDUouGaJNeaDZs0vXXVpMeSi1GxjKrBHWjTYJlm4RmGo+/SDpE68TLOx7DzdMXUC3QP+UJGNusSbzenL4m7tvxDrn5E38kdKLO3XTSZQjrxItrs53YbNB6UDRSBj9e6retmgR8Jk1asXdOnCOFr1H+N8q/At8COxHW3zl69wWIS4cI3wDzIkwhZBghshR2tHa0YZM1B6UpcO8+IZ2zqWpCuH0qSqKLU5gNJ6ZTNodP51bnF1knJ6Azqr7WtEdWwSWvoxG0DfwA/Afwr8DfgI23ytEZ0vslQBRE2AX+hKCIdIAp4NeozJdBDEUO3IWXpjWzUGVCqhfaKwVXUpEjWp2jNUk0rJV5UygqzUiiYUNgHeY9ySJ6XLPyNL5gAd8yNPmIJpJHkGcNGCot2zZOpLX2EIH42raFvAK0E6JGv3xt2z6jWn8sfSBYyI6k14QtwwR10sT00ZSNbkMk6NWJBW+DfpJCchavgQZulT/ky0vfjhn0LZsHK4xd5+rVn8Vc0k1MAik2ednJhAgp3r5xNObVzRHwLci/Ym4V/AJYj7DxztL7JUAa2kb4m8KCKvMi9CTjF8AsSn373but2FwOOk8N9TLlednpIhHmRdLYKKUl7lmHHYsZ4RB4jPB7lH8B/gq8wdwp+N7Q+ylABLRgXQv+WKh0gEwyeiL8XEXKk5NqCRFPcxSspwZ1aBkgQBzR7Zm+DdbVsOy3jn3bSs++w6B+lkAeUS0xofHa3DZl8YZPq5ZdPbfRmY9u4vw69TcOuqjz9rXuIGiTXoAYLH000BKr9lCqmkpua3fWAnw+fGRjfSaQUXzCSpVzdBmiLmBScaJIzuUv3ke99Fpu3fPjtju39FFyg2gVV9sLEUN4kDBEwiHvqTULIVL/sXbwy1DHUYCBduRH4Dco/yLw3xS85j0THvC+CpCGXhU5fxwMmNFC5jtdzbpTfNLpMQMkD8te0fh0VYWXg67aIaST1MlYcdqkKxyR8RThd8A/A39CeQlcprv7zozeWwEiYsyZRcHLoz35/fGBdHpT9BdukPdm9GcI0/kQVCWyfOFr0On1DT9OHN566x3279R6hr1Gk7BLtx8CjaMKW0tL7QTSxHc776a4Mbu3p4XaiCaloXp8xnhP/m5JJ6Yp+ujEbY+4ptzESyOl2OafJOIItPgwvdb29bXiCV1w1CE1zl8sTvrZ+OgnvgbnlqFK0+77qfWNJrlwnaitL6W2VUfRCn4Yq9TVCUHjnmSAyEPN+B0i/wv0v0R5jr6fwgPeYwGCUF2vnvcPeXqwJTo1y3B2SbOsQ4HweT6UuUuvub3FhZqzrptxvB7YeV6tURk61zp5Ryv5Eo7bQ+ARwn8i8i/Ab4CHvIdmK5veXwFikRYMhwOednqlxiUcINJH5BcoiyntMI48PDSRQiLWVx9VuL0/sV4whp0/GlZ9LdvnIZyO2hzzpXY3NW7Afe6CZSGiu7Fw30UnhHHqpMW2Hj73tFqvDE41ToD6xmo7r07GQVHx9QIvdNI5ZYgu/AOZaq/r+EjEqxNFw7aPrF+l+12kMHXibmYasS37/SXsq1ac1vZw+4sftM3Ni91vGtYVlD3gGzUXQv0z5ubUJ7znwgN+IgIEgaxDLhlPJaMP7GOuyc2BX1AdNrxAfkZRdPIYJ2yFqCdmajJ+XDNXwiwVjE7SZT/phJpIbpKw1dtJ662tTpJhUiatU+eZnsT9587niL6ojN+fThom5WF4HIqX3zcZp/Nv61sj8zXZHCJ8rWab7r8CfwBeYOaX955+EgKkXA9BhBzTuIrRDo4wwuQfMPesv/PkD4jTWChOP2lcvKHh/HO09+lMQidpkbdv0GsTipO1/Un5H7/e0vycfa8oU1wDvgP+HYM8/gI8PZcMLyn9JARIhF6D/sZATznACJN/QLiNtRo33iJ6iwmhfuabvdKDYayDa967toW/MJ22w14xHuJaYWxbZlrbjizwJsrZrqFWYUO9M4l6Its8G/tMpAwJ04hGDp4GGxPazB9B+hEzTWuduBNp+jbEWDuGpqs6XGJ+DsskQf1HBcmIOglrfNw+nzJdVb8l0vZh2KDeUjyggSnbHjdqzpp9gREc/4byV8whwZ+M8ICfrgApgC2MxoBAocIhyD9hvPi+a7dsAWdnZnif6DQmqctGl52/SUHGWZTn4tpXrS/6EpGvMGarf8a4J1k7VfLvKP1UBYghYVdUvxCRQ0T2FQbAPyncJ1E3AfJIafwwHvLwNbYgH0snSmlfsYXkwCGkq/k74QMerJRGIIX29CLaXjK+rWH6Gl+Er+Cd/zyCUiJ1mkxjnDpJhYmUwd+wEEcr/jsbCVcHXxMIzoqSMjFF3W0kJv14nSSQhzTvm3de+VvbI/7bSSdwguiHI4o4TFibl/a2j25td3l/pcLvVfRfgf8Qla+BzTDST4N+2gLE0DZGg1DICqCPFDnwEWoOHL7LdNZa66XXgj161/gdRe9beU5LF1gffURWgT8g+r8x6x7fYuaPnyxdCRBDx6h8h3CMcCDIMfB/qfC5KtNAuLU30MzTOz/EepfS+to08rRGGbPPe6EjCCJMb4RW6/Dl/h5Lax/HPh9zRhnVGROoJ1GGcbbdjlPu6Ls6jM+nlUFCaw/1cbsdqzqJxB2BGFy+UvxaDwN0J06Y8dZq7NK4iCGGkEam14a6J1l38soQq78AefiuicxHoWRPRfitwr8o8hvQ73kP7vM4LV0JkIb2QL4GhggF6AClAD4D5t4ybyem9xmBXCZeLgtNVCcTrln8ROmo0OypSva7DP4Xov8F8iOq7+w1tGdJVwLEpQJ4hBmH+4ocKhwj+ksRFgBLT4uPPnudQ/A0yFbkkdDY1Io3Yv1ACLUv++yiNo+jh8gsxkdqjoH9G0vTa10XSqWbtpEHCKQl3fEOZMbDCu2acxsSinPYUhYf0fqM+HwFKbthA9TXxmdrnXjlb0WP6fgjeYil05Juai0uWjetl5Ql+LHaV8o0FA6LovNdoZ3/UpF/E+G3Ivkj4DjG4k+RrgRISH3goSqHCkOFgRjB8itgHnNl7oXRxSAIaX17RRdFV/X/9kkrnW0X+EGR/yw0+98g/62qz8TMB1ctVdKVAIlTDjzDzKzHmIvvt0F+CXxEqK9QOVWLKpaqkYf1y1ZGnLUU78skqbZpY+Pl7dnIg+dhvIAvYaSsaltraI3q10mQebQm21iJUnvYNId+/Qf9pCXhceqkjdJ1MiGNjD/Z1HqyOon3Qxt7TV4n6rxReAX6DchvMDcJ/hkzH7y3ThFPSlcCpJX0hSCHguwJbCmyh+lE9xXtAO7EJZ7ciG1jxe+u4TMYYe7y03MW6T0ThLrpqcsgThnGWhiPPw/i2XE8E1y0DN6W1Wh6sZmhxXtu7Lmdjm8+jMUPfkv4NKy3ZiJNTaeBkUuI3Bcf5yWWTts24zCsRaMW+ZV0H4hyNmIRPfHMPE+bz1JpODFG9NVY3l4/HCq8VHP5038A/wZ8idmmeyU8InQlQNopxxwQ+itwhLArwobCP6HyKbDiR2jTjs+bRk00tn44FkvnyfclWsBNY5OE0DpBumPRCIExTnpvxbQyQR1NxJ/VYZOK1hjZB3lGlTPZVpHHheifQX8D/FGULzEHjq8oQVcCZASVnW9L4EsRNhF5Cawq/L+BX6OlDy019isz4Xgmknol29KXynCpO8ujKCBY4LRhvKdLRe66CNCCeHkGC5WWrqmuZmkzl9Lko6jH09rx0o2ZJPz7xPG3RTs8u7Gb9mhBaQF3Kd4h7kbFtbk4qMC3y/jtomKeWUbRBolE0MGIA6JuLxDnox1xpdshCOP1VXsjRIA6fQTs5Rrlz35fvxPn00FuLhOROrGo7gpq/ldAZFtF/qaS/UaF/1CKPwnF60zZrXJ8K4L5HaArATI+7QPfI+xhfP8fomwh/B1wFzW7tMaicTS2MWzjF0ojeW43bJw83TDsZamSM6GoWa4lrN8vLgGSu3SoZ4w6KXk+VHgNfKvI71Tkv1T4M8jT96uTnR9dCZDJ6TXG5cm6Gs+br4D/icivgAVRjRzwq7QlG4EIjsZWpe5rqJE1gdQdHTaltEVbmwq3B3uapR0Wjy+rTH4YAseDvrYY0dojGrR/33erU0bf3h9DPfU7r24i8UKzh1casZCXuvU2ThkcFBBo4LF6rO4yierwbr1G1pzcPCV4pm4uTRgR643HV9SFjsvPaRwvomK1r19uf3yE/dBxp2KNozLpA+AH4Pcq/A7hT2p+/yR9Wp2UrgTI5KQo6xgXBtsI+8AeyjHmbpFrClOtKbzLCCTJzwUikMtSJxNQkuVJEUjq2ftUJ+PQOAgknsFAYauQ7AdE/yiq/wr8CXP+6/A0LP0U6UqAnJyGwGMMGllDeK3w/wL5R8zp9U64ruFr5mnk4Wp77rMmjpeG9St0pR5DAX6ccOT52npw77mtieOSemssLu9xzdTlIVUnYXqpdNvRlJ2eROMF6wVOeT0E6NW5WFq7X7d1qmrxmEAMatuu1K83FxVI9B1OnHZ3+AEMsOK190M3nThisGOGSDqUCmm3623o0V37qblSHSI8Vcn+qpL9Foo/Al+K8hLoX611TE5XAuR0NMRcXbmB2eq3qbCr5jDixxgXKNbBQ9cEM1ZnDa02J6JJok7MF9QmuYkza8k/qWSeUZ1MQifJpjGdXACdExK5kOr1BefZp1ug7GMUvj+ryH+oyG8g+0G02LoSGyenKwFyNrSn8A3mhsNtEdaA/6nwS4QPtLxEuZpQKqUz1m2jdmrv03/u2XbLJ65GrZ5SpnasQBg0X0INP+Sl+R5f12ijtEYpAe9BXMI6SNWV884rQ6xOggOSQbk1UieeZh6m0uQdYbAOHcnL7w9+O9dlEA3OrUbrpOYjjlhtXmL15Dxw+Irh4bDO3TDihLErp+63AYry8tAwL1AQoUBWEb6Vgt8h/A5ztuMhZmPMFZ2CrgTI2dEB8L0YJLKK8AaDRv4B+ECVGSR1IwW0q5Ch6WZ8atGugvQm0cQ8k481x40lOEamHBeQ9q/Ta/iRyC0T3ag37SHjAikWIp5Dex84uzpJU+rO8na+/VAnzXsExcs8UFhTyf4E/CeZ/hvoF5izHYNTMXRFwJUAOWsaYHZlHWMW5LYwu7b+D+AT4I7RchtNNeWUsaK3Ca7fDWB/hlxelLnpis6eHOQjYHZTPQW+Bn4L/B74CnPt7BWdEV0JkPOhTeALRFZRniH6CuX/Bv4O+ADoBdOeuF/G2SKZ0gjNsxY9Nlj0jYSx03fCugYNkTD8eDfNJUxOzkKqp8PH+PXrpE2zT5XXqY9Ivcf4JDTXNDzZC9oJc17bYrCfV5tgC7Z9N8bRVJ2o9U+48Bwvv5NOoh+2mg3b0vP6lNrracl0ojZAUPrAK5RvgT8Af0D4K0aY/OTv7zhruhIg50f7wI/l5z5G83kh8HPMlbm3qe4ZOWPN110bOF+67CjlIvm77HXh07vGb4pKWXikKqsoTxC+waxz/BWzNvmcK19W50JXAuT86Q3Gm+dL4BtR/j5D/gfwj4XwWS661L4tNfJuxP3QsXcxzS28tzrCg68lRhYzU1rmJM4Zo6tDqUXglhvwglQiCMnfbhtDHqHWnkASsbCRbbJ+2HG2JMedR3r8eMihLf5IFx+49XYe6UX7YbBVnIBSfb98ua+FPFLlL8AfyfiLiD7CbGbZ5kp4nBtdCZDzJ6Xc4gu8yuBVT1kFVgfwOhc+y+EmsJwlDU+TZ3iFQAxdIZDLQ1W/PDHgVqh3aIkowraqrKM80kK+0oI/SMZfUP0OYedMmL6iVroSIBdEZbffzpRvp5TtDB4qfH2s8n8Uov8gor9SuKuet7zYGkOdZssaRvoWuhbnh0G6Nhpw90aNt0YT5zuWV9vup9DJo72l1eMjWBOJ6bxpe38KsUXvnR+5/qLWM/HCpveaJV3M2OkEbnLsXL2UAzcqYaoTIcwUMozw7F41YKcXacMWdGeueWoyU/Q1yDcUfKGF/FVzvsOc83gN7IUpXdF50JUAuWASOOgqP3bgaR+eoTxX5XUmbGZmfeReAQsK0zC5VnulBV/RWdJZ9ScbFZ8UgWiHPiJ7wCqqX1PwB1X5I4X8DeUlUt5TfrWb7sLoSoC8BRLzV7lCORLlTbfgxx78SuEfc+GXQ+HTQphRlMwaefa6REzzDQb8idYs0usQY+16CjRUK9AY91Un0xkjr+Z5BF3UPMTTiIVJad8xvtrCBGiixSV9gH7q3zK6/idYk7L7kk/xdY1E27XWSay82l4WCwwZi5WiwqF25alOydcIX8lAv5AjvkV5gvI6UtwrugC6EiBvgRRzyXrZ41c7sNFVnvTgezU7RtZyYV+FT7RgUZUpsY6MpEbKOCNoTAcqJ0r94kbwaXOKx29P9SR5tqnCk6cXNziePIXzpdBE527OHcGLghprax9lG+GxduSLYjb7HRl/zg6KH+RYN0R1qGezdHhFJ6ArAfL2SYFBBqsZ7CvsZ/Aa4bHCr4HPUf0E4Q4q7pxUj0htTATVGYTEkIpp5P5Qj5kaUuaHsUZum4bq+fSIHawclYcpe2VZlzrLUZp4VUcOT96SQludNPlPbpyJtUONmjxYEStHKic7rF/OSeokxmeq7V0s5a31jOC3eumYuCr3KsqaijxB+RblbwhfkfEtHR6TXZ3puAx0JUAuCZWDZx/4Ts29zA8L4Rvt8k8F/J8CvxLlA2AKtRw0RhZugcCzaXT7Y2pr5RjbMltNT5FvSWpZRE+l45ic1DPFBN5zx+BTaeUjyV9gPqpMPDEhOL7pzr8pMsJx2jyl7u9oOtE6cftNY54K80zdtW7eeSIjuhHAS897rB2OEVZV+VaVP4rKH6Tgb6I8F2VfzdUJV3QJ6EqAXCIqtbA+yoYoW0WHjf4M68UULzLlYe+IX3QG3M2G3AJuEDvR/hOi8YTYOdElXai1ZWHs3bnmfcI6UUCUIcoGXVZ1Wl7QlUc65CuO9UuUb4CnKEUNVX7KHf8S0ZUAuWQkGKVPCgrt8PJ4gb3BgjzMcv4yu8Ovp/f4heT8Ugo+V3igGfPVlGFMFJWmO77FPO1mI7L4HdNwvXTGud+9QTtpk1UqHeezRg7VFlVP07fT98xlfhlEw/hJZGLdxFglFHXpEfDj5hnx4RSxP1rtm3A1EuXLyzPKQ2CyiqfvxPd4b7YHW0aylCkstsFAdYeC16L8oCLf6Ez2pc5kP+ixPskGxRpa7IIUEZau6C3TlQC5rKSgQj6cYqs/x1ZnyOupQ1ZVeIrZvfUz4OcgH4IuK6wILI6R7Pkoz5dEIz+JYnpqZfbCyn4yTtvNZSdK8ixoD+NsdA2znf0JyvcI32lPvtcpeU7B7mXpV1cUpysBctlJjMaowiHGt9YG8D3ILeAThJ8p8nPQXyj6icItIjqsrQGGtufK/l39suzgCbcpMdcjqbsu4mjFXaZu56+KY4f1bOwJ5BDdkhzwqektpcHzmC0/tu7k16kfx8pIylS89QP/vnL3u9TR/TBBOf3n9u/ghkM3rsNzUBYXMTmL9F79WWkUGPc+T4HvMO59vgOeYQ4BbgGbKuaGwCu63HQlQC45SQFZbv7EeBp9U/79YP7kB9DHagbgLxUeYITIArAgypQ95xTlp7en8gwYPZtk3oZp+11BICffgt1C/naz86EhBnHsYvruY+B7jHv1bzCK0TrmJk/Di7XP/YouL10JkHeXCozGdoAxA3yrKh+pQSWfIHwuyieKfijKglTTj4jRDkut15Brw2/TKINJLHJHePshPB8ppNYPYndxu6gjGu9EjvkEH7EEc5eVdVgnCTQVLYPLg3P7Xh00gQosPoMcTujepY6TrDebPxf1+Og0qBsFVTkEfSnCj4g+FOEHRX4EnmMOAK7Cld+qd5WuBMi7T7sY7e6RwpeKfAB8Cvp3mvErFX4p5g6SGygzKNNU97RfjPZ5+SlmbjmDOhkriRYB91aobcvvCMbq5XPhGPRIkW0t5KnCw0z0K+noV4h8B7xE2cV4yf2p9753mq4EyPtBihmM28AeBZt0eF10+W44JV8UHR4IfNoZcD8bcE9ybovS1XK9wZcj9ZzhbKoJkUcVJ440LOXaOtdQh03s0hnHFbqty/trMuKFdfOIr/UEQSXMW1Qb05/PcxUmgtKCdaaaP1tqxdFSU5/VQdHYGotfhmYtxX/Xjjzi/ELE+WZiXQdhqOiGCC+Ax1rI4yLPvlfVp3SKF50Oz0FXQa6uk31P6EqAvGckkKOsqrKZd/i+P8MX+TT3BPn51CG/7im/yHL9WAruasYSQldFOxhU4hi2ID4R22FiBh9fkLRTmwIaT6BtLeAk6wR1GZRw8Vedj+C7CZswe1kJJfmaCIFoUug1HESERDK9MeCFrWGEvOZAjnCEQcHrwFNEvwX+psrXRS6PVWVTRAdGcOjVdtz3iK4EyPtJCvTJ6BdddvIebzJlVbs8k4yvM7P190PgA4TrCteBFVWuU3oBNodRjNZrS5XYKet2Nqxf9mR0CSk+/ZbvHFhmxyAQNsR/noqv08Vss0udKPc+ZrfUBkZorJZ/rzG+3J5iFsafUbB3ZaR6f+lKgLzPpPXfLsoxymtR+auY8yJ3BH1QiN5Xs3PrAcjHwB2FZWCqSsQxU0UXV/13JaUW02PvggVpqxipw32xtIOtqhE+g00DzXstv9TmqNocFLDVskXXMgt5gie2NTeglgX9cIHdE2LENjW01Z9vWvMD2dhGBsAO6CvgmYo+Ah4j8gjkBapvMILloPzrX2aF4YpOT1cC5D0n0fqvX24D3hZ4pWYr5WPgLmDQiBEk9wTuoXIT1SUVloBrQC9MPaXhppg5bWmuaBSdqbIvDBTZBXbUrK+tY1DGE+AFBm08w1zXvIYRGlf0E6IrAfLTpT5mEtjETAjzIlxDua0qD1B9AHJfRD9S4SMyPlBYRIyT7dhNeDUlbsCzw/vIoU2TDreu2nm5T6Nox39mufuwRaBE+AsPwkUWyDV8V0WO3vVepusilJYyRBBXqk6cNFu2SAfxQj53VOS1wgsVeQI8RfWJqD5TeIVBGvvl3wFX947/JOlKgPy0KccsftpXgM4L3EHlI9D7Ch8hPFDzd0vMduA5YB6YpTR1jaX5XiGQC6W2NvHe9YEj4ADRPcy5jJcgz1TkaSVARPUZV+c2rsiiKwFyRT7tY0xbmyhPEJZU5HqRcVeFDzLlAaL3BLkH3FJhRWERdLbRjqXcnOppvtYieqP5+tqxJWUSjghb11IiycTWaHzt30dCqS21UWQTuHtxNhq38jnWffE2JdeOXHOinXesLAqI0FfYQtlCdU2E14g+RfQ5Ks8QXUVkHYM2tjGCYxjh6op+onQlQK4oRjnGtLUJoEJXRZZUuKnoxyLcBz7GHFq8BXpdYQWzOD8NTKlBJlOYPtaBM7bPn4IuCx/nTWU5C2BQ/vVB++ZT9tXsolrFrF+8Bn2O6I8i+gx4reiuwPFPpb6uaHK6EiBXNA4NMZPNdvn5GORL4BrCCugKygrICrCscEPhusINhGvAEjCHNgvxodv1+g2uU4wI8nDWIcR754dttHEbIcXixPlpe96OVkDDd5HDhuG7sAxewlb9lS/t9Q7zf4GyD+yBbCK6KegbREvFQLdUZI2qXZVtGu+4WxiBc0VX1EpXAuSKJqEcM8FsAo+ADugMMC/IIirX1CCSuyr6QelW5SZwQ9BlhOsYYVKhEvsvtlR8ajpP7dlPO7ZIfaYkQcpKdZjP/A2BYxX2UXZFZQPYVOPA8BWiz6F4LcIbkC1gS5F94NhL54quaCy6EiBXdBKyJ5pDjEARzKL6EsactYI5oLikZhvwCsJNUW4Ai2rCLaoJs6jGe/C0RPqkwSTtk7K7AuDiGF+BH2ctPwgbu642gTza03dRS/Tu+gjD5gx6nfJQzaL3IQYVVuhhW0W3FbZL4bGOWbeo3lfrGTuYnVNXp8Kv6FR0JUCu6KxIMZPSEcYs0sP0rx4wbQSEriDcAK6j3ES4DXyIcBOV68C8wgyi08A0YtZTQLsKmYpjrzGbg/0F7OrLWKYrfwE/jSra0EUQp2Xbrb9ZwN7irOX6tlZBjdQcqlm3OEboC3KkcIRxRriD6GvMttqXGKSxgbCFsIkxTfUxyKRaBxlyJTiu6IzoSoBc0VlTgdkW2o+8m8IstNso5Tbm5Ps1DIKZKz/nrb9ZYBqkWpyfBma8z8bL8AnpgheLFWM6OkI4Qo0HW8wC9zFmsjfvy/MWguyLZPuKHhbKvqJ7NO5EqvWM3TL80cUW54p+inQlQK7oIqmPmey2MSeapzACYAqhh9JVmEFlDmEBdBF0AVhUkTlF5lWYB5ZQXTTvjSmMaqFemAG6iGYKmRpVPzN/KjhIxtB424NDm1Nie7Ei1XVIWmh9NZIUgCoyBPqo7iHsIrKjIjugu6q6A+ypsodwALKPsK/KrojsCrIr5ZqFCH3VYljW6XH5V6GNK7qiC6ErAXJFb4MqM8oAY8evvAFnGCRRHVRcsP5KNCILoLsYgbFE43fpsAxjBEiTXvUnkd+1KeyUpNZfYf1Vi9xq/R5iJvvqwF61RlF9Vjf3HZTfD6jvfJFdQYyPKTQv0/Q/r+iKLoz+/6MGJR/0FcZNAAAAAElFTkSuQmCC";
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$g = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$c = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // e.g. heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$g);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = _extends({}, props, {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$c(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, hasSvgAsChild && children.props, {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(path2, displayName) {
  function Component2(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends({
      "data-testid": `${displayName}Icon`,
      ref
    }, props, {
      children: path2
    }));
  }
  Component2.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component2));
}
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$f = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$b = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === "elevation" && _extends({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$f);
  const ownerState = _extends({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$b(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other));
});
const Paper$1 = Paper;
function isHostComponent(element2) {
  return typeof element2 === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends({}, otherProps, {
    ownerState: _extends({}, otherProps.ownerState, ownerState)
  });
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = _extends({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
const _excluded$e = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose$1(parameters, _excluded$e);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const _excluded$d = ["center", "classes", "className"];
let _$1 = (t2) => t2, _t$1, _t2$1, _t3$1, _t4$1;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2$1 || (_t2$1 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3$1 || (_t3$1 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4$1 || (_t4$1 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$d);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = useTimeout();
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element2 = fakeElement ? null : container.current;
    const rect = element2 ? element2.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element2 ? element2.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element2 ? element2.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.start(DELAY_RIPPLE, () => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        });
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit, startTimer]);
  const pulsate = reactExports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = reactExports.useCallback((event, cb2) => {
    startTimer.clear();
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.start(0, () => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, [startTimer]);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends({
    className: clsx(touchRippleClasses.root, classes.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const _excluded$c = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$a = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$c);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore2 = skipRippleAction;
      if (!ignore2 && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
  const ownerState = _extends({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$a(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
});
const ButtonBase$1 = ButtonBase;
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const _excluded$b = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled(ButtonBase$1, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme.vars || theme).palette.action.active,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme,
  ownerState
}) => {
  var _palette;
  const palette = (_palette = (theme.vars || theme).palette) == null ? void 0 : _palette[ownerState.color];
  return _extends({}, ownerState.color === "inherit" && {
    color: "inherit"
  }, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends({
    color: palette == null ? void 0 : palette.main
  }, !ownerState.disableRipple && {
    "&:hover": _extends({}, palette && {
      backgroundColor: theme.vars ? `rgba(${palette.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(palette.main, theme.palette.action.hoverOpacity)
    }, {
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    })
  }), ownerState.size === "small" && {
    padding: 5,
    fontSize: theme.typography.pxToRem(18)
  }, ownerState.size === "large" && {
    padding: 12,
    fontSize: theme.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses.disabled}`]: {
      backgroundColor: "transparent",
      color: (theme.vars || theme).palette.action.disabled
    }
  });
});
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$b);
  const ownerState = _extends({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size
  });
  const classes = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(IconButtonRoot, _extends({
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref,
    ownerState
  }, other, {
    children
  }));
});
const IconButton$1 = IconButton;
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$a = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph: paragraph2,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph2 && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(({
  theme,
  ownerState
}) => _extends({
  margin: 0
}, ownerState.variant === "inherit" && {
  // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
  font: "inherit"
}, ownerState.variant !== "inherit" && theme.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const colorTransformations$1 = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors$1 = (color2) => {
  return colorTransformations$1[color2] || color2;
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTypography"
  });
  const color2 = transformDeprecatedColors$1(themeProps.color);
  const props = extendSxProp(_extends({}, themeProps, {
    color: color2
  }));
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph: paragraph2 = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$a);
  const ownerState = _extends({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph: paragraph2,
    variant,
    variantMapping
  });
  const Component2 = component || (paragraph2 ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TypographyRoot, _extends({
    as: Component2,
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, other));
});
const Typography$1 = Typography;
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element2, show) {
  if (show) {
    element2.setAttribute("aria-hidden", "true");
  } else {
    element2.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element2) {
  return parseInt(ownerWindow(element2).getComputedStyle(element2).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element2) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element2.tagName) !== -1;
  const isInputHidden = element2.tagName === "INPUT" && element2.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element2) => {
    const isNotExcludedElement = blacklist.indexOf(element2) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element2);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element2, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element2) => {
        restoreStyle.push({
          value: element2.style.paddingRight,
          property: "padding-right",
          el: element2
        });
        element2.style.paddingRight = `${getPaddingRight(element2) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element2) => {
    if (element2.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element2);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
    !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
    return _extends({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    });
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends({}, props, {
    defaultTheme: defaultTheme$2,
    themeId: THEME_ID
  }));
}
const Person = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");
function getAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiAvatar", slot);
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const _excluded$9 = ["alt", "children", "className", "component", "imgProps", "sizes", "src", "srcSet", "variant"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes);
};
const AvatarRoot = styled("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(({
  theme
}) => ({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme.typography.fontFamily,
  fontSize: theme.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none",
  variants: [{
    props: {
      variant: "rounded"
    },
    style: {
      borderRadius: (theme.vars || theme).shape.borderRadius
    }
  }, {
    props: {
      variant: "square"
    },
    style: {
      borderRadius: 0
    }
  }, {
    props: {
      colorDefault: true
    },
    style: _extends({
      color: (theme.vars || theme).palette.background.default
    }, theme.vars ? {
      backgroundColor: theme.vars.palette.Avatar.defaultBg
    } : _extends({
      backgroundColor: theme.palette.grey[400]
    }, theme.applyStyles("dark", {
      backgroundColor: theme.palette.grey[600]
    })))
  }]
}));
const AvatarImg = styled("img", {
  name: "MuiAvatar",
  slot: "Img",
  overridesResolver: (props, styles2) => styles2.img
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image. The property isn't supported by IE11.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled(Person, {
  name: "MuiAvatar",
  slot: "Fallback",
  overridesResolver: (props, styles2) => styles2.fallback
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src,
  srcSet
}) {
  const [loaded, setLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!src && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image2 = new Image();
    image2.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image2.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image2.crossOrigin = crossOrigin;
    image2.referrerPolicy = referrerPolicy;
    image2.src = src;
    if (srcSet) {
      image2.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src, srcSet]);
  return loaded;
}
const Avatar = /* @__PURE__ */ reactExports.forwardRef(function Avatar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const {
    alt,
    children: childrenProp,
    className,
    component = "div",
    imgProps,
    sizes,
    src,
    srcSet,
    variant = "circular"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$9);
  let children = null;
  const loaded = useLoaded(_extends({}, imgProps, {
    src,
    srcSet
  }));
  const hasImg = src || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  const ownerState = _extends({}, props, {
    colorDefault: !hasImgNotFailing,
    component,
    variant
  });
  const classes = useUtilityClasses$7(ownerState);
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarImg, _extends({
      alt,
      srcSet,
      src,
      sizes,
      ownerState,
      className: classes.img
    }, imgProps));
  } else if (childrenProp != null && childrenProp !== "" && typeof childrenProp !== "boolean") {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, {
      ownerState,
      className: classes.fallback
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarRoot, _extends({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children
  }));
});
const Avatar$1 = Avatar;
const _excluded$8 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$1 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$8);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends({
        style: _extends({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$1[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
const Fade$1 = Fade;
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$7 = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  var _slotProps$root, _ref, _slots$root;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    components = {},
    componentsProps = {},
    invisible = false,
    open,
    slotProps = {},
    slots = {},
    TransitionComponent = Fade$1,
    transitionDuration
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$7);
  const ownerState = _extends({}, props, {
    component,
    invisible
  });
  const classes = useUtilityClasses$6(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes,
      ref,
      children
    }))
  }));
});
const Backdrop$1 = Backdrop;
const html$4 = (theme, enableColorScheme) => _extends({
  WebkitFontSmoothing: "antialiased",
  // Antialiasing.
  MozOsxFontSmoothing: "grayscale",
  // Antialiasing.
  // Change from `box-sizing: content-box` so that `width`
  // is not affected by `padding` or `border`.
  boxSizing: "border-box",
  // Fix font resize problem in iOS
  WebkitTextSizeAdjust: "100%"
}, enableColorScheme && !theme.vars && {
  colorScheme: theme.palette.mode
});
const body = (theme) => _extends({
  color: (theme.vars || theme).palette.text.primary
}, theme.typography.body1, {
  backgroundColor: (theme.vars || theme).palette.background.default,
  "@media print": {
    // Save printer ink.
    backgroundColor: (theme.vars || theme).palette.common.white
  }
});
const styles = (theme, enableColorScheme = false) => {
  var _theme$components;
  const colorSchemeStyles = {};
  if (enableColorScheme && theme.colorSchemes) {
    Object.entries(theme.colorSchemes).forEach(([key2, scheme]) => {
      var _scheme$palette;
      colorSchemeStyles[theme.getColorSchemeSelector(key2).replace(/\s*&/, "")] = {
        colorScheme: (_scheme$palette = scheme.palette) == null ? void 0 : _scheme$palette.mode
      };
    });
  }
  let defaultStyles = _extends({
    html: html$4(theme, enableColorScheme),
    "*, *::before, *::after": {
      boxSizing: "inherit"
    },
    "strong, b": {
      fontWeight: theme.typography.fontWeightBold
    },
    body: _extends({
      margin: 0
    }, body(theme), {
      // Add support for document.body.requestFullScreen().
      // Other elements, if background transparent, are not supported.
      "&::backdrop": {
        backgroundColor: (theme.vars || theme).palette.background.default
      }
    })
  }, colorSchemeStyles);
  const themeOverrides = (_theme$components = theme.components) == null || (_theme$components = _theme$components.MuiCssBaseline) == null ? void 0 : _theme$components.styleOverrides;
  if (themeOverrides) {
    defaultStyles = [defaultStyles, themeOverrides];
  }
  return defaultStyles;
};
function CssBaseline(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCssBaseline"
  });
  const {
    children,
    enableColorScheme = false
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      styles: (theme) => styles(theme, enableColorScheme)
    }), children]
  });
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$6 = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
const ModalRoot = styled("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled(Backdrop$1, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useThemeProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open,
    slotProps,
    slots
    // eslint-disable-next-line react/prop-types
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$6);
  const propsWithDefaults = _extends({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(_extends({}, propsWithDefaults, {
    rootRef: ref
  }));
  const ownerState = _extends({}, propsWithDefaults, {
    exited
  });
  const classes = useUtilityClasses$5(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
  });
  const backdropProps = useSlotProps({
    elementType: BackdropSlot,
    externalSlotProps: backdropSlotProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
const Modal$1 = Modal;
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const dialogClasses$1 = dialogClasses;
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const DialogContext$1 = DialogContext;
const _excluded$5 = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled(Backdrop$1, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    scroll: scroll2,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize(scroll2)}`],
    paper: ["paper", `paperScroll${capitalize(scroll2)}`, `paperWidth${capitalize(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled(Modal$1, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, ownerState.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&::after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
}));
const DialogPaper = styled(Paper$1, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize(ownerState.scroll)}`], styles2[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(({
  theme,
  ownerState
}) => _extends({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ownerState.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ownerState.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ownerState.maxWidth === "xs" && {
  maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
  maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.fullWidth && {
  width: "calc(100% - 64px)"
}, ownerState.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
}));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onBackdropClick,
    onClose,
    open,
    PaperComponent = Paper$1,
    PaperProps = {},
    scroll: scroll2 = "paper",
    TransitionComponent = Fade$1,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$5);
  const ownerState = _extends({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll: scroll2
  });
  const classes = useUtilityClasses$4(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends({
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown,
    onClose,
    open,
    ref,
    onClick: handleBackdropClick,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends({
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext$1.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      })
    }))
  }));
});
const Dialog$1 = Dialog;
const GridContext = /* @__PURE__ */ reactExports.createContext();
const GridContext$1 = GridContext;
function getGridUtilityClass(slot) {
  return generateUtilityClass("MuiGrid", slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses = generateUtilityClasses("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...SPACINGS.map((spacing) => `spacing-xs-${spacing}`),
  // direction values
  ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
  // wrap values
  ...WRAPS.map((wrap2) => `wrap-xs-${wrap2}`),
  // grid sizes for all breakpoints
  ...GRID_SIZES.map((size) => `grid-xs-${size}`),
  ...GRID_SIZES.map((size) => `grid-sm-${size}`),
  ...GRID_SIZES.map((size) => `grid-md-${size}`),
  ...GRID_SIZES.map((size) => `grid-lg-${size}`),
  ...GRID_SIZES.map((size) => `grid-xl-${size}`)
]);
const _excluded$4 = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function getOffset(val) {
  const parse2 = parseFloat(val);
  return `${parse2}${String(val).replace(String(parse2), "") || "px"}`;
}
function generateGrid({
  theme,
  ownerState
}) {
  let size;
  return theme.breakpoints.keys.reduce((globalStyles, breakpoint) => {
    let styles2 = {};
    if (ownerState[breakpoint]) {
      size = ownerState[breakpoint];
    }
    if (!size) {
      return globalStyles;
    }
    if (size === true) {
      styles2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    } else if (size === "auto") {
      styles2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    } else {
      const columnsBreakpointValues = resolveBreakpointValues({
        values: ownerState.columns,
        breakpoints: theme.breakpoints.values
      });
      const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
      if (columnValue === void 0 || columnValue === null) {
        return globalStyles;
      }
      const width2 = `${Math.round(size / columnValue * 1e8) / 1e6}%`;
      let more = {};
      if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
        const themeSpacing = theme.spacing(ownerState.columnSpacing);
        if (themeSpacing !== "0px") {
          const fullWidth = `calc(${width2} + ${getOffset(themeSpacing)})`;
          more = {
            flexBasis: fullWidth,
            maxWidth: fullWidth
          };
        }
      }
      styles2 = _extends({
        flexBasis: width2,
        flexGrow: 0,
        maxWidth: width2
      }, more);
    }
    if (theme.breakpoints.values[breakpoint] === 0) {
      Object.assign(globalStyles, styles2);
    } else {
      globalStyles[theme.breakpoints.up(breakpoint)] = styles2;
    }
    return globalStyles;
  }, {});
}
function generateDirection({
  theme,
  ownerState
}) {
  const directionValues = resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme.breakpoints.values
  });
  return handleBreakpoints({
    theme
  }, directionValues, (propValue) => {
    const output = {
      flexDirection: propValue
    };
    if (propValue.indexOf("column") === 0) {
      output[`& > .${gridClasses.item}`] = {
        maxWidth: "none"
      };
    }
    return output;
  });
}
function extractZeroValueBreakpointKeys({
  breakpoints,
  values: values2
}) {
  let nonZeroKey = "";
  Object.keys(values2).forEach((key2) => {
    if (nonZeroKey !== "") {
      return;
    }
    if (values2[key2] !== 0) {
      nonZeroKey = key2;
    }
  });
  const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a2, b2) => {
    return breakpoints[a2] - breakpoints[b2];
  });
  return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({
  theme,
  ownerState
}) {
  const {
    container,
    rowSpacing
  } = ownerState;
  let styles2 = {};
  if (container && rowSpacing !== 0) {
    const rowSpacingValues = resolveBreakpointValues({
      values: rowSpacing,
      breakpoints: theme.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof rowSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme.breakpoints.values,
        values: rowSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme
    }, rowSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK;
      const themeSpacing = theme.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          marginTop: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingTop: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
        return {};
      }
      return {
        marginTop: 0,
        [`& > .${gridClasses.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return styles2;
}
function generateColumnGap({
  theme,
  ownerState
}) {
  const {
    container,
    columnSpacing
  } = ownerState;
  let styles2 = {};
  if (container && columnSpacing !== 0) {
    const columnSpacingValues = resolveBreakpointValues({
      values: columnSpacing,
      breakpoints: theme.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof columnSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme.breakpoints.values,
        values: columnSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme
    }, columnSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK2;
      const themeSpacing = theme.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          width: `calc(100% + ${getOffset(themeSpacing)})`,
          marginLeft: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingLeft: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
        return {};
      }
      return {
        width: "100%",
        marginLeft: 0,
        [`& > .${gridClasses.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return styles2;
}
function resolveSpacingStyles(spacing, breakpoints, styles2 = {}) {
  if (!spacing || spacing <= 0) {
    return [];
  }
  if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
    return [styles2[`spacing-xs-${String(spacing)}`]];
  }
  const spacingStyles = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
    }
  });
  return spacingStyles;
}
const GridRoot = styled("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      container,
      direction,
      item,
      spacing,
      wrap: wrap2,
      zeroMinWidth,
      breakpoints
    } = ownerState;
    let spacingStyles = [];
    if (container) {
      spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles2);
    }
    const breakpointsStyles = [];
    breakpoints.forEach((breakpoint) => {
      const value = ownerState[breakpoint];
      if (value) {
        breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
      }
    });
    return [styles2.root, container && styles2.container, item && styles2.item, zeroMinWidth && styles2.zeroMinWidth, ...spacingStyles, direction !== "row" && styles2[`direction-xs-${String(direction)}`], wrap2 !== "wrap" && styles2[`wrap-xs-${String(wrap2)}`], ...breakpointsStyles];
  }
})(({
  ownerState
}) => _extends({
  boxSizing: "border-box"
}, ownerState.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, ownerState.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, ownerState.zeroMinWidth && {
  minWidth: 0
}, ownerState.wrap !== "wrap" && {
  flexWrap: ownerState.wrap
}), generateDirection, generateRowGap, generateColumnGap, generateGrid);
function resolveSpacingClasses(spacing, breakpoints) {
  if (!spacing || spacing <= 0) {
    return [];
  }
  if (typeof spacing === "string" && !Number.isNaN(Number(spacing)) || typeof spacing === "number") {
    return [`spacing-xs-${String(spacing)}`];
  }
  const classes = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      const className = `spacing-${breakpoint}-${String(value)}`;
      classes.push(className);
    }
  });
  return classes;
}
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    container,
    direction,
    item,
    spacing,
    wrap: wrap2,
    zeroMinWidth,
    breakpoints
  } = ownerState;
  let spacingClasses = [];
  if (container) {
    spacingClasses = resolveSpacingClasses(spacing, breakpoints);
  }
  const breakpointsClasses = [];
  breakpoints.forEach((breakpoint) => {
    const value = ownerState[breakpoint];
    if (value) {
      breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
    }
  });
  const slots = {
    root: ["root", container && "container", item && "item", zeroMinWidth && "zeroMinWidth", ...spacingClasses, direction !== "row" && `direction-xs-${String(direction)}`, wrap2 !== "wrap" && `wrap-xs-${String(wrap2)}`, ...breakpointsClasses]
  };
  return composeClasses(slots, getGridUtilityClass, classes);
};
const Grid = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiGrid"
  });
  const {
    breakpoints
  } = useTheme();
  const props = extendSxProp(themeProps);
  const {
    className,
    columns: columnsProp,
    columnSpacing: columnSpacingProp,
    component = "div",
    container = false,
    direction = "row",
    item = false,
    rowSpacing: rowSpacingProp,
    spacing = 0,
    wrap: wrap2 = "wrap",
    zeroMinWidth = false
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$4);
  const rowSpacing = rowSpacingProp || spacing;
  const columnSpacing = columnSpacingProp || spacing;
  const columnsContext = reactExports.useContext(GridContext$1);
  const columns = container ? columnsProp || 12 : columnsContext;
  const breakpointsValues = {};
  const otherFiltered = _extends({}, other);
  breakpoints.keys.forEach((breakpoint) => {
    if (other[breakpoint] != null) {
      breakpointsValues[breakpoint] = other[breakpoint];
      delete otherFiltered[breakpoint];
    }
  });
  const ownerState = _extends({}, props, {
    columns,
    container,
    direction,
    item,
    rowSpacing,
    columnSpacing,
    wrap: wrap2,
    zeroMinWidth,
    spacing
  }, breakpointsValues, {
    breakpoints: breakpoints.keys
  });
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GridContext$1.Provider, {
    value: columns,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(GridRoot, _extends({
      ownerState,
      className: clsx(classes.root, className),
      as: component,
      ref
    }, otherFiltered))
  });
});
const Grid$1 = Grid;
function getLinkUtilityClass(slot) {
  return generateUtilityClass("MuiLink", slot);
}
const linkClasses = generateUtilityClasses("MuiLink", ["root", "underlineNone", "underlineHover", "underlineAlways", "button", "focusVisible"]);
const linkClasses$1 = linkClasses;
const colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors = (color2) => {
  return colorTransformations[color2] || color2;
};
const getTextDecoration = ({
  theme,
  ownerState
}) => {
  const transformedColor = transformDeprecatedColors(ownerState.color);
  const color2 = getPath(theme, `palette.${transformedColor}`, false) || ownerState.color;
  const channelColor = getPath(theme, `palette.${transformedColor}Channel`);
  if ("vars" in theme && channelColor) {
    return `rgba(${channelColor} / 0.4)`;
  }
  return alpha(color2, 0.4);
};
const _excluded$3 = ["className", "color", "component", "onBlur", "onFocus", "TypographyClasses", "underline", "variant", "sx"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    component,
    focusVisible,
    underline
  } = ownerState;
  const slots = {
    root: ["root", `underline${capitalize(underline)}`, component === "button" && "button", focusVisible && "focusVisible"]
  };
  return composeClasses(slots, getLinkUtilityClass, classes);
};
const LinkRoot = styled(Typography$1, {
  name: "MuiLink",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`underline${capitalize(ownerState.underline)}`], ownerState.component === "button" && styles2.button];
  }
})(({
  theme,
  ownerState
}) => {
  return _extends({}, ownerState.underline === "none" && {
    textDecoration: "none"
  }, ownerState.underline === "hover" && {
    textDecoration: "none",
    "&:hover": {
      textDecoration: "underline"
    }
  }, ownerState.underline === "always" && _extends({
    textDecoration: "underline"
  }, ownerState.color !== "inherit" && {
    textDecorationColor: getTextDecoration({
      theme,
      ownerState
    })
  }, {
    "&:hover": {
      textDecorationColor: "inherit"
    }
  }), ownerState.component === "button" && {
    position: "relative",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${linkClasses$1.focusVisible}`]: {
      outline: "auto"
    }
  });
});
const Link = /* @__PURE__ */ reactExports.forwardRef(function Link2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiLink"
  });
  const {
    className,
    color: color2 = "primary",
    component = "a",
    onBlur,
    onFocus,
    TypographyClasses,
    underline = "always",
    variant = "inherit",
    sx
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$3);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  const handlerRef = useForkRef(ref, focusVisibleRef);
  const handleBlur = (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  };
  const handleFocus = (event) => {
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  const ownerState = _extends({}, props, {
    color: color2,
    component,
    focusVisible,
    underline,
    variant
  });
  const classes = useUtilityClasses$2(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LinkRoot, _extends({
    color: color2,
    className: clsx(classes.root, className),
    classes: TypographyClasses,
    component,
    onBlur: handleBlur,
    onFocus: handleFocus,
    ref: handlerRef,
    ownerState,
    variant,
    sx: [...!Object.keys(colorTransformations).includes(color2) ? [{
      color: color2
    }] : [], ...Array.isArray(sx) ? sx : [sx]]
  }, other));
});
const Link$1 = Link;
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass("MuiSkeleton", slot);
}
generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const _excluded$2 = ["animation", "className", "component", "height", "style", "variant", "width"];
let _ = (t2) => t2, _t, _t2, _t3, _t4;
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    variant,
    animation,
    hasChildren,
    width: width2,
    height: height2
  } = ownerState;
  const slots = {
    root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width2 && "fitContent", hasChildren && !height2 && "heightAuto"]
  };
  return composeClasses(slots, getSkeletonUtilityClass, classes);
};
const pulseKeyframe = keyframes(_t || (_t = _`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
const waveKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
const SkeletonRoot = styled("span", {
  name: "MuiSkeleton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
  }
})(({
  theme,
  ownerState
}) => {
  const radiusUnit = getUnit(theme.shape.borderRadius) || "px";
  const radiusValue = toUnitless(theme.shape.borderRadius);
  return _extends({
    display: "block",
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme.vars ? theme.vars.palette.Skeleton.bg : alpha(theme.palette.text.primary, theme.palette.mode === "light" ? 0.11 : 0.13),
    height: "1.2em"
  }, ownerState.variant === "text" && {
    marginTop: 0,
    marginBottom: 0,
    height: "auto",
    transformOrigin: "0 55%",
    transform: "scale(1, 0.60)",
    borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
    "&:empty:before": {
      content: '"\\00a0"'
    }
  }, ownerState.variant === "circular" && {
    borderRadius: "50%"
  }, ownerState.variant === "rounded" && {
    borderRadius: (theme.vars || theme).shape.borderRadius
  }, ownerState.hasChildren && {
    "& > *": {
      visibility: "hidden"
    }
  }, ownerState.hasChildren && !ownerState.width && {
    maxWidth: "fit-content"
  }, ownerState.hasChildren && !ownerState.height && {
    height: "auto"
  });
}, ({
  ownerState
}) => ownerState.animation === "pulse" && css(_t3 || (_t3 = _`
      animation: ${0} 2s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
  ownerState,
  theme
}) => ownerState.animation === "wave" && css(_t4 || (_t4 = _`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 2s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme.vars || theme).palette.action.hover));
const Skeleton = /* @__PURE__ */ reactExports.forwardRef(function Skeleton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSkeleton"
  });
  const {
    animation = "pulse",
    className,
    component = "span",
    height: height2,
    style: style2,
    variant = "text",
    width: width2
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$2);
  const ownerState = _extends({}, props, {
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  });
  const classes = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonRoot, _extends({
    as: component,
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    style: _extends({
      width: width2,
      height: height2
    }, style2)
  }));
});
const Skeleton$1 = Skeleton;
function getToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiToolbar", slot);
}
generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const _excluded$1 = ["className", "component", "disableGutters", "variant"];
const useUtilityClasses = (ownerState) => {
  const {
    classes,
    disableGutters,
    variant
  } = ownerState;
  const slots = {
    root: ["root", !disableGutters && "gutters", variant]
  };
  return composeClasses(slots, getToolbarUtilityClass, classes);
};
const ToolbarRoot = styled("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !ownerState.disableGutters && {
  paddingLeft: theme.spacing(2),
  paddingRight: theme.spacing(2),
  [theme.breakpoints.up("sm")]: {
    paddingLeft: theme.spacing(3),
    paddingRight: theme.spacing(3)
  }
}, ownerState.variant === "dense" && {
  minHeight: 48
}), ({
  theme,
  ownerState
}) => ownerState.variant === "regular" && theme.mixins.toolbar);
const Toolbar = /* @__PURE__ */ reactExports.forwardRef(function Toolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiToolbar"
  });
  const {
    className,
    component = "div",
    disableGutters = false,
    variant = "regular"
  } = props, other = _objectWithoutPropertiesLoose$1(props, _excluded$1);
  const ownerState = _extends({}, props, {
    component,
    disableGutters,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarRoot, _extends({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
const Tollbar = Toolbar;
const encodeData = (content2) => {
  const encoder = new TextEncoder();
  const data = encoder.encode(content2);
  const base64 = btoa(String.fromCharCode(...new Uint8Array(data.buffer)));
  return base64;
};
const getToken = (name2, type = "") => {
  try {
    let data = localStorage.getItem(name2);
    if (type == "json") {
      return JSON.parse(data);
    }
    return data || "";
  } catch {
    return "";
  }
};
const setToken = (name2, val) => {
  try {
    if (typeof val == "object") {
      val = JSON.stringify(val);
    }
    localStorage.setItem(name2, val);
  } catch {
  }
};
class Config {
  constructor(props) {
    try {
      this.API_URL = "https://api.younet.ai/api";
      this.RIGHT = (props == null ? void 0 : props.RIGHT) ? Number(props.RIGHT) : 24;
      this.BOTTOM = (props == null ? void 0 : props.BOTTOM) ? Number(props.BOTTOM) : 20;
      this.HEIGHT = (props == null ? void 0 : props.HEIGHT) ? Number(props.HEIGHT) : 60;
      this.WIDTH = (props == null ? void 0 : props.WIDTH) ? Number(props.WIDTH) : 60;
    } catch (error) {
      console.error("Config: ", error);
    }
  }
}
const GLOBAL_TIMEOUT_PERIOD_MS = 6e4;
const RESPONSE_TIMEOUT_MESSAGE_CODE = "message.timeout";
async function createStream(url, callback, params = {}, signal = {}, errorCallback = () => {
}, streamSettings = { TIMEOUT_PERIOD_MS: 15e3, hasAttachments: false }) {
  var _a;
  let abortTimeoutId, errorSaveAction = true;
  const restartAbortTimer = (timeout = streamSettings.TIMEOUT_PERIOD_MS) => {
    clearTimeout(abortTimeoutId);
    abortTimeoutId = setTimeout(() => {
      console.error("Failed to establish SSE connection.");
      errorCallback({
        message: [RESPONSE_TIMEOUT_MESSAGE_CODE],
        params: { saveMessage: errorSaveAction }
      });
    }, timeout);
  };
  try {
    restartAbortTimer(GLOBAL_TIMEOUT_PERIOD_MS);
    const response = await fetch(new Config().API_URL + url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer `
        // "Access-Control-Allow-Origin": "*",
      },
      body: JSON.stringify(params),
      signal
    });
    if (response.status === 200 && response.headers.get("Content-Type").startsWith("text/event-stream")) {
      let processChunk = function({ done, value }) {
        var _a2;
        if (done) {
          console.log("SSE stream has ended.");
          clearTimeout(abortTimeoutId);
          return;
        }
        restartAbortTimer();
        let chunkData = { data: "", response: null, message: null };
        const chunkText = decoder.decode(value);
        const eventDataList = chunkText.split("\n");
        let parsedData = "";
        for (let eventData of eventDataList) {
          if (eventData.trim() == "") {
            continue;
          }
          if (eventData.startsWith("data: {")) {
            dataBuffer = eventData.slice(6);
          } else {
            dataBuffer += eventData;
          }
          try {
            let data = JSON.parse(dataBuffer);
            parsedData = data;
          } catch (error) {
            continue;
          }
          if (parsedData.response) {
            chunkData.response = parsedData.response;
            if (parsedData.balance) {
              chunkData.balance = parsedData.balance;
            }
            clearTimeout(abortTimeoutId);
          } else if (parsedData.message) {
            errorSaveAction = false;
            chunkData.message = parsedData.message;
            if (((_a2 = parsedData.attachments) == null ? void 0 : _a2.length) > 0) {
              chunkData.message.attachments = parsedData.attachments;
            }
            chunkData.sources = parsedData.sources;
          } else if (parsedData.data) {
            chunkData.data += parsedData.data;
          } else if (streamSettings.hasAttachments && parsedData.status == "processing") {
            chunkData.progressStatus = {
              status: parsedData.status,
              msg: parsedData.processing_message
            };
          } else if (parsedData.error) {
            chunkData.error = parsedData.error;
            clearTimeout(abortTimeoutId);
            callback(chunkData);
            return;
          }
        }
        if (chunkData.data !== "" || chunkData.response || chunkData.message || chunkData.progressStatus) {
          callback(chunkData);
        }
        reader.read().then(processChunk).catch(handleReadError);
      };
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let dataBuffer = "";
      const handleReadError = (err) => {
        var _a2;
        if ((_a2 = signal == null ? void 0 : signal.reason) == null ? void 0 : _a2.userAction) {
          console.warn("User aborted the request.");
          errorCallback({ params: { hideErrorMsg: true } });
        } else {
          console.error("Failed to establish SSE connection.");
          errorCallback({
            message: [RESPONSE_TIMEOUT_MESSAGE_CODE],
            params: { saveMessage: errorSaveAction }
          });
        }
        console.warn(err);
        clearTimeout(abortTimeoutId);
      };
      reader.read().then(processChunk).catch(handleReadError);
    } else {
      const responseData = await response.json();
      clearTimeout(abortTimeoutId);
      console.error("Failed to establish SSE connection.");
      errorCallback(responseData);
      console.error("Failed to establish SSE connection.");
    }
  } catch (e2) {
    console.error(e2);
    console.warn(e2.message);
    clearTimeout(abortTimeoutId);
    if ((_a = signal == null ? void 0 : signal.reason) == null ? void 0 : _a.userAction) {
      console.warn("User aborted the request.");
      errorCallback({
        params: { hideErrorMsg: true, saveMessage: errorSaveAction }
      });
    } else {
      console.error("Failed to establish SSE connection.");
      errorCallback();
    }
  }
}
const isInAppBrowser = (userAgent) => {
  const regex2 = /FBAN|FBAV|Instagram|LinkedInApp|Mobile Safari/i;
  return regex2.test(userAgent) && !/Chrome/i.test(userAgent);
};
const useDeviceDetect = () => {
  const userAgent = typeof window.navigator === "undefined" ? "" : navigator.userAgent;
  const isInAppView = reactExports.useMemo(() => isInAppBrowser(userAgent), [userAgent]);
  const [isMobileDevice, setMobile] = reactExports.useState(() => {
    const savedIsMobileDevice = localStorage.getItem("isMobileDevice");
    return savedIsMobileDevice !== null ? JSON.parse(savedIsMobileDevice) : false;
  });
  reactExports.useEffect(() => {
    const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone|Mobile|SymbianOS|Opera Mini|IEMobile|Kindle|Silk|PlayBook|Nintendo|Mobile Safari/i;
    const mobile = mobileRegex.test(userAgent);
    setMobile(mobile);
    localStorage.setItem("isMobileDevice", JSON.stringify(mobile));
  }, [userAgent]);
  return { isMobileDevice, userAgent, isInAppView };
};
const getShareData = async (modelHash) => {
  var _a, _b;
  try {
    const res = await fetch("https://api.younet.ai/api/model/share/data", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        modelHash,
        guestId: (_b = (_a = getToken("younetChat", "json")) == null ? void 0 : _a.guest) == null ? void 0 : _b.guest_id
      })
    });
    if (res.status !== 200) {
      throw new Error("Error fetching data");
    }
    const data = await res.json();
    setToken("younetChat", data);
    return data;
  } catch (error) {
  }
};
var Component = {};
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text2, options) {
  var debug, message, reselectPrevious, range, selection, mark2, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range = document.createRange();
    selection = document.getSelection();
    mark2 = document.createElement("span");
    mark2.textContent = text2;
    mark2.ariaHidden = "true";
    mark2.style.all = "unset";
    mark2.style.position = "fixed";
    mark2.style.top = 0;
    mark2.style.clip = "rect(0, 0, 0, 0)";
    mark2.style.whiteSpace = "pre";
    mark2.style.webkitUserSelect = "text";
    mark2.style.MozUserSelect = "text";
    mark2.style.msUserSelect = "text";
    mark2.style.userSelect = "text";
    mark2.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text2);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text2);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark2);
    range.selectNodeContents(mark2);
    selection.addRange(range);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text2);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text2);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark2) {
      document.body.removeChild(mark2);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
Object.defineProperty(Component, "__esModule", {
  value: true
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault(reactExports);
var _copyToClipboard = _interopRequireDefault(copyToClipboard);
var _excluded = ["text", "onCopy", "options", "children"];
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o3, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
    o4.__proto__ = p3;
    return o4;
  };
  return _setPrototypeOf(o3, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o3) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
    return o4.__proto__ || Object.getPrototypeOf(o4);
  };
  return _getPrototypeOf(o3);
}
function _defineProperty(obj, key2, value) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value;
  }
  return obj;
}
var CopyToClipboard$1 = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(CopyToClipboard2, _React$PureComponent);
  var _super = _createSuper(CopyToClipboard2);
  function CopyToClipboard2() {
    var _this;
    _classCallCheck(this, CopyToClipboard2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
      var _this$props = _this.props, text2 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
      var elem = _react["default"].Children.only(children);
      var result = (0, _copyToClipboard["default"])(text2, options);
      if (onCopy) {
        onCopy(text2, result);
      }
      if (elem && elem.props && typeof elem.props.onClick === "function") {
        elem.props.onClick(event);
      }
    });
    return _this;
  }
  _createClass(CopyToClipboard2, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props;
      _this$props2.text;
      _this$props2.onCopy;
      _this$props2.options;
      var children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
      var elem = _react["default"].Children.only(children);
      return /* @__PURE__ */ _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
        onClick: this.onClick
      }));
    }
  }]);
  return CopyToClipboard2;
}(_react["default"].PureComponent);
Component.CopyToClipboard = CopyToClipboard$1;
_defineProperty(CopyToClipboard$1, "defaultProps", {
  onCopy: void 0,
  options: void 0
});
var _require = Component, CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
function ccount(value, character2) {
  const source = String(value);
  if (typeof character2 !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source.indexOf(character2);
  while (index2 !== -1) {
    count++;
    index2 = source.indexOf(character2, index2 + character2.length);
  }
  return count;
}
function ok$4() {
}
function unreachable() {
}
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex2) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex2.test(String.fromCharCode(code2));
  }
}
function escapeStringRegexp(string2) {
  if (typeof string2 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const convert$2 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok$3;
    }
    if (typeof test === "function") {
      return castFactory$2(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory$2(test) : propsFactory$2(test);
    }
    if (typeof test === "string") {
      return typeFactory$2(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory$2(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$2(tests[index2]);
  }
  return castFactory$2(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory$2(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory$2(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key2;
    for (key2 in check) {
      if (nodeAsRecord[key2] !== checkAsRecord[key2])
        return false;
    }
    return true;
  }
}
function typeFactory$2(check) {
  return castFactory$2(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory$2(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok$3() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color$2(d2) {
  return d2;
}
const empty$1 = [];
const CONTINUE$2 = true;
const EXIT$2 = false;
const SKIP$2 = "skip";
function visitParents$2(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is = convert$2(check);
  const step = reverse ? -1 : 1;
  factory2(tree, void 0, [])();
  function factory2(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color$2(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty$1;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult$2(visitor(node2, parents));
        if (result[0] === EXIT$2) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP$2) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child2 = nodeAsParent.children[offset];
            subresult = factory2(child2, offset, grandparents)();
            if (subresult[0] === EXIT$2) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult$2(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$2, value];
  }
  return value === null || value === void 0 ? empty$1 : [value];
}
function findAndReplace(tree, list2, options) {
  const settings = options || {};
  const ignored = convert$2(settings.ignore || []);
  const pairs = toPairs(list2);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents$2(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index2 = -1;
    let grandparent;
    while (++index2 < parents.length) {
      const parent = parents[index2];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find2 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start = 0;
    const siblings = parent.children;
    const index2 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find2.lastIndex = 0;
    let match2 = find2.exec(node2.value);
    while (match2) {
      const position2 = match2.index;
      const matchObject = {
        index: match2.index,
        input: match2.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match2, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find2.lastIndex = position2 + 1;
      } else {
        if (start !== position2) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start, position2)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start = position2 + match2[0].length;
        change = true;
      }
      if (!find2.global) {
        break;
      }
      match2 = find2.exec(node2.value);
    }
    if (change) {
      if (start < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start) });
      }
      parent.children.splice(index2, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index2 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index2 = -1;
  while (++index2 < list2.length) {
    const tuple = list2[index2];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}
const inConstruct = "phrasing";
const notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token2);
}
function enterLiteralAutolinkValue(token2) {
  this.config.enter.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkHttp(token2) {
  this.config.exit.autolinkProtocol.call(this, token2);
}
function exitLiteralAutolinkWww(token2) {
  this.config.exit.data.call(this, token2);
  const node2 = this.stack[this.stack.length - 1];
  ok$4(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token2);
}
function exitLiteralAutolinkEmail(token2) {
  this.config.exit.autolinkEmail.call(this, token2);
}
function exitLiteralAutolink(token2) {
  this.exit(token2);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_2, protocol, domain2, path2, match2) {
  let prefix2 = "";
  if (!previous$1(match2)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix2 = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path2);
  if (!parts[0])
    return false;
  const result = {
    type: "link",
    title: null,
    url: prefix2 + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_2, atext, label2, match2) {
  if (
    // Not an expected previous character.
    !previous$1(match2, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label2)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label2,
    children: [{ type: "text", value: atext + "@" + label2 }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous$1(match2, email2) {
  const code2 = match2.input.charCodeAt(match2.index - 1);
  return (match2.index === 0 || unicodeWhitespace(code2) || unicodePunctuation(code2)) && (!email2 || code2 !== 47);
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
footnoteReference$1.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference: footnoteReference$1 }
  };
}
function enterFootnoteDefinition(token2) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token2
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token2) {
  const label2 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$4(node2.type === "footnoteDefinition");
  node2.label = label2;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token2)
  ).toLowerCase();
}
function exitFootnoteDefinition(token2) {
  this.exit(token2);
}
function enterFootnoteCall(token2) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token2);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token2) {
  const label2 = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok$4(node2.type === "footnoteReference");
  node2.label = label2;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token2)
  ).toLowerCase();
}
function exitFootnoteCall(token2) {
  this.exit(token2);
}
function footnoteReference$1(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit2();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit2 = state.enter("footnoteDefinition");
  const subexit = state.enter("label");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node2.children && node2.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    state.indentLines(state.containerFlow(node2, tracker.current()), map$2)
  );
  exit2();
  return value;
}
function map$2(line2, index2, blank) {
  if (index2 === 0) {
    return line2;
  }
  return (blank ? "" : "    ") + line2;
}
const constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token2) {
  this.enter({ type: "delete", children: [] }, token2);
}
function exitStrikethrough(token2) {
  this.exit(token2);
}
function handleDelete(node2, _2, state, info) {
  const tracker = state.createTracker(info);
  const exit2 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit2();
  return value;
}
function peekDelete() {
  return "~";
}
function markdownTable(table2, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize$1(table2[rowIndex][columnIndex2]);
      if (options.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code2 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code2 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code2 === 99) {
      before = ":";
      after = ":";
    } else if (code2 === 108) {
      before = ":";
    } else if (code2 === 114) {
      after = ":";
    }
    let size = options.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line2 = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (options.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code2 = alignments[columnIndex];
        if (code2 === 114) {
          before = " ".repeat(size);
        } else if (code2 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (options.delimiterStart !== false && !columnIndex) {
        line2.push("|");
      }
      if (options.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(options.alignDelimiters === false && cell === "") && (options.delimiterStart !== false || columnIndex)) {
        line2.push(" ");
      }
      if (options.alignDelimiters !== false) {
        line2.push(before);
      }
      line2.push(cell);
      if (options.alignDelimiters !== false) {
        line2.push(after);
      }
      if (options.padding !== false) {
        line2.push(" ");
      }
      if (options.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line2.push("|");
      }
    }
    lines.push(
      options.delimiterEnd === false ? line2.join("").replace(/ +$/, "") : line2.join("")
    );
  }
  return lines.join("\n");
}
function serialize$1(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code2 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
}
function blockquote$1(node2, _2, state, info) {
  const exit2 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map$1
  );
  exit2();
  return value;
}
function map$1(line2, _2, blank) {
  return ">" + (blank ? "" : " ") + line2;
}
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  if (!list2 || list2.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list2.length) {
    if (stack.includes(list2[index2])) {
      return true;
    }
  }
  return false;
}
function hardBreak$1(_2, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}
function longestStreak(value, substring) {
  const source = String(value);
  let index2 = source.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source.indexOf(substring, expected);
  }
  return max;
}
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If there’s no info…
    !node2.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}
function code$2(node2, _2, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit3 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map);
    exit3();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit2 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit2();
  return value;
}
function map(line2, _2, blank) {
  return (blank ? "" : "    ") + line2;
}
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}
function definition$1(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit2();
  return value;
}
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}
emphasis$1.peek = emphasisPeek;
function emphasis$1(node2, _2, state, info) {
  const marker = checkEmphasis(state);
  const exit2 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit2();
  return value;
}
function emphasisPeek(_2, _1, state) {
  return state.options.emphasis || "*";
}
function visit$2(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents$2(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const emptyOptions$4 = {};
function toString$2(value, options) {
  const settings = options || emptyOptions$4;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$3(value, includeImageAlt, includeHtml);
}
function one$3(value, includeImageAlt, includeHtml) {
  if (node$1(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all$1(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all$1(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all$1(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one$3(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node$1(value) {
  return Boolean(value && typeof value === "object");
}
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit$2(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT$2;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString$2(node2) && (state.options.setext || literalWithBreak)
  );
}
function heading$1(node2, _2, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit3 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit3();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit2 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit2();
  return value;
}
html$3.peek = htmlPeek;
function html$3(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}
image$1.peek = imagePeek;
function image$1(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit2 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function imagePeek() {
  return "!";
}
imageReference$1.peek = imageReferencePeek;
function imageReference$1(node2, _2, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}
inlineCode$1.peek = inlineCodePeek;
function inlineCode$1(node2, _2, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = state.compilePattern(pattern);
    let match2;
    if (!pattern.atBreak)
      continue;
    while (match2 = expression.exec(value)) {
      let position2 = match2.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match2.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(node2, state) {
  const raw = toString$2(node2);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node2.url && // And there’s a no title…
    !node2.title && // And the content of `node` is a single text node…
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node2.url)
  );
}
link$2.peek = linkPeek;
function link$2(node2, _2, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit2;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit2 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit2();
    state.stack = stack;
    return value2;
  }
  exit2 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit2();
  return value;
}
function linkPeek(node2, _2, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}
linkReference$1.peek = linkReferencePeek;
function linkReference$1(node2, _2, state, info) {
  const type = node2.referenceType;
  const exit2 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text2 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text2 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit2();
  if (type === "full" || !text2 || text2 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}
function list$2(node2, parent, state, info) {
  const exit2 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit2();
  return value;
}
function checkListItemIndent(state) {
  const style2 = state.options.listItemIndent || "one";
  if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style2;
}
function listItem$1(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit2 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map2
  );
  exit2();
  return value;
  function map2(line2, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line2;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
  }
}
function paragraph$1(node2, _2, state, info) {
  const exit2 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit2();
  return value;
}
const phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert$2([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function root$2(node2, _2, state, info) {
  const hasPhrasing = node2.children.some(function(d2) {
    return phrasing(d2);
  });
  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn.call(state, node2, info);
}
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}
strong$1.peek = strongPeek;
function strong$1(node2, _2, state, info) {
  const marker = checkStrong(state);
  const exit2 = state.enter("strong");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit2();
  return value;
}
function strongPeek(_2, _1, state) {
  return state.options.strong || "*";
}
function text$5(node2, _2, state, info) {
  return state.safe(node2.value, info);
}
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}
function thematicBreak$2(_2, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}
const handle = {
  blockquote: blockquote$1,
  break: hardBreak$1,
  code: code$2,
  definition: definition$1,
  emphasis: emphasis$1,
  hardBreak: hardBreak$1,
  heading: heading$1,
  html: html$3,
  image: image$1,
  imageReference: imageReference$1,
  inlineCode: inlineCode$1,
  link: link$2,
  linkReference: linkReference$1,
  list: list$2,
  listItem: listItem$1,
  paragraph: paragraph$1,
  root: root$2,
  strong: strong$1,
  text: text$5,
  thematicBreak: thematicBreak$2
};
const element$1 = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element$1.innerHTML = characterReference2;
  const char2 = element$1.textContent;
  if (char2.charCodeAt(char2.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char2 === characterReference2 ? false : char2;
}
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return "�";
  }
  return String.fromCodePoint(code2);
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit$1,
      tableHeader: exit$1,
      tableRow: exit$1
    }
  };
}
function enterTable(token2) {
  const align = token2._align;
  this.enter(
    {
      type: "table",
      align: align.map(function(d2) {
        return d2 === "none" ? null : d2;
      }),
      children: []
    },
    token2
  );
  this.data.inTable = true;
}
function exitTable(token2) {
  this.exit(token2);
  this.data.inTable = void 0;
}
function enterRow(token2) {
  this.enter({ type: "tableRow", children: [] }, token2);
}
function exit$1(token2) {
  this.exit(token2);
}
function enterCell(token2) {
  this.enter({ type: "tableCell", children: [] }, token2);
}
function exitCodeText(token2) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace$1);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok$4(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token2);
}
function replace$1($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding2 = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding2 ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _2, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _2, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _2, state, info) {
    const exit2 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit2();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: padding2,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(children[index2], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(children[index2], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token2) {
  const node2 = this.stack[this.stack.length - 2];
  ok$4(node2.type === "listItem");
  node2.checked = token2.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token2) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok$4(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token2);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}
function splice(list2, start, remove, items) {
  const end2 = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end2 ? 0 : end2 + start;
  } else {
    start = start > end2 ? end2 : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove)
      list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2))
          left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}
const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path$1 = {
  tokenize: tokenizePath,
  partial: true
};
const trail = {
  tokenize: tokenizeTrail,
  partial: true
};
const emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
const wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
const emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
const text$4 = {};
function gfmAutolinkLiteral() {
  return {
    text: text$4
  };
}
let code$1 = 48;
while (code$1 < 123) {
  text$4[code$1] = emailAutolink;
  code$1++;
  if (code$1 === 58)
    code$1 = 65;
  else if (code$1 === 91)
    code$1 = 97;
}
text$4[43] = emailAutolink;
text$4[45] = emailAutolink;
text$4[46] = emailAutolink;
text$4[95] = emailAutolink;
text$4[72] = [emailAutolink, protocolAutolink];
text$4[104] = [emailAutolink, protocolAutolink];
text$4[87] = [emailAutolink, wwwAutolink];
text$4[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok2, nok) {
  const self2 = this;
  let dot;
  let data;
  return start;
  function start(code2) {
    if (!gfmAtext(code2) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code2);
  }
  function atext(code2) {
    if (gfmAtext(code2)) {
      effects.consume(code2);
      return atext;
    }
    if (code2 === 64) {
      effects.consume(code2);
      return emailDomain;
    }
    return nok(code2);
  }
  function emailDomain(code2) {
    if (code2 === 46) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code2);
    }
    if (code2 === 45 || code2 === 95 || asciiAlphanumeric(code2)) {
      data = true;
      effects.consume(code2);
      return emailDomain;
    }
    return emailDomainAfter(code2);
  }
  function emailDomainDot(code2) {
    effects.consume(code2);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code2) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeWwwAutolink(effects, ok2, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code2) {
    if (code2 !== 87 && code2 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code2);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path$1, wwwAfter), nok),
      nok
    )(code2);
  }
  function wwwAfter(code2) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeProtocolAutolink(effects, ok2, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code2) {
    if ((code2 === 72 || code2 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    return nok(code2);
  }
  function protocolPrefixInside(code2) {
    if (asciiAlpha(code2) && buffer.length < 5) {
      buffer += String.fromCodePoint(code2);
      effects.consume(code2);
      return protocolPrefixInside;
    }
    if (code2 === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code2);
        return protocolSlashesInside;
      }
    }
    return nok(code2);
  }
  function protocolSlashesInside(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code2);
  }
  function afterProtocol(code2) {
    return code2 === null || asciiControl(code2) || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || unicodePunctuation(code2) ? nok(code2) : effects.attempt(domain, effects.attempt(path$1, protocolAfter), nok)(code2);
  }
  function protocolAfter(code2) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok2(code2);
  }
}
function tokenizeWwwPrefix(effects, ok2, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code2) {
    if ((code2 === 87 || code2 === 119) && size < 3) {
      size++;
      effects.consume(code2);
      return wwwPrefixInside;
    }
    if (code2 === 46 && size === 3) {
      effects.consume(code2);
      return wwwPrefixAfter;
    }
    return nok(code2);
  }
  function wwwPrefixAfter(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function tokenizeDomain(effects, ok2, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code2) {
    if (code2 === 46 || code2 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2) || code2 !== 45 && unicodePunctuation(code2)) {
      return domainAfter(code2);
    }
    seen = true;
    effects.consume(code2);
    return domainInside;
  }
  function domainAtPunctuation(code2) {
    if (code2 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code2);
    return domainInside;
  }
  function domainAfter(code2) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code2);
    }
    return ok2(code2);
  }
}
function tokenizePath(effects, ok2) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code2) {
    if (code2 === 40) {
      sizeOpen++;
      effects.consume(code2);
      return pathInside;
    }
    if (code2 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code2);
    }
    if (code2 === 33 || code2 === 34 || code2 === 38 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 60 || code2 === 63 || code2 === 93 || code2 === 95 || code2 === 126) {
      return effects.check(trail, ok2, pathAtPunctuation)(code2);
    }
    if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    effects.consume(code2);
    return pathInside;
  }
  function pathAtPunctuation(code2) {
    if (code2 === 41) {
      sizeClose++;
    }
    effects.consume(code2);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok2, nok) {
  return trail2;
  function trail2(code2) {
    if (code2 === 33 || code2 === 34 || code2 === 39 || code2 === 41 || code2 === 42 || code2 === 44 || code2 === 46 || code2 === 58 || code2 === 59 || code2 === 63 || code2 === 95 || code2 === 126) {
      effects.consume(code2);
      return trail2;
    }
    if (code2 === 38) {
      effects.consume(code2);
      return trailCharRefStart;
    }
    if (code2 === 93) {
      effects.consume(code2);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code2 === 60 || // So is whitespace.
      code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)
    ) {
      return ok2(code2);
    }
    return nok(code2);
  }
  function trailBracketAfter(code2) {
    if (code2 === null || code2 === 40 || code2 === 91 || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
      return ok2(code2);
    }
    return trail2(code2);
  }
  function trailCharRefStart(code2) {
    return asciiAlpha(code2) ? trailCharRefInside(code2) : nok(code2);
  }
  function trailCharRefInside(code2) {
    if (code2 === 59) {
      effects.consume(code2);
      return trail2;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return trailCharRefInside;
    }
    return nok(code2);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    return asciiAlphanumeric(code2) ? nok(code2) : ok2(code2);
  }
}
function previousWww(code2) {
  return code2 === null || code2 === 40 || code2 === 42 || code2 === 95 || code2 === 91 || code2 === 93 || code2 === 126 || markdownLineEndingOrSpace(code2);
}
function previousProtocol(code2) {
  return !asciiAlpha(code2);
}
function previousEmail(code2) {
  return !(code2 === 47 || gfmAtext(code2));
}
function gfmAtext(code2) {
  return code2 === 43 || code2 === 45 || code2 === 46 || code2 === 95 || asciiAlphanumeric(code2);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token2 = events[index2][1];
    if ((token2.type === "labelLink" || token2.type === "labelImage") && !token2._balanced) {
      result = true;
      break;
    }
    if (token2._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace2 = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace2 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next2 = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code2, next2);
        skip = 1;
      } else {
        replace2 = "�";
      }
    } else {
      replace2 = String.fromCharCode(code2);
    }
    if (replace2) {
      result.push(value.slice(start, index2), encodeURIComponent(replace2));
      start = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end2 = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end2, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end: end2
          };
          text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text2, context]
          ]);
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text2, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token2 = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token2._open = Boolean(marker === 42 ? open : open && (before || !close));
    token2._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      const next2 = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next2;
    }
    return nok(code2);
  }
}
function factorySpace(effects, ok2, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix2(code2);
    }
    return ok2(code2);
  }
  function prefix2(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix2;
    }
    effects.exit(type);
    return ok2(code2);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        contBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === 59 && size) {
      const token2 = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
const codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      "linePrefix",
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token2;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between(code2);
  }
  function between(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === 96) {
      token2 = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token2.type = "codeTextData";
    return data(code2);
  }
}
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token2 = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token2._tokenizer || context.parser[token2.contentType](token2.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token2;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token2;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.unshift([start2, start2 + slice2.length - 1]);
    splice(events, start2, 2, slice2);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content$1 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen)
      seen = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape2 : inside;
  }
  function escape2(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code2);
    }
    return ok2(code2);
  }
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier2;
  return start;
  function start(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    identifier2 = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier2);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context],
      ["enter", text2, context],
      ["exit", text2, context],
      ["exit", content2, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
const blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration2;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment2(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment2;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment2(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end2(code2) : code2 === 45 ? commentClose(code2) : comment2(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end2(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration2(code2) {
    if (code2 === null || code2 === 62) {
      return end2(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration2;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration2;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end2(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end2(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end2;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end2(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end2(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token2 = events[index2][1];
    if (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd") {
      events.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
      token2.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token2;
  let open;
  let close;
  let media;
  while (index2--) {
    token2 = events[index2][1];
    if (open) {
      if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token2.type === "labelLink") {
        token2._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
        open = index2;
        if (token2.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token2.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label2 = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label2, context]
  ];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text2, context]]);
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text2, context],
    events[close - 2],
    events[close - 1],
    ["exit", label2, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === 91) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}
const list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent$1,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok2,
      "listItemIndent",
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(
      effects,
      effects.attempt(list$1, ok2, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code2);
  }
}
function tokenizeIndent$1(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text2][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const indent = {
  tokenize: tokenizeIndent,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token2 = self2.events[index2][1];
    if (token2.type === "labelImage") {
      labelStart = token2;
      break;
    }
    if (token2.type === "gfmFootnoteCall" || token2.type === "labelLink" || token2.type === "label" || token2.type === "image" || token2.type === "link") {
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code2);
    }
    const id2 = normalizeIdentifier(
      self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })
    );
    if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
      return nok(code2);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok2(code2);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string2 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string2.start),
    end: Object.assign({}, string2.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string2, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string2, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code2) {
    if (code2 !== 94)
      return nok(code2);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code2) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
    ) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token2 = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token2)))) {
        return nok(code2);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok2;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? callEscape : callData;
  }
  function callEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return callData;
    }
    return callData(code2);
  }
}
function tokenizeDefinitionStart(effects, ok2, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier2;
  let size = 0;
  let data;
  return start;
  function start(code2) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code2);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code2) {
    if (code2 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code2);
  }
  function labelInside(code2) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code2 === 93 && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code2 === null || code2 === 91 || markdownLineEndingOrSpace(code2)
    ) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit("chunkString");
      const token2 = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier2 = normalizeIdentifier(self2.sliceSerialize(token2));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code2);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code2)) {
      data = true;
    }
    size++;
    effects.consume(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
  function labelAfter(code2) {
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier2)) {
        defined.push(identifier2);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code2);
  }
  function whitespaceAfter(code2) {
    return ok2(code2);
  }
}
function tokenizeDefinitionContinuation(effects, ok2, nok) {
  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok2(code2) : nok(code2);
  }
}
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text2 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text2, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index2), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text2, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough2, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok2, nok) {
    const previous2 = this.previous;
    const events = this.events;
    let size = 0;
    return start;
    function start(code2) {
      if (previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code2);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code2);
    }
    function more(code2) {
      const before = classifyCharacter(previous2);
      if (code2 === 126) {
        if (size > 1)
          return nok(code2);
        effects.consume(code2);
        size++;
        return more;
      }
      if (size < 2 && !single)
        return nok(code2);
      const token2 = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code2);
      token2._open = !after || after === 2 && Boolean(before);
      token2._close = !before || before === 2 && Boolean(after);
      return ok2(code2);
    }
  }
}
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index2, remove, add) {
    addImpl(this, index2, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a2, b2) {
      return a2[0] - b2[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(
        events.slice(this.map[index2][0] + this.map[index2][1]),
        this.map[index2][2]
      );
      events.length = this.map[index2][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice2 = vecs.pop();
    while (slice2) {
      events.push(...slice2);
      slice2 = vecs.pop();
    }
    this.map.length = 0;
  }
}
function addImpl(editMap, at, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at, remove, add]);
}
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}
function gfmTable() {
  return {
    flow: {
      null: {
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start;
  function start(code2) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type = self2.events[index2][1].type;
      if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === "linePrefix")
        index2--;
      else
        break;
    }
    const tail = index2 > -1 ? self2.events[index2][1].type : null;
    const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    return next2(code2);
  }
  function headRowBefore(code2) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code2);
  }
  function headRowStart(code2) {
    if (code2 === 124) {
      return headRowBreak(code2);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code2);
  }
  function headRowBreak(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code2);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code2);
  }
  function headRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return headRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return headRowData;
    }
    return headRowData(code2);
  }
  function headDelimiterStart(code2) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        headDelimiterBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code2);
    }
    return headDelimiterBefore(code2);
  }
  function headDelimiterBefore(code2) {
    if (code2 === 45 || code2 === 58) {
      return headDelimiterValueBefore(code2);
    }
    if (code2 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterCellBefore(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code2);
    }
    return headDelimiterValueBefore(code2);
  }
  function headDelimiterValueBefore(code2) {
    if (code2 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code2 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return headDelimiterCellAfter(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterLeftAlignmentAfter(code2) {
    if (code2 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterFiller(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return headDelimiterFiller;
    }
    if (code2 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code2);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code2);
  }
  function headDelimiterRightAlignmentAfter(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code2);
    }
    return headDelimiterCellAfter(code2);
  }
  function headDelimiterCellAfter(code2) {
    if (code2 === 124) {
      return headDelimiterBefore(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code2);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok2(code2);
    }
    return headDelimiterNok(code2);
  }
  function headDelimiterNok(code2) {
    return nok(code2);
  }
  function bodyRowStart(code2) {
    effects.enter("tableRow");
    return bodyRowBreak(code2);
  }
  function bodyRowBreak(code2) {
    if (code2 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code2);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("tableRow");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code2);
    }
    effects.enter("data");
    return bodyRowData(code2);
  }
  function bodyRowData(code2) {
    if (code2 === null || code2 === 124 || markdownLineEndingOrSpace(code2)) {
      effects.exit("data");
      return bodyRowBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code2) {
    if (code2 === 92 || code2 === 124) {
      effects.consume(code2);
      return bodyRowData;
    }
    return bodyRowData(code2);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map2 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token2 = event[1];
    if (event[0] === "enter") {
      if (token2.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token2.start),
          // Note: correct end is set later.
          end: Object.assign({}, token2.end)
        };
        map2.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token2.type === "tableRow" || token2.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token2.start),
            // Note: correct end is set later.
            end: Object.assign({}, token2.end)
          };
          map2.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token2.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token2.type === "data" || token2.type === "tableDelimiterMarker" || token2.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token2.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map2,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token2.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token2.type === "tableRow" || token2.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(
          map2,
          context,
          lastCell,
          rowKind,
          index2,
          currentCell
        );
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map2, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token2.type === "data" || token2.type === "tableDelimiterMarker" || token2.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map2, context, lastTableEnd, currentTable, currentBody);
  }
  map2.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map2, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map2.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map2.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map2.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start = context.events[range[2]];
      const end2 = context.events[range[3]];
      start[1].end = Object.assign({}, end2[1].end);
      start[1].type = "chunkText";
      start[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a2 = range[2] + 1;
        const b2 = range[3] - range[2] - 1;
        map2.add(a2, b2, []);
      }
    }
    map2.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map2.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map2, context, index2, table2, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table2.end = Object.assign({}, related);
  exits.push(["exit", table2, context]);
  map2.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}
const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      [91]: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(effects, ok2, nok) {
  const self2 = this;
  return open;
  function open(code2) {
    if (
      // Exit if there’s stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code2);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code2);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code2) {
    if (markdownLineEndingOrSpace(code2)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code2 === 88 || code2 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code2);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code2);
  }
  function close(code2) {
    if (code2 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code2);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok2,
        nok
      )(code2);
    }
    return nok(code2);
  }
}
function spaceThenNonSpace(effects, ok2, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code2) {
    return code2 === null ? nok(code2) : ok2(code2);
  }
}
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}
const emptyOptions$3 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor} */
    this
  );
  const settings = options || emptyOptions$3;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}
function newlineToBreak(tree) {
  findAndReplace(tree, [/\r?\n|\r/g, replace]);
}
function replace() {
  return { type: "break" };
}
function remarkBreaks() {
  return function(tree) {
    newlineToBreak(tree);
  };
}
const emptyOptions$2 = {};
function toString$1(value, options) {
  const settings = options || emptyOptions$2;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one$2(value, includeImageAlt, includeHtml);
}
function one$2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one$2(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
const convert$1 = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok$2;
    }
    if (typeof test === "string") {
      return typeFactory$1(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory$1(test) : propsFactory$1(test);
    }
    if (typeof test === "function") {
      return castFactory$1(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory$1(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert$1(tests[index2]);
  }
  return castFactory$1(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory$1(check) {
  return castFactory$1(all2);
  function all2(node2) {
    let key2;
    for (key2 in check) {
      if (node2[key2] !== check[key2])
        return false;
    }
    return true;
  }
}
function typeFactory$1(check) {
  return castFactory$1(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory$1(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok$2() {
  return true;
}
function color$1(d2) {
  return d2;
}
const CONTINUE$1 = true;
const EXIT$1 = false;
const SKIP$1 = "skip";
const visitParents$1 = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is = convert$1(test);
    const step = reverse ? -1 : 1;
    factory2(tree, void 0, [])();
    function factory2(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name2 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color$1(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult$1(visitor(node2, parents));
          if (result[0] === EXIT$1) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP$1) {
          offset = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset > -1 && offset < node2.children.length) {
            subresult = factory2(node2.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT$1) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult$1(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE$1, value];
  }
  return [value];
}
const visit$1 = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents$1(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);
var regex$1 = /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g;
const regex = regex$1;
var githubSlugger = BananaSlug;
const own$5 = Object.hasOwnProperty;
function BananaSlug() {
  const self2 = this;
  if (!(self2 instanceof BananaSlug))
    return new BananaSlug();
  self2.reset();
}
BananaSlug.prototype.slug = function(value, maintainCase) {
  const self2 = this;
  let slug = slugger(value, maintainCase === true);
  const originalSlug = slug;
  while (own$5.call(self2.occurrences, slug)) {
    self2.occurrences[originalSlug]++;
    slug = originalSlug + "-" + self2.occurrences[originalSlug];
  }
  self2.occurrences[slug] = 0;
  return slug;
};
BananaSlug.prototype.reset = function() {
  this.occurrences = /* @__PURE__ */ Object.create(null);
};
function slugger(string2, maintainCase) {
  if (typeof string2 !== "string")
    return "";
  if (!maintainCase)
    string2 = string2.toLowerCase();
  return string2.replace(regex, "").replace(/ /g, "-");
}
BananaSlug.slug = slugger;
const BananaSlug$1 = /* @__PURE__ */ getDefaultExportFromCjs(githubSlugger);
const slugs = new BananaSlug$1();
function remarkSlug() {
  return (tree) => {
    slugs.reset();
    visit$1(tree, "heading", (node2) => {
      const data = node2.data || (node2.data = {});
      const props = (
        /** @type {Properties} */
        data.hProperties || (data.hProperties = {})
      );
      let id2 = props.id;
      id2 = id2 ? slugs.slug(String(id2), true) : slugs.slug(toString$1(node2));
      data.id = id2;
      props.id = id2;
    });
  };
}
const convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok$1;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node2) {
    let key2;
    for (key2 in check) {
      if (node2[key2] !== check[key2])
        return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok$1() {
  return true;
}
function color(d2) {
  return d2;
}
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
const visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is = convert(test);
    const step = reverse ? -1 : 1;
    factory2(tree, void 0, [])();
    function factory2(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name2 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP) {
          offset = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset > -1 && offset < node2.children.length) {
            subresult = factory2(node2.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}
const visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn.call(obj, key2);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend = function extend2() {
  var options, name2, src, copy2, copyIsArray, clone;
  var target = arguments[0];
  var i = 1;
  var length2 = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length2; ++i) {
    options = arguments[i];
    if (options != null) {
      for (name2 in options) {
        src = getProperty(target, name2);
        copy2 = getProperty(options, name2);
        if (target !== copy2) {
          if (deep && copy2 && (isPlainObject$1(copy2) || (copyIsArray = isArray(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend2(deep, clone, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target, { name: name2, newValue: copy2 });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
const contentDefaults = {
  type: "element",
  tagName: "span",
  properties: { className: ["icon", "icon-link"] },
  children: []
};
function rehypeAutolinkHeadings(options = {}) {
  let props = options.linkProperties;
  const behavior = "behavior" in options && options.behavior || "prepend";
  const content2 = "content" in options && options.content || contentDefaults;
  const group = "group" in options ? options.group : void 0;
  let method;
  if (behavior === "wrap") {
    method = wrap2;
  } else if (behavior === "before" || behavior === "after") {
    method = around;
  } else {
    if (!props) {
      props = { ariaHidden: "true", tabIndex: -1 };
    }
    method = inject;
  }
  return (tree) => {
    visit(tree, "heading", method);
  };
  function inject(node2) {
    const url = getUrl(node2);
    if (url) {
      const link2 = create2(url);
      link2.data = Object.assign({}, link2.data, {
        hProperties: extend$1(true, {}, props),
        hChildren: toChildren(content2, node2)
      });
      node2.children[behavior === "prepend" ? "unshift" : "push"](link2);
    }
  }
  function around(node2, index2, parent) {
    const url = getUrl(node2);
    if (url && typeof index2 === "number" && parent) {
      const link2 = create2(url);
      const grouping = group ? toGrouping(group, node2) : void 0;
      link2.data = Object.assign({}, link2.data, {
        hProperties: extend$1(true, {}, props),
        hChildren: toChildren(content2, node2)
      });
      let nodes = behavior === "before" ? [link2, node2] : [node2, link2];
      if (grouping) {
        grouping.children = nodes;
        nodes = [grouping];
      }
      parent.children.splice(index2, 1, ...nodes);
      return [SKIP, index2 + nodes.length];
    }
  }
  function wrap2(node2) {
    const url = getUrl(node2);
    if (url) {
      const link2 = create2(url, toStaticPhrasingContent(node2.children));
      link2.data = { hProperties: extend$1(true, {}, props) };
      node2.children = [link2];
    }
  }
  function toNode(value, node2) {
    return typeof value === "function" ? value(node2) : value;
  }
  function toChildren(value, node2) {
    const result = toNode(value, node2);
    const children = Array.isArray(result) ? result : [result];
    return typeof value === "function" ? children : extend$1(true, [], children);
  }
  function toGrouping(value, node2) {
    const grouping = toNode(value, node2);
    if (Array.isArray(grouping) || grouping.type !== "element") {
      throw new Error("Expected element as grouping");
    }
    const hName = grouping.tagName;
    const hProperties = grouping.properties;
    return {
      // @ts-expect-error: custom node.
      type: "heading-group",
      data: {
        hName,
        hProperties: typeof value === "function" ? extend$1(true, {}, hProperties) : hProperties
      },
      children: []
    };
  }
  function create2(url, children) {
    return {
      type: "link",
      url,
      title: null,
      children: children || []
    };
  }
  function getUrl(node2) {
    const data = node2.data || {};
    const props2 = (
      /** @type {Properties} */
      data.hProperties
    );
    const id2 = props2 && props2.id;
    return id2 ? "#" + id2 : void 0;
  }
  function toStaticPhrasingContent(nodes) {
    let result = [];
    let index2 = -1;
    if (nodes) {
      while (++index2 < nodes.length) {
        result = result.concat(toStaticPhrasingContentOne(nodes[index2]));
      }
    }
    return result;
  }
  function toStaticPhrasingContentOne(node2) {
    if (node2.type === "link" || node2.type === "linkReference" || node2.type === "footnote" || node2.type === "footnoteReference") {
      return toStaticPhrasingContent(node2.children);
    }
    if ("children" in node2) {
      const { children, position: position3, ...copy3 } = node2;
      return Object.assign(extend$1(true, {}, copy3), {
        children: toStaticPhrasingContent(node2.children)
      });
    }
    const { position: position2, ...copy2 } = node2;
    return extend$1(true, {}, copy2);
  }
}
var dist = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const typedArrayTypeNames = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function isTypedArrayName(name2) {
    return typedArrayTypeNames.includes(name2);
  }
  const objectTypeNames = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    ...typedArrayTypeNames
  ];
  function isObjectTypeName(name2) {
    return objectTypeNames.includes(name2);
  }
  const primitiveTypeNames = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  function isPrimitiveTypeName(name2) {
    return primitiveTypeNames.includes(name2);
  }
  function isOfType(type) {
    return (value) => typeof value === type;
  }
  const { toString: toString2 } = Object.prototype;
  const getObjectType = (value) => {
    const objectTypeName = toString2.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
      return "HTMLElement";
    }
    if (isObjectTypeName(objectTypeName)) {
      return objectTypeName;
    }
    return void 0;
  };
  const isObjectOfType = (type) => (value) => getObjectType(value) === type;
  function is(value) {
    if (value === null) {
      return "null";
    }
    switch (typeof value) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
    }
    if (is.observable(value)) {
      return "Observable";
    }
    if (is.array(value)) {
      return "Array";
    }
    if (is.buffer(value)) {
      return "Buffer";
    }
    const tagType = getObjectType(value);
    if (tagType) {
      return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
      throw new TypeError("Please don't use object wrappers for primitive types");
    }
    return "Object";
  }
  is.undefined = isOfType("undefined");
  is.string = isOfType("string");
  const isNumberType = isOfType("number");
  is.number = (value) => isNumberType(value) && !is.nan(value);
  is.bigint = isOfType("bigint");
  is.function_ = isOfType("function");
  is.null_ = (value) => value === null;
  is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
  is.boolean = (value) => value === true || value === false;
  is.symbol = isOfType("symbol");
  is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
  is.array = (value, assertion) => {
    if (!Array.isArray(value)) {
      return false;
    }
    if (!is.function_(assertion)) {
      return true;
    }
    return value.every(assertion);
  };
  is.buffer = (value) => {
    var _a, _b, _c, _d;
    return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false;
  };
  is.blob = (value) => isObjectOfType("Blob")(value);
  is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
  is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
  is.iterable = (value) => {
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]);
  };
  is.asyncIterable = (value) => {
    var _a;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]);
  };
  is.generator = (value) => {
    var _a, _b;
    return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw);
  };
  is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
  is.nativePromise = (value) => isObjectOfType("Promise")(value);
  const hasPromiseAPI = (value) => {
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
  };
  is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
  is.generatorFunction = isObjectOfType("GeneratorFunction");
  is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
  is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
  is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
  is.regExp = isObjectOfType("RegExp");
  is.date = isObjectOfType("Date");
  is.error = isObjectOfType("Error");
  is.map = (value) => isObjectOfType("Map")(value);
  is.set = (value) => isObjectOfType("Set")(value);
  is.weakMap = (value) => isObjectOfType("WeakMap")(value);
  is.weakSet = (value) => isObjectOfType("WeakSet")(value);
  is.int8Array = isObjectOfType("Int8Array");
  is.uint8Array = isObjectOfType("Uint8Array");
  is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
  is.int16Array = isObjectOfType("Int16Array");
  is.uint16Array = isObjectOfType("Uint16Array");
  is.int32Array = isObjectOfType("Int32Array");
  is.uint32Array = isObjectOfType("Uint32Array");
  is.float32Array = isObjectOfType("Float32Array");
  is.float64Array = isObjectOfType("Float64Array");
  is.bigInt64Array = isObjectOfType("BigInt64Array");
  is.bigUint64Array = isObjectOfType("BigUint64Array");
  is.arrayBuffer = isObjectOfType("ArrayBuffer");
  is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
  is.dataView = isObjectOfType("DataView");
  is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
  is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
  is.urlInstance = (value) => isObjectOfType("URL")(value);
  is.urlString = (value) => {
    if (!is.string(value)) {
      return false;
    }
    try {
      new URL(value);
      return true;
    } catch (_a) {
      return false;
    }
  };
  is.truthy = (value) => Boolean(value);
  is.falsy = (value) => !value;
  is.nan = (value) => Number.isNaN(value);
  is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
  is.integer = (value) => Number.isInteger(value);
  is.safeInteger = (value) => Number.isSafeInteger(value);
  is.plainObject = (value) => {
    if (toString2.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
  };
  is.typedArray = (value) => isTypedArrayName(getObjectType(value));
  const isValidLength = (value) => is.safeInteger(value) && value >= 0;
  is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
  is.inRange = (value, range) => {
    if (is.number(range)) {
      return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
      return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
  };
  const NODE_TYPE_ELEMENT = 1;
  const DOM_PROPERTIES_TO_CHECK = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  is.domElement = (value) => {
    return is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
  };
  is.observable = (value) => {
    var _a, _b, _c, _d;
    if (!value) {
      return false;
    }
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
      return true;
    }
    if (value === ((_d = (_c = value)["@@observable"]) === null || _d === void 0 ? void 0 : _d.call(_c))) {
      return true;
    }
    return false;
  };
  is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
  is.infinite = (value) => value === Infinity || value === -Infinity;
  const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
  is.evenInteger = isAbsoluteMod2(0);
  is.oddInteger = isAbsoluteMod2(1);
  is.emptyArray = (value) => is.array(value) && value.length === 0;
  is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
  is.emptyString = (value) => is.string(value) && value.length === 0;
  const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
  is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
  is.nonEmptyString = (value) => is.string(value) && value.length > 0;
  is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
  is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
  is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
  is.emptySet = (value) => is.set(value) && value.size === 0;
  is.nonEmptySet = (value) => is.set(value) && value.size > 0;
  is.emptyMap = (value) => is.map(value) && value.size === 0;
  is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
  is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
  is.formData = (value) => isObjectOfType("FormData")(value);
  is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
  const predicateOnArray = (method, predicate, values2) => {
    if (!is.function_(predicate)) {
      throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values2.length === 0) {
      throw new TypeError("Invalid number of values");
    }
    return method.call(values2, predicate);
  };
  is.any = (predicate, ...values2) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values2));
  };
  is.all = (predicate, ...values2) => predicateOnArray(Array.prototype.every, predicate, values2);
  const assertType = (condition, description, value, options = {}) => {
    if (!condition) {
      const { multipleValues } = options;
      const valuesMessage = multipleValues ? `received values of types ${[
        ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
      ].join(", ")}` : `received value of type \`${is(value)}\``;
      throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
  };
  exports.assert = {
    // Unknowns.
    undefined: (value) => assertType(is.undefined(value), "undefined", value),
    string: (value) => assertType(is.string(value), "string", value),
    number: (value) => assertType(is.number(value), "number", value),
    bigint: (value) => assertType(is.bigint(value), "bigint", value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value) => assertType(is.function_(value), "Function", value),
    null_: (value) => assertType(is.null_(value), "null", value),
    class_: (value) => assertType(is.class_(value), "Class", value),
    boolean: (value) => assertType(is.boolean(value), "boolean", value),
    symbol: (value) => assertType(is.symbol(value), "symbol", value),
    numericString: (value) => assertType(is.numericString(value), "string with a number", value),
    array: (value, assertion) => {
      const assert = assertType;
      assert(is.array(value), "Array", value);
      if (assertion) {
        value.forEach(assertion);
      }
    },
    buffer: (value) => assertType(is.buffer(value), "Buffer", value),
    blob: (value) => assertType(is.blob(value), "Blob", value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
    object: (value) => assertType(is.object(value), "Object", value),
    iterable: (value) => assertType(is.iterable(value), "Iterable", value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
    generator: (value) => assertType(is.generator(value), "Generator", value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
    promise: (value) => assertType(is.promise(value), "Promise", value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
    regExp: (value) => assertType(is.regExp(value), "RegExp", value),
    date: (value) => assertType(is.date(value), "Date", value),
    error: (value) => assertType(is.error(value), "Error", value),
    map: (value) => assertType(is.map(value), "Map", value),
    set: (value) => assertType(is.set(value), "Set", value),
    weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
    weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
    int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
    uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
    int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
    uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
    int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
    uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
    float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
    float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
    dataView: (value) => assertType(is.dataView(value), "DataView", value),
    enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), "EnumCase", value),
    urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
    truthy: (value) => assertType(is.truthy(value), "truthy", value),
    falsy: (value) => assertType(is.falsy(value), "falsy", value),
    nan: (value) => assertType(is.nan(value), "NaN", value),
    primitive: (value) => assertType(is.primitive(value), "primitive", value),
    integer: (value) => assertType(is.integer(value), "integer", value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
    domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
    observable: (value) => assertType(is.observable(value), "Observable", value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
    infinite: (value) => assertType(is.infinite(value), "infinite number", value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
    nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
    propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
    formData: (value) => assertType(is.formData(value), "FormData", value),
    urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
    // Numbers.
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
    // Two arguments.
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
    inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
    // Variadic functions.
    any: (predicate, ...values2) => {
      return assertType(is.any(predicate, ...values2), "predicate returns truthy for any value", values2, { multipleValues: true });
    },
    all: (predicate, ...values2) => assertType(is.all(predicate, ...values2), "predicate returns truthy for all values", values2, { multipleValues: true })
  };
  Object.defineProperties(is, {
    class: {
      value: is.class_
    },
    function: {
      value: is.function_
    },
    null: {
      value: is.null_
    }
  });
  Object.defineProperties(exports.assert, {
    class: {
      value: exports.assert.class_
    },
    function: {
      value: exports.assert.function_
    },
    null: {
      value: exports.assert.null_
    }
  });
  exports.default = is;
  module.exports = is;
  module.exports.default = is;
  module.exports.assert = exports.assert;
})(dist, dist.exports);
var distExports = dist.exports;
const grinning = {
  keywords: [
    "face",
    "smile",
    "happy",
    "joy",
    ":D",
    "grin"
  ],
  char: "😀",
  fitzpatrick_scale: false,
  category: "people"
};
const grimacing = {
  keywords: [
    "face",
    "grimace",
    "teeth"
  ],
  char: "😬",
  fitzpatrick_scale: false,
  category: "people"
};
const grin = {
  keywords: [
    "face",
    "happy",
    "smile",
    "joy",
    "kawaii"
  ],
  char: "😁",
  fitzpatrick_scale: false,
  category: "people"
};
const joy = {
  keywords: [
    "face",
    "cry",
    "tears",
    "weep",
    "happy",
    "happytears",
    "haha"
  ],
  char: "😂",
  fitzpatrick_scale: false,
  category: "people"
};
const rofl = {
  keywords: [
    "face",
    "rolling",
    "floor",
    "laughing",
    "lol",
    "haha"
  ],
  char: "🤣",
  fitzpatrick_scale: false,
  category: "people"
};
const partying = {
  keywords: [
    "face",
    "celebration",
    "woohoo"
  ],
  char: "🥳",
  fitzpatrick_scale: false,
  category: "people"
};
const smiley = {
  keywords: [
    "face",
    "happy",
    "joy",
    "haha",
    ":D",
    ":)",
    "smile",
    "funny"
  ],
  char: "😃",
  fitzpatrick_scale: false,
  category: "people"
};
const smile = {
  keywords: [
    "face",
    "happy",
    "joy",
    "funny",
    "haha",
    "laugh",
    "like",
    ":D",
    ":)"
  ],
  char: "😄",
  fitzpatrick_scale: false,
  category: "people"
};
const sweat_smile = {
  keywords: [
    "face",
    "hot",
    "happy",
    "laugh",
    "sweat",
    "smile",
    "relief"
  ],
  char: "😅",
  fitzpatrick_scale: false,
  category: "people"
};
const laughing = {
  keywords: [
    "happy",
    "joy",
    "lol",
    "satisfied",
    "haha",
    "face",
    "glad",
    "XD",
    "laugh"
  ],
  char: "😆",
  fitzpatrick_scale: false,
  category: "people"
};
const innocent = {
  keywords: [
    "face",
    "angel",
    "heaven",
    "halo"
  ],
  char: "😇",
  fitzpatrick_scale: false,
  category: "people"
};
const wink = {
  keywords: [
    "face",
    "happy",
    "mischievous",
    "secret",
    ";)",
    "smile",
    "eye"
  ],
  char: "😉",
  fitzpatrick_scale: false,
  category: "people"
};
const blush = {
  keywords: [
    "face",
    "smile",
    "happy",
    "flushed",
    "crush",
    "embarrassed",
    "shy",
    "joy"
  ],
  char: "😊",
  fitzpatrick_scale: false,
  category: "people"
};
const slightly_smiling_face = {
  keywords: [
    "face",
    "smile"
  ],
  char: "🙂",
  fitzpatrick_scale: false,
  category: "people"
};
const upside_down_face = {
  keywords: [
    "face",
    "flipped",
    "silly",
    "smile"
  ],
  char: "🙃",
  fitzpatrick_scale: false,
  category: "people"
};
const relaxed = {
  keywords: [
    "face",
    "blush",
    "massage",
    "happiness"
  ],
  char: "☺️",
  fitzpatrick_scale: false,
  category: "people"
};
const yum = {
  keywords: [
    "happy",
    "joy",
    "tongue",
    "smile",
    "face",
    "silly",
    "yummy",
    "nom",
    "delicious",
    "savouring"
  ],
  char: "😋",
  fitzpatrick_scale: false,
  category: "people"
};
const relieved = {
  keywords: [
    "face",
    "relaxed",
    "phew",
    "massage",
    "happiness"
  ],
  char: "😌",
  fitzpatrick_scale: false,
  category: "people"
};
const heart_eyes = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "crush",
    "heart"
  ],
  char: "😍",
  fitzpatrick_scale: false,
  category: "people"
};
const smiling_face_with_three_hearts = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "crush",
    "hearts",
    "adore"
  ],
  char: "🥰",
  fitzpatrick_scale: false,
  category: "people"
};
const kissing_heart = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "😘",
  fitzpatrick_scale: false,
  category: "people"
};
const kissing = {
  keywords: [
    "love",
    "like",
    "face",
    "3",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "😗",
  fitzpatrick_scale: false,
  category: "people"
};
const kissing_smiling_eyes = {
  keywords: [
    "face",
    "affection",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "😙",
  fitzpatrick_scale: false,
  category: "people"
};
const kissing_closed_eyes = {
  keywords: [
    "face",
    "love",
    "like",
    "affection",
    "valentines",
    "infatuation",
    "kiss"
  ],
  char: "😚",
  fitzpatrick_scale: false,
  category: "people"
};
const stuck_out_tongue_winking_eye = {
  keywords: [
    "face",
    "prank",
    "childish",
    "playful",
    "mischievous",
    "smile",
    "wink",
    "tongue"
  ],
  char: "😜",
  fitzpatrick_scale: false,
  category: "people"
};
const zany = {
  keywords: [
    "face",
    "goofy",
    "crazy"
  ],
  char: "🤪",
  fitzpatrick_scale: false,
  category: "people"
};
const raised_eyebrow = {
  keywords: [
    "face",
    "distrust",
    "scepticism",
    "disapproval",
    "disbelief",
    "surprise"
  ],
  char: "🤨",
  fitzpatrick_scale: false,
  category: "people"
};
const monocle = {
  keywords: [
    "face",
    "stuffy",
    "wealthy"
  ],
  char: "🧐",
  fitzpatrick_scale: false,
  category: "people"
};
const stuck_out_tongue_closed_eyes = {
  keywords: [
    "face",
    "prank",
    "playful",
    "mischievous",
    "smile",
    "tongue"
  ],
  char: "😝",
  fitzpatrick_scale: false,
  category: "people"
};
const stuck_out_tongue = {
  keywords: [
    "face",
    "prank",
    "childish",
    "playful",
    "mischievous",
    "smile",
    "tongue"
  ],
  char: "😛",
  fitzpatrick_scale: false,
  category: "people"
};
const money_mouth_face = {
  keywords: [
    "face",
    "rich",
    "dollar",
    "money"
  ],
  char: "🤑",
  fitzpatrick_scale: false,
  category: "people"
};
const nerd_face = {
  keywords: [
    "face",
    "nerdy",
    "geek",
    "dork"
  ],
  char: "🤓",
  fitzpatrick_scale: false,
  category: "people"
};
const sunglasses = {
  keywords: [
    "face",
    "cool",
    "smile",
    "summer",
    "beach",
    "sunglass"
  ],
  char: "😎",
  fitzpatrick_scale: false,
  category: "people"
};
const star_struck = {
  keywords: [
    "face",
    "smile",
    "starry",
    "eyes",
    "grinning"
  ],
  char: "🤩",
  fitzpatrick_scale: false,
  category: "people"
};
const clown_face = {
  keywords: [
    "face"
  ],
  char: "🤡",
  fitzpatrick_scale: false,
  category: "people"
};
const cowboy_hat_face = {
  keywords: [
    "face",
    "cowgirl",
    "hat"
  ],
  char: "🤠",
  fitzpatrick_scale: false,
  category: "people"
};
const hugs = {
  keywords: [
    "face",
    "smile",
    "hug"
  ],
  char: "🤗",
  fitzpatrick_scale: false,
  category: "people"
};
const smirk = {
  keywords: [
    "face",
    "smile",
    "mean",
    "prank",
    "smug",
    "sarcasm"
  ],
  char: "😏",
  fitzpatrick_scale: false,
  category: "people"
};
const no_mouth = {
  keywords: [
    "face",
    "hellokitty"
  ],
  char: "😶",
  fitzpatrick_scale: false,
  category: "people"
};
const neutral_face = {
  keywords: [
    "indifference",
    "meh",
    ":|",
    "neutral"
  ],
  char: "😐",
  fitzpatrick_scale: false,
  category: "people"
};
const expressionless = {
  keywords: [
    "face",
    "indifferent",
    "-_-",
    "meh",
    "deadpan"
  ],
  char: "😑",
  fitzpatrick_scale: false,
  category: "people"
};
const unamused = {
  keywords: [
    "indifference",
    "bored",
    "straight face",
    "serious",
    "sarcasm",
    "unimpressed",
    "skeptical",
    "dubious",
    "side_eye"
  ],
  char: "😒",
  fitzpatrick_scale: false,
  category: "people"
};
const roll_eyes = {
  keywords: [
    "face",
    "eyeroll",
    "frustrated"
  ],
  char: "🙄",
  fitzpatrick_scale: false,
  category: "people"
};
const thinking = {
  keywords: [
    "face",
    "hmmm",
    "think",
    "consider"
  ],
  char: "🤔",
  fitzpatrick_scale: false,
  category: "people"
};
const lying_face = {
  keywords: [
    "face",
    "lie",
    "pinocchio"
  ],
  char: "🤥",
  fitzpatrick_scale: false,
  category: "people"
};
const hand_over_mouth = {
  keywords: [
    "face",
    "whoops",
    "shock",
    "surprise"
  ],
  char: "🤭",
  fitzpatrick_scale: false,
  category: "people"
};
const shushing = {
  keywords: [
    "face",
    "quiet",
    "shhh"
  ],
  char: "🤫",
  fitzpatrick_scale: false,
  category: "people"
};
const symbols_over_mouth = {
  keywords: [
    "face",
    "swearing",
    "cursing",
    "cussing",
    "profanity",
    "expletive"
  ],
  char: "🤬",
  fitzpatrick_scale: false,
  category: "people"
};
const exploding_head = {
  keywords: [
    "face",
    "shocked",
    "mind",
    "blown"
  ],
  char: "🤯",
  fitzpatrick_scale: false,
  category: "people"
};
const flushed = {
  keywords: [
    "face",
    "blush",
    "shy",
    "flattered"
  ],
  char: "😳",
  fitzpatrick_scale: false,
  category: "people"
};
const disappointed = {
  keywords: [
    "face",
    "sad",
    "upset",
    "depressed",
    ":("
  ],
  char: "😞",
  fitzpatrick_scale: false,
  category: "people"
};
const worried = {
  keywords: [
    "face",
    "concern",
    "nervous",
    ":("
  ],
  char: "😟",
  fitzpatrick_scale: false,
  category: "people"
};
const angry = {
  keywords: [
    "mad",
    "face",
    "annoyed",
    "frustrated"
  ],
  char: "😠",
  fitzpatrick_scale: false,
  category: "people"
};
const rage = {
  keywords: [
    "angry",
    "mad",
    "hate",
    "despise"
  ],
  char: "😡",
  fitzpatrick_scale: false,
  category: "people"
};
const pensive = {
  keywords: [
    "face",
    "sad",
    "depressed",
    "upset"
  ],
  char: "😔",
  fitzpatrick_scale: false,
  category: "people"
};
const confused = {
  keywords: [
    "face",
    "indifference",
    "huh",
    "weird",
    "hmmm",
    ":/"
  ],
  char: "😕",
  fitzpatrick_scale: false,
  category: "people"
};
const slightly_frowning_face = {
  keywords: [
    "face",
    "frowning",
    "disappointed",
    "sad",
    "upset"
  ],
  char: "🙁",
  fitzpatrick_scale: false,
  category: "people"
};
const frowning_face = {
  keywords: [
    "face",
    "sad",
    "upset",
    "frown"
  ],
  char: "☹",
  fitzpatrick_scale: false,
  category: "people"
};
const persevere = {
  keywords: [
    "face",
    "sick",
    "no",
    "upset",
    "oops"
  ],
  char: "😣",
  fitzpatrick_scale: false,
  category: "people"
};
const confounded = {
  keywords: [
    "face",
    "confused",
    "sick",
    "unwell",
    "oops",
    ":S"
  ],
  char: "😖",
  fitzpatrick_scale: false,
  category: "people"
};
const tired_face = {
  keywords: [
    "sick",
    "whine",
    "upset",
    "frustrated"
  ],
  char: "😫",
  fitzpatrick_scale: false,
  category: "people"
};
const weary = {
  keywords: [
    "face",
    "tired",
    "sleepy",
    "sad",
    "frustrated",
    "upset"
  ],
  char: "😩",
  fitzpatrick_scale: false,
  category: "people"
};
const pleading = {
  keywords: [
    "face",
    "begging",
    "mercy"
  ],
  char: "🥺",
  fitzpatrick_scale: false,
  category: "people"
};
const triumph = {
  keywords: [
    "face",
    "gas",
    "phew",
    "proud",
    "pride"
  ],
  char: "😤",
  fitzpatrick_scale: false,
  category: "people"
};
const open_mouth = {
  keywords: [
    "face",
    "surprise",
    "impressed",
    "wow",
    "whoa",
    ":O"
  ],
  char: "😮",
  fitzpatrick_scale: false,
  category: "people"
};
const scream = {
  keywords: [
    "face",
    "munch",
    "scared",
    "omg"
  ],
  char: "😱",
  fitzpatrick_scale: false,
  category: "people"
};
const fearful = {
  keywords: [
    "face",
    "scared",
    "terrified",
    "nervous",
    "oops",
    "huh"
  ],
  char: "😨",
  fitzpatrick_scale: false,
  category: "people"
};
const cold_sweat = {
  keywords: [
    "face",
    "nervous",
    "sweat"
  ],
  char: "😰",
  fitzpatrick_scale: false,
  category: "people"
};
const hushed = {
  keywords: [
    "face",
    "woo",
    "shh"
  ],
  char: "😯",
  fitzpatrick_scale: false,
  category: "people"
};
const frowning = {
  keywords: [
    "face",
    "aw",
    "what"
  ],
  char: "😦",
  fitzpatrick_scale: false,
  category: "people"
};
const anguished = {
  keywords: [
    "face",
    "stunned",
    "nervous"
  ],
  char: "😧",
  fitzpatrick_scale: false,
  category: "people"
};
const cry = {
  keywords: [
    "face",
    "tears",
    "sad",
    "depressed",
    "upset",
    ":'("
  ],
  char: "😢",
  fitzpatrick_scale: false,
  category: "people"
};
const disappointed_relieved = {
  keywords: [
    "face",
    "phew",
    "sweat",
    "nervous"
  ],
  char: "😥",
  fitzpatrick_scale: false,
  category: "people"
};
const drooling_face = {
  keywords: [
    "face"
  ],
  char: "🤤",
  fitzpatrick_scale: false,
  category: "people"
};
const sleepy = {
  keywords: [
    "face",
    "tired",
    "rest",
    "nap"
  ],
  char: "😪",
  fitzpatrick_scale: false,
  category: "people"
};
const sweat = {
  keywords: [
    "face",
    "hot",
    "sad",
    "tired",
    "exercise"
  ],
  char: "😓",
  fitzpatrick_scale: false,
  category: "people"
};
const hot = {
  keywords: [
    "face",
    "feverish",
    "heat",
    "red",
    "sweating"
  ],
  char: "🥵",
  fitzpatrick_scale: false,
  category: "people"
};
const cold = {
  keywords: [
    "face",
    "blue",
    "freezing",
    "frozen",
    "frostbite",
    "icicles"
  ],
  char: "🥶",
  fitzpatrick_scale: false,
  category: "people"
};
const sob = {
  keywords: [
    "face",
    "cry",
    "tears",
    "sad",
    "upset",
    "depressed"
  ],
  char: "😭",
  fitzpatrick_scale: false,
  category: "people"
};
const dizzy_face = {
  keywords: [
    "spent",
    "unconscious",
    "xox",
    "dizzy"
  ],
  char: "😵",
  fitzpatrick_scale: false,
  category: "people"
};
const astonished = {
  keywords: [
    "face",
    "xox",
    "surprised",
    "poisoned"
  ],
  char: "😲",
  fitzpatrick_scale: false,
  category: "people"
};
const zipper_mouth_face = {
  keywords: [
    "face",
    "sealed",
    "zipper",
    "secret"
  ],
  char: "🤐",
  fitzpatrick_scale: false,
  category: "people"
};
const nauseated_face = {
  keywords: [
    "face",
    "vomit",
    "gross",
    "green",
    "sick",
    "throw up",
    "ill"
  ],
  char: "🤢",
  fitzpatrick_scale: false,
  category: "people"
};
const sneezing_face = {
  keywords: [
    "face",
    "gesundheit",
    "sneeze",
    "sick",
    "allergy"
  ],
  char: "🤧",
  fitzpatrick_scale: false,
  category: "people"
};
const vomiting = {
  keywords: [
    "face",
    "sick"
  ],
  char: "🤮",
  fitzpatrick_scale: false,
  category: "people"
};
const mask = {
  keywords: [
    "face",
    "sick",
    "ill",
    "disease"
  ],
  char: "😷",
  fitzpatrick_scale: false,
  category: "people"
};
const face_with_thermometer = {
  keywords: [
    "sick",
    "temperature",
    "thermometer",
    "cold",
    "fever"
  ],
  char: "🤒",
  fitzpatrick_scale: false,
  category: "people"
};
const face_with_head_bandage = {
  keywords: [
    "injured",
    "clumsy",
    "bandage",
    "hurt"
  ],
  char: "🤕",
  fitzpatrick_scale: false,
  category: "people"
};
const woozy = {
  keywords: [
    "face",
    "dizzy",
    "intoxicated",
    "tipsy",
    "wavy"
  ],
  char: "🥴",
  fitzpatrick_scale: false,
  category: "people"
};
const sleeping = {
  keywords: [
    "face",
    "tired",
    "sleepy",
    "night",
    "zzz"
  ],
  char: "😴",
  fitzpatrick_scale: false,
  category: "people"
};
const zzz = {
  keywords: [
    "sleepy",
    "tired",
    "dream"
  ],
  char: "💤",
  fitzpatrick_scale: false,
  category: "people"
};
const poop = {
  keywords: [
    "hankey",
    "shitface",
    "fail",
    "turd",
    "shit"
  ],
  char: "💩",
  fitzpatrick_scale: false,
  category: "people"
};
const smiling_imp = {
  keywords: [
    "devil",
    "horns"
  ],
  char: "😈",
  fitzpatrick_scale: false,
  category: "people"
};
const imp = {
  keywords: [
    "devil",
    "angry",
    "horns"
  ],
  char: "👿",
  fitzpatrick_scale: false,
  category: "people"
};
const japanese_ogre = {
  keywords: [
    "monster",
    "red",
    "mask",
    "halloween",
    "scary",
    "creepy",
    "devil",
    "demon",
    "japanese",
    "ogre"
  ],
  char: "👹",
  fitzpatrick_scale: false,
  category: "people"
};
const japanese_goblin = {
  keywords: [
    "red",
    "evil",
    "mask",
    "monster",
    "scary",
    "creepy",
    "japanese",
    "goblin"
  ],
  char: "👺",
  fitzpatrick_scale: false,
  category: "people"
};
const skull = {
  keywords: [
    "dead",
    "skeleton",
    "creepy",
    "death"
  ],
  char: "💀",
  fitzpatrick_scale: false,
  category: "people"
};
const ghost = {
  keywords: [
    "halloween",
    "spooky",
    "scary"
  ],
  char: "👻",
  fitzpatrick_scale: false,
  category: "people"
};
const alien = {
  keywords: [
    "UFO",
    "paul",
    "weird",
    "outer_space"
  ],
  char: "👽",
  fitzpatrick_scale: false,
  category: "people"
};
const robot = {
  keywords: [
    "computer",
    "machine",
    "bot"
  ],
  char: "🤖",
  fitzpatrick_scale: false,
  category: "people"
};
const smiley_cat = {
  keywords: [
    "animal",
    "cats",
    "happy",
    "smile"
  ],
  char: "😺",
  fitzpatrick_scale: false,
  category: "people"
};
const smile_cat = {
  keywords: [
    "animal",
    "cats",
    "smile"
  ],
  char: "😸",
  fitzpatrick_scale: false,
  category: "people"
};
const joy_cat = {
  keywords: [
    "animal",
    "cats",
    "haha",
    "happy",
    "tears"
  ],
  char: "😹",
  fitzpatrick_scale: false,
  category: "people"
};
const heart_eyes_cat = {
  keywords: [
    "animal",
    "love",
    "like",
    "affection",
    "cats",
    "valentines",
    "heart"
  ],
  char: "😻",
  fitzpatrick_scale: false,
  category: "people"
};
const smirk_cat = {
  keywords: [
    "animal",
    "cats",
    "smirk"
  ],
  char: "😼",
  fitzpatrick_scale: false,
  category: "people"
};
const kissing_cat = {
  keywords: [
    "animal",
    "cats",
    "kiss"
  ],
  char: "😽",
  fitzpatrick_scale: false,
  category: "people"
};
const scream_cat = {
  keywords: [
    "animal",
    "cats",
    "munch",
    "scared",
    "scream"
  ],
  char: "🙀",
  fitzpatrick_scale: false,
  category: "people"
};
const crying_cat_face = {
  keywords: [
    "animal",
    "tears",
    "weep",
    "sad",
    "cats",
    "upset",
    "cry"
  ],
  char: "😿",
  fitzpatrick_scale: false,
  category: "people"
};
const pouting_cat = {
  keywords: [
    "animal",
    "cats"
  ],
  char: "😾",
  fitzpatrick_scale: false,
  category: "people"
};
const palms_up = {
  keywords: [
    "hands",
    "gesture",
    "cupped",
    "prayer"
  ],
  char: "🤲",
  fitzpatrick_scale: true,
  category: "people"
};
const raised_hands = {
  keywords: [
    "gesture",
    "hooray",
    "yea",
    "celebration",
    "hands"
  ],
  char: "🙌",
  fitzpatrick_scale: true,
  category: "people"
};
const clap = {
  keywords: [
    "hands",
    "praise",
    "applause",
    "congrats",
    "yay"
  ],
  char: "👏",
  fitzpatrick_scale: true,
  category: "people"
};
const wave = {
  keywords: [
    "hands",
    "gesture",
    "goodbye",
    "solong",
    "farewell",
    "hello",
    "hi",
    "palm"
  ],
  char: "👋",
  fitzpatrick_scale: true,
  category: "people"
};
const call_me_hand = {
  keywords: [
    "hands",
    "gesture"
  ],
  char: "🤙",
  fitzpatrick_scale: true,
  category: "people"
};
const facepunch = {
  keywords: [
    "angry",
    "violence",
    "fist",
    "hit",
    "attack",
    "hand"
  ],
  char: "👊",
  fitzpatrick_scale: true,
  category: "people"
};
const fist = {
  keywords: [
    "fingers",
    "hand",
    "grasp"
  ],
  char: "✊",
  fitzpatrick_scale: true,
  category: "people"
};
const fist_left = {
  keywords: [
    "hand",
    "fistbump"
  ],
  char: "🤛",
  fitzpatrick_scale: true,
  category: "people"
};
const fist_right = {
  keywords: [
    "hand",
    "fistbump"
  ],
  char: "🤜",
  fitzpatrick_scale: true,
  category: "people"
};
const v = {
  keywords: [
    "fingers",
    "ohyeah",
    "hand",
    "peace",
    "victory",
    "two"
  ],
  char: "✌",
  fitzpatrick_scale: true,
  category: "people"
};
const ok_hand = {
  keywords: [
    "fingers",
    "limbs",
    "perfect",
    "ok",
    "okay"
  ],
  char: "👌",
  fitzpatrick_scale: true,
  category: "people"
};
const raised_hand = {
  keywords: [
    "fingers",
    "stop",
    "highfive",
    "palm",
    "ban"
  ],
  char: "✋",
  fitzpatrick_scale: true,
  category: "people"
};
const raised_back_of_hand = {
  keywords: [
    "fingers",
    "raised",
    "backhand"
  ],
  char: "🤚",
  fitzpatrick_scale: true,
  category: "people"
};
const open_hands = {
  keywords: [
    "fingers",
    "butterfly",
    "hands",
    "open"
  ],
  char: "👐",
  fitzpatrick_scale: true,
  category: "people"
};
const muscle = {
  keywords: [
    "arm",
    "flex",
    "hand",
    "summer",
    "strong",
    "biceps"
  ],
  char: "💪",
  fitzpatrick_scale: true,
  category: "people"
};
const pray = {
  keywords: [
    "please",
    "hope",
    "wish",
    "namaste",
    "highfive"
  ],
  char: "🙏",
  fitzpatrick_scale: true,
  category: "people"
};
const foot = {
  keywords: [
    "kick",
    "stomp"
  ],
  char: "🦶",
  fitzpatrick_scale: true,
  category: "people"
};
const leg = {
  keywords: [
    "kick",
    "limb"
  ],
  char: "🦵",
  fitzpatrick_scale: true,
  category: "people"
};
const handshake = {
  keywords: [
    "agreement",
    "shake"
  ],
  char: "🤝",
  fitzpatrick_scale: false,
  category: "people"
};
const point_up = {
  keywords: [
    "hand",
    "fingers",
    "direction",
    "up"
  ],
  char: "☝",
  fitzpatrick_scale: true,
  category: "people"
};
const point_up_2 = {
  keywords: [
    "fingers",
    "hand",
    "direction",
    "up"
  ],
  char: "👆",
  fitzpatrick_scale: true,
  category: "people"
};
const point_down = {
  keywords: [
    "fingers",
    "hand",
    "direction",
    "down"
  ],
  char: "👇",
  fitzpatrick_scale: true,
  category: "people"
};
const point_left = {
  keywords: [
    "direction",
    "fingers",
    "hand",
    "left"
  ],
  char: "👈",
  fitzpatrick_scale: true,
  category: "people"
};
const point_right = {
  keywords: [
    "fingers",
    "hand",
    "direction",
    "right"
  ],
  char: "👉",
  fitzpatrick_scale: true,
  category: "people"
};
const fu = {
  keywords: [
    "hand",
    "fingers",
    "rude",
    "middle",
    "flipping"
  ],
  char: "🖕",
  fitzpatrick_scale: true,
  category: "people"
};
const raised_hand_with_fingers_splayed = {
  keywords: [
    "hand",
    "fingers",
    "palm"
  ],
  char: "🖐",
  fitzpatrick_scale: true,
  category: "people"
};
const love_you = {
  keywords: [
    "hand",
    "fingers",
    "gesture"
  ],
  char: "🤟",
  fitzpatrick_scale: true,
  category: "people"
};
const metal = {
  keywords: [
    "hand",
    "fingers",
    "evil_eye",
    "sign_of_horns",
    "rock_on"
  ],
  char: "🤘",
  fitzpatrick_scale: true,
  category: "people"
};
const crossed_fingers = {
  keywords: [
    "good",
    "lucky"
  ],
  char: "🤞",
  fitzpatrick_scale: true,
  category: "people"
};
const vulcan_salute = {
  keywords: [
    "hand",
    "fingers",
    "spock",
    "star trek"
  ],
  char: "🖖",
  fitzpatrick_scale: true,
  category: "people"
};
const writing_hand = {
  keywords: [
    "lower_left_ballpoint_pen",
    "stationery",
    "write",
    "compose"
  ],
  char: "✍",
  fitzpatrick_scale: true,
  category: "people"
};
const selfie = {
  keywords: [
    "camera",
    "phone"
  ],
  char: "🤳",
  fitzpatrick_scale: true,
  category: "people"
};
const nail_care = {
  keywords: [
    "beauty",
    "manicure",
    "finger",
    "fashion",
    "nail"
  ],
  char: "💅",
  fitzpatrick_scale: true,
  category: "people"
};
const lips = {
  keywords: [
    "mouth",
    "kiss"
  ],
  char: "👄",
  fitzpatrick_scale: false,
  category: "people"
};
const tooth = {
  keywords: [
    "teeth",
    "dentist"
  ],
  char: "🦷",
  fitzpatrick_scale: false,
  category: "people"
};
const tongue = {
  keywords: [
    "mouth",
    "playful"
  ],
  char: "👅",
  fitzpatrick_scale: false,
  category: "people"
};
const ear = {
  keywords: [
    "face",
    "hear",
    "sound",
    "listen"
  ],
  char: "👂",
  fitzpatrick_scale: true,
  category: "people"
};
const nose = {
  keywords: [
    "smell",
    "sniff"
  ],
  char: "👃",
  fitzpatrick_scale: true,
  category: "people"
};
const eye = {
  keywords: [
    "face",
    "look",
    "see",
    "watch",
    "stare"
  ],
  char: "👁",
  fitzpatrick_scale: false,
  category: "people"
};
const eyes = {
  keywords: [
    "look",
    "watch",
    "stalk",
    "peek",
    "see"
  ],
  char: "👀",
  fitzpatrick_scale: false,
  category: "people"
};
const brain = {
  keywords: [
    "smart",
    "intelligent"
  ],
  char: "🧠",
  fitzpatrick_scale: false,
  category: "people"
};
const bust_in_silhouette = {
  keywords: [
    "user",
    "person",
    "human"
  ],
  char: "👤",
  fitzpatrick_scale: false,
  category: "people"
};
const busts_in_silhouette = {
  keywords: [
    "user",
    "person",
    "human",
    "group",
    "team"
  ],
  char: "👥",
  fitzpatrick_scale: false,
  category: "people"
};
const speaking_head = {
  keywords: [
    "user",
    "person",
    "human",
    "sing",
    "say",
    "talk"
  ],
  char: "🗣",
  fitzpatrick_scale: false,
  category: "people"
};
const baby = {
  keywords: [
    "child",
    "boy",
    "girl",
    "toddler"
  ],
  char: "👶",
  fitzpatrick_scale: true,
  category: "people"
};
const child = {
  keywords: [
    "gender-neutral",
    "young"
  ],
  char: "🧒",
  fitzpatrick_scale: true,
  category: "people"
};
const boy = {
  keywords: [
    "man",
    "male",
    "guy",
    "teenager"
  ],
  char: "👦",
  fitzpatrick_scale: true,
  category: "people"
};
const girl = {
  keywords: [
    "female",
    "woman",
    "teenager"
  ],
  char: "👧",
  fitzpatrick_scale: true,
  category: "people"
};
const adult = {
  keywords: [
    "gender-neutral",
    "person"
  ],
  char: "🧑",
  fitzpatrick_scale: true,
  category: "people"
};
const man = {
  keywords: [
    "mustache",
    "father",
    "dad",
    "guy",
    "classy",
    "sir",
    "moustache"
  ],
  char: "👨",
  fitzpatrick_scale: true,
  category: "people"
};
const woman = {
  keywords: [
    "female",
    "girls",
    "lady"
  ],
  char: "👩",
  fitzpatrick_scale: true,
  category: "people"
};
const blonde_woman = {
  keywords: [
    "woman",
    "female",
    "girl",
    "blonde",
    "person"
  ],
  char: "👱‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const blonde_man = {
  keywords: [
    "man",
    "male",
    "boy",
    "blonde",
    "guy",
    "person"
  ],
  char: "👱",
  fitzpatrick_scale: true,
  category: "people"
};
const bearded_person = {
  keywords: [
    "person",
    "bewhiskered"
  ],
  char: "🧔",
  fitzpatrick_scale: true,
  category: "people"
};
const older_adult = {
  keywords: [
    "human",
    "elder",
    "senior",
    "gender-neutral"
  ],
  char: "🧓",
  fitzpatrick_scale: true,
  category: "people"
};
const older_man = {
  keywords: [
    "human",
    "male",
    "men",
    "old",
    "elder",
    "senior"
  ],
  char: "👴",
  fitzpatrick_scale: true,
  category: "people"
};
const older_woman = {
  keywords: [
    "human",
    "female",
    "women",
    "lady",
    "old",
    "elder",
    "senior"
  ],
  char: "👵",
  fitzpatrick_scale: true,
  category: "people"
};
const man_with_gua_pi_mao = {
  keywords: [
    "male",
    "boy",
    "chinese"
  ],
  char: "👲",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_with_headscarf = {
  keywords: [
    "female",
    "hijab",
    "mantilla",
    "tichel"
  ],
  char: "🧕",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_with_turban = {
  keywords: [
    "female",
    "indian",
    "hinduism",
    "arabs",
    "woman"
  ],
  char: "👳‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_with_turban = {
  keywords: [
    "male",
    "indian",
    "hinduism",
    "arabs"
  ],
  char: "👳",
  fitzpatrick_scale: true,
  category: "people"
};
const policewoman = {
  keywords: [
    "woman",
    "police",
    "law",
    "legal",
    "enforcement",
    "arrest",
    "911",
    "female"
  ],
  char: "👮‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const policeman = {
  keywords: [
    "man",
    "police",
    "law",
    "legal",
    "enforcement",
    "arrest",
    "911"
  ],
  char: "👮",
  fitzpatrick_scale: true,
  category: "people"
};
const construction_worker_woman = {
  keywords: [
    "female",
    "human",
    "wip",
    "build",
    "construction",
    "worker",
    "labor",
    "woman"
  ],
  char: "👷‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const construction_worker_man = {
  keywords: [
    "male",
    "human",
    "wip",
    "guy",
    "build",
    "construction",
    "worker",
    "labor"
  ],
  char: "👷",
  fitzpatrick_scale: true,
  category: "people"
};
const guardswoman = {
  keywords: [
    "uk",
    "gb",
    "british",
    "female",
    "royal",
    "woman"
  ],
  char: "💂‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const guardsman = {
  keywords: [
    "uk",
    "gb",
    "british",
    "male",
    "guy",
    "royal"
  ],
  char: "💂",
  fitzpatrick_scale: true,
  category: "people"
};
const female_detective = {
  keywords: [
    "human",
    "spy",
    "detective",
    "female",
    "woman"
  ],
  char: "🕵️‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const male_detective = {
  keywords: [
    "human",
    "spy",
    "detective"
  ],
  char: "🕵",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_health_worker = {
  keywords: [
    "doctor",
    "nurse",
    "therapist",
    "healthcare",
    "woman",
    "human"
  ],
  char: "👩‍⚕️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_health_worker = {
  keywords: [
    "doctor",
    "nurse",
    "therapist",
    "healthcare",
    "man",
    "human"
  ],
  char: "👨‍⚕️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_farmer = {
  keywords: [
    "rancher",
    "gardener",
    "woman",
    "human"
  ],
  char: "👩‍🌾",
  fitzpatrick_scale: true,
  category: "people"
};
const man_farmer = {
  keywords: [
    "rancher",
    "gardener",
    "man",
    "human"
  ],
  char: "👨‍🌾",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_cook = {
  keywords: [
    "chef",
    "woman",
    "human"
  ],
  char: "👩‍🍳",
  fitzpatrick_scale: true,
  category: "people"
};
const man_cook = {
  keywords: [
    "chef",
    "man",
    "human"
  ],
  char: "👨‍🍳",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_student = {
  keywords: [
    "graduate",
    "woman",
    "human"
  ],
  char: "👩‍🎓",
  fitzpatrick_scale: true,
  category: "people"
};
const man_student = {
  keywords: [
    "graduate",
    "man",
    "human"
  ],
  char: "👨‍🎓",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_singer = {
  keywords: [
    "rockstar",
    "entertainer",
    "woman",
    "human"
  ],
  char: "👩‍🎤",
  fitzpatrick_scale: true,
  category: "people"
};
const man_singer = {
  keywords: [
    "rockstar",
    "entertainer",
    "man",
    "human"
  ],
  char: "👨‍🎤",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_teacher = {
  keywords: [
    "instructor",
    "professor",
    "woman",
    "human"
  ],
  char: "👩‍🏫",
  fitzpatrick_scale: true,
  category: "people"
};
const man_teacher = {
  keywords: [
    "instructor",
    "professor",
    "man",
    "human"
  ],
  char: "👨‍🏫",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_factory_worker = {
  keywords: [
    "assembly",
    "industrial",
    "woman",
    "human"
  ],
  char: "👩‍🏭",
  fitzpatrick_scale: true,
  category: "people"
};
const man_factory_worker = {
  keywords: [
    "assembly",
    "industrial",
    "man",
    "human"
  ],
  char: "👨‍🏭",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_technologist = {
  keywords: [
    "coder",
    "developer",
    "engineer",
    "programmer",
    "software",
    "woman",
    "human",
    "laptop",
    "computer"
  ],
  char: "👩‍💻",
  fitzpatrick_scale: true,
  category: "people"
};
const man_technologist = {
  keywords: [
    "coder",
    "developer",
    "engineer",
    "programmer",
    "software",
    "man",
    "human",
    "laptop",
    "computer"
  ],
  char: "👨‍💻",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_office_worker = {
  keywords: [
    "business",
    "manager",
    "woman",
    "human"
  ],
  char: "👩‍💼",
  fitzpatrick_scale: true,
  category: "people"
};
const man_office_worker = {
  keywords: [
    "business",
    "manager",
    "man",
    "human"
  ],
  char: "👨‍💼",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_mechanic = {
  keywords: [
    "plumber",
    "woman",
    "human",
    "wrench"
  ],
  char: "👩‍🔧",
  fitzpatrick_scale: true,
  category: "people"
};
const man_mechanic = {
  keywords: [
    "plumber",
    "man",
    "human",
    "wrench"
  ],
  char: "👨‍🔧",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_scientist = {
  keywords: [
    "biologist",
    "chemist",
    "engineer",
    "physicist",
    "woman",
    "human"
  ],
  char: "👩‍🔬",
  fitzpatrick_scale: true,
  category: "people"
};
const man_scientist = {
  keywords: [
    "biologist",
    "chemist",
    "engineer",
    "physicist",
    "man",
    "human"
  ],
  char: "👨‍🔬",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_artist = {
  keywords: [
    "painter",
    "woman",
    "human"
  ],
  char: "👩‍🎨",
  fitzpatrick_scale: true,
  category: "people"
};
const man_artist = {
  keywords: [
    "painter",
    "man",
    "human"
  ],
  char: "👨‍🎨",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_firefighter = {
  keywords: [
    "fireman",
    "woman",
    "human"
  ],
  char: "👩‍🚒",
  fitzpatrick_scale: true,
  category: "people"
};
const man_firefighter = {
  keywords: [
    "fireman",
    "man",
    "human"
  ],
  char: "👨‍🚒",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_pilot = {
  keywords: [
    "aviator",
    "plane",
    "woman",
    "human"
  ],
  char: "👩‍✈️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_pilot = {
  keywords: [
    "aviator",
    "plane",
    "man",
    "human"
  ],
  char: "👨‍✈️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_astronaut = {
  keywords: [
    "space",
    "rocket",
    "woman",
    "human"
  ],
  char: "👩‍🚀",
  fitzpatrick_scale: true,
  category: "people"
};
const man_astronaut = {
  keywords: [
    "space",
    "rocket",
    "man",
    "human"
  ],
  char: "👨‍🚀",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_judge = {
  keywords: [
    "justice",
    "court",
    "woman",
    "human"
  ],
  char: "👩‍⚖️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_judge = {
  keywords: [
    "justice",
    "court",
    "man",
    "human"
  ],
  char: "👨‍⚖️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_superhero = {
  keywords: [
    "woman",
    "female",
    "good",
    "heroine",
    "superpowers"
  ],
  char: "🦸‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_superhero = {
  keywords: [
    "man",
    "male",
    "good",
    "hero",
    "superpowers"
  ],
  char: "🦸‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_supervillain = {
  keywords: [
    "woman",
    "female",
    "evil",
    "bad",
    "criminal",
    "heroine",
    "superpowers"
  ],
  char: "🦹‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_supervillain = {
  keywords: [
    "man",
    "male",
    "evil",
    "bad",
    "criminal",
    "hero",
    "superpowers"
  ],
  char: "🦹‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const mrs_claus = {
  keywords: [
    "woman",
    "female",
    "xmas",
    "mother christmas"
  ],
  char: "🤶",
  fitzpatrick_scale: true,
  category: "people"
};
const santa = {
  keywords: [
    "festival",
    "man",
    "male",
    "xmas",
    "father christmas"
  ],
  char: "🎅",
  fitzpatrick_scale: true,
  category: "people"
};
const sorceress = {
  keywords: [
    "woman",
    "female",
    "mage",
    "witch"
  ],
  char: "🧙‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const wizard = {
  keywords: [
    "man",
    "male",
    "mage",
    "sorcerer"
  ],
  char: "🧙‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_elf = {
  keywords: [
    "woman",
    "female"
  ],
  char: "🧝‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_elf = {
  keywords: [
    "man",
    "male"
  ],
  char: "🧝‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_vampire = {
  keywords: [
    "woman",
    "female"
  ],
  char: "🧛‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_vampire = {
  keywords: [
    "man",
    "male",
    "dracula"
  ],
  char: "🧛‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_zombie = {
  keywords: [
    "woman",
    "female",
    "undead",
    "walking dead"
  ],
  char: "🧟‍♀️",
  fitzpatrick_scale: false,
  category: "people"
};
const man_zombie = {
  keywords: [
    "man",
    "male",
    "dracula",
    "undead",
    "walking dead"
  ],
  char: "🧟‍♂️",
  fitzpatrick_scale: false,
  category: "people"
};
const woman_genie = {
  keywords: [
    "woman",
    "female"
  ],
  char: "🧞‍♀️",
  fitzpatrick_scale: false,
  category: "people"
};
const man_genie = {
  keywords: [
    "man",
    "male"
  ],
  char: "🧞‍♂️",
  fitzpatrick_scale: false,
  category: "people"
};
const mermaid = {
  keywords: [
    "woman",
    "female",
    "merwoman",
    "ariel"
  ],
  char: "🧜‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const merman = {
  keywords: [
    "man",
    "male",
    "triton"
  ],
  char: "🧜‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_fairy = {
  keywords: [
    "woman",
    "female"
  ],
  char: "🧚‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_fairy = {
  keywords: [
    "man",
    "male"
  ],
  char: "🧚‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const angel = {
  keywords: [
    "heaven",
    "wings",
    "halo"
  ],
  char: "👼",
  fitzpatrick_scale: true,
  category: "people"
};
const pregnant_woman = {
  keywords: [
    "baby"
  ],
  char: "🤰",
  fitzpatrick_scale: true,
  category: "people"
};
const breastfeeding = {
  keywords: [
    "nursing",
    "baby"
  ],
  char: "🤱",
  fitzpatrick_scale: true,
  category: "people"
};
const princess = {
  keywords: [
    "girl",
    "woman",
    "female",
    "blond",
    "crown",
    "royal",
    "queen"
  ],
  char: "👸",
  fitzpatrick_scale: true,
  category: "people"
};
const prince = {
  keywords: [
    "boy",
    "man",
    "male",
    "crown",
    "royal",
    "king"
  ],
  char: "🤴",
  fitzpatrick_scale: true,
  category: "people"
};
const bride_with_veil = {
  keywords: [
    "couple",
    "marriage",
    "wedding",
    "woman",
    "bride"
  ],
  char: "👰",
  fitzpatrick_scale: true,
  category: "people"
};
const man_in_tuxedo = {
  keywords: [
    "couple",
    "marriage",
    "wedding",
    "groom"
  ],
  char: "🤵",
  fitzpatrick_scale: true,
  category: "people"
};
const running_woman = {
  keywords: [
    "woman",
    "walking",
    "exercise",
    "race",
    "running",
    "female"
  ],
  char: "🏃‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const running_man = {
  keywords: [
    "man",
    "walking",
    "exercise",
    "race",
    "running"
  ],
  char: "🏃",
  fitzpatrick_scale: true,
  category: "people"
};
const walking_woman = {
  keywords: [
    "human",
    "feet",
    "steps",
    "woman",
    "female"
  ],
  char: "🚶‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const walking_man = {
  keywords: [
    "human",
    "feet",
    "steps"
  ],
  char: "🚶",
  fitzpatrick_scale: true,
  category: "people"
};
const dancer = {
  keywords: [
    "female",
    "girl",
    "woman",
    "fun"
  ],
  char: "💃",
  fitzpatrick_scale: true,
  category: "people"
};
const man_dancing = {
  keywords: [
    "male",
    "boy",
    "fun",
    "dancer"
  ],
  char: "🕺",
  fitzpatrick_scale: true,
  category: "people"
};
const dancing_women = {
  keywords: [
    "female",
    "bunny",
    "women",
    "girls"
  ],
  char: "👯",
  fitzpatrick_scale: false,
  category: "people"
};
const dancing_men = {
  keywords: [
    "male",
    "bunny",
    "men",
    "boys"
  ],
  char: "👯‍♂️",
  fitzpatrick_scale: false,
  category: "people"
};
const couple = {
  keywords: [
    "pair",
    "people",
    "human",
    "love",
    "date",
    "dating",
    "like",
    "affection",
    "valentines",
    "marriage"
  ],
  char: "👫",
  fitzpatrick_scale: false,
  category: "people"
};
const two_men_holding_hands = {
  keywords: [
    "pair",
    "couple",
    "love",
    "like",
    "bromance",
    "friendship",
    "people",
    "human"
  ],
  char: "👬",
  fitzpatrick_scale: false,
  category: "people"
};
const two_women_holding_hands = {
  keywords: [
    "pair",
    "friendship",
    "couple",
    "love",
    "like",
    "female",
    "people",
    "human"
  ],
  char: "👭",
  fitzpatrick_scale: false,
  category: "people"
};
const bowing_woman = {
  keywords: [
    "woman",
    "female",
    "girl"
  ],
  char: "🙇‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const bowing_man = {
  keywords: [
    "man",
    "male",
    "boy"
  ],
  char: "🙇",
  fitzpatrick_scale: true,
  category: "people"
};
const man_facepalming = {
  keywords: [
    "man",
    "male",
    "boy",
    "disbelief"
  ],
  char: "🤦‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_facepalming = {
  keywords: [
    "woman",
    "female",
    "girl",
    "disbelief"
  ],
  char: "🤦‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_shrugging = {
  keywords: [
    "woman",
    "female",
    "girl",
    "confused",
    "indifferent",
    "doubt"
  ],
  char: "🤷",
  fitzpatrick_scale: true,
  category: "people"
};
const man_shrugging = {
  keywords: [
    "man",
    "male",
    "boy",
    "confused",
    "indifferent",
    "doubt"
  ],
  char: "🤷‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const tipping_hand_woman = {
  keywords: [
    "female",
    "girl",
    "woman",
    "human",
    "information"
  ],
  char: "💁",
  fitzpatrick_scale: true,
  category: "people"
};
const tipping_hand_man = {
  keywords: [
    "male",
    "boy",
    "man",
    "human",
    "information"
  ],
  char: "💁‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const no_good_woman = {
  keywords: [
    "female",
    "girl",
    "woman",
    "nope"
  ],
  char: "🙅",
  fitzpatrick_scale: true,
  category: "people"
};
const no_good_man = {
  keywords: [
    "male",
    "boy",
    "man",
    "nope"
  ],
  char: "🙅‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const ok_woman = {
  keywords: [
    "women",
    "girl",
    "female",
    "pink",
    "human",
    "woman"
  ],
  char: "🙆",
  fitzpatrick_scale: true,
  category: "people"
};
const ok_man = {
  keywords: [
    "men",
    "boy",
    "male",
    "blue",
    "human",
    "man"
  ],
  char: "🙆‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const raising_hand_woman = {
  keywords: [
    "female",
    "girl",
    "woman"
  ],
  char: "🙋",
  fitzpatrick_scale: true,
  category: "people"
};
const raising_hand_man = {
  keywords: [
    "male",
    "boy",
    "man"
  ],
  char: "🙋‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const pouting_woman = {
  keywords: [
    "female",
    "girl",
    "woman"
  ],
  char: "🙎",
  fitzpatrick_scale: true,
  category: "people"
};
const pouting_man = {
  keywords: [
    "male",
    "boy",
    "man"
  ],
  char: "🙎‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const frowning_woman = {
  keywords: [
    "female",
    "girl",
    "woman",
    "sad",
    "depressed",
    "discouraged",
    "unhappy"
  ],
  char: "🙍",
  fitzpatrick_scale: true,
  category: "people"
};
const frowning_man = {
  keywords: [
    "male",
    "boy",
    "man",
    "sad",
    "depressed",
    "discouraged",
    "unhappy"
  ],
  char: "🙍‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const haircut_woman = {
  keywords: [
    "female",
    "girl",
    "woman"
  ],
  char: "💇",
  fitzpatrick_scale: true,
  category: "people"
};
const haircut_man = {
  keywords: [
    "male",
    "boy",
    "man"
  ],
  char: "💇‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const massage_woman = {
  keywords: [
    "female",
    "girl",
    "woman",
    "head"
  ],
  char: "💆",
  fitzpatrick_scale: true,
  category: "people"
};
const massage_man = {
  keywords: [
    "male",
    "boy",
    "man",
    "head"
  ],
  char: "💆‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const woman_in_steamy_room = {
  keywords: [
    "female",
    "woman",
    "spa",
    "steamroom",
    "sauna"
  ],
  char: "🧖‍♀️",
  fitzpatrick_scale: true,
  category: "people"
};
const man_in_steamy_room = {
  keywords: [
    "male",
    "man",
    "spa",
    "steamroom",
    "sauna"
  ],
  char: "🧖‍♂️",
  fitzpatrick_scale: true,
  category: "people"
};
const couple_with_heart_woman_man = {
  keywords: [
    "pair",
    "love",
    "like",
    "affection",
    "human",
    "dating",
    "valentines",
    "marriage"
  ],
  char: "💑",
  fitzpatrick_scale: false,
  category: "people"
};
const couple_with_heart_woman_woman = {
  keywords: [
    "pair",
    "love",
    "like",
    "affection",
    "human",
    "dating",
    "valentines",
    "marriage"
  ],
  char: "👩‍❤️‍👩",
  fitzpatrick_scale: false,
  category: "people"
};
const couple_with_heart_man_man = {
  keywords: [
    "pair",
    "love",
    "like",
    "affection",
    "human",
    "dating",
    "valentines",
    "marriage"
  ],
  char: "👨‍❤️‍👨",
  fitzpatrick_scale: false,
  category: "people"
};
const couplekiss_man_woman = {
  keywords: [
    "pair",
    "valentines",
    "love",
    "like",
    "dating",
    "marriage"
  ],
  char: "💏",
  fitzpatrick_scale: false,
  category: "people"
};
const couplekiss_woman_woman = {
  keywords: [
    "pair",
    "valentines",
    "love",
    "like",
    "dating",
    "marriage"
  ],
  char: "👩‍❤️‍💋‍👩",
  fitzpatrick_scale: false,
  category: "people"
};
const couplekiss_man_man = {
  keywords: [
    "pair",
    "valentines",
    "love",
    "like",
    "dating",
    "marriage"
  ],
  char: "👨‍❤️‍💋‍👨",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_woman_boy = {
  keywords: [
    "home",
    "parents",
    "child",
    "mom",
    "dad",
    "father",
    "mother",
    "people",
    "human"
  ],
  char: "👪",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_woman_girl = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "child"
  ],
  char: "👨‍👩‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_woman_girl_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👩‍👧‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_woman_boy_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👩‍👦‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_woman_girl_girl = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👩‍👧‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_woman_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👩‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_woman_girl = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👩‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_woman_girl_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👩‍👧‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_woman_boy_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👩‍👦‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_woman_girl_girl = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👩‍👧‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_man_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👨‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_man_girl = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👨‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_man_girl_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👨‍👧‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_man_boy_boy = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👨‍👦‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_man_girl_girl = {
  keywords: [
    "home",
    "parents",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👨‍👧‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_boy = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "👩‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_girl = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "👩‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_girl_boy = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👧‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_boy_boy = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👦‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_woman_girl_girl = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "👩‍👧‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_boy = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "👨‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_girl = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "child"
  ],
  char: "👨‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_girl_boy = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👧‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_boy_boy = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👦‍👦",
  fitzpatrick_scale: false,
  category: "people"
};
const family_man_girl_girl = {
  keywords: [
    "home",
    "parent",
    "people",
    "human",
    "children"
  ],
  char: "👨‍👧‍👧",
  fitzpatrick_scale: false,
  category: "people"
};
const yarn = {
  keywords: [
    "ball",
    "crochet",
    "knit"
  ],
  char: "🧶",
  fitzpatrick_scale: false,
  category: "people"
};
const thread = {
  keywords: [
    "needle",
    "sewing",
    "spool",
    "string"
  ],
  char: "🧵",
  fitzpatrick_scale: false,
  category: "people"
};
const coat = {
  keywords: [
    "jacket"
  ],
  char: "🧥",
  fitzpatrick_scale: false,
  category: "people"
};
const labcoat = {
  keywords: [
    "doctor",
    "experiment",
    "scientist",
    "chemist"
  ],
  char: "🥼",
  fitzpatrick_scale: false,
  category: "people"
};
const womans_clothes = {
  keywords: [
    "fashion",
    "shopping_bags",
    "female"
  ],
  char: "👚",
  fitzpatrick_scale: false,
  category: "people"
};
const tshirt = {
  keywords: [
    "fashion",
    "cloth",
    "casual",
    "shirt",
    "tee"
  ],
  char: "👕",
  fitzpatrick_scale: false,
  category: "people"
};
const jeans = {
  keywords: [
    "fashion",
    "shopping"
  ],
  char: "👖",
  fitzpatrick_scale: false,
  category: "people"
};
const necktie = {
  keywords: [
    "shirt",
    "suitup",
    "formal",
    "fashion",
    "cloth",
    "business"
  ],
  char: "👔",
  fitzpatrick_scale: false,
  category: "people"
};
const dress = {
  keywords: [
    "clothes",
    "fashion",
    "shopping"
  ],
  char: "👗",
  fitzpatrick_scale: false,
  category: "people"
};
const bikini = {
  keywords: [
    "swimming",
    "female",
    "woman",
    "girl",
    "fashion",
    "beach",
    "summer"
  ],
  char: "👙",
  fitzpatrick_scale: false,
  category: "people"
};
const kimono = {
  keywords: [
    "dress",
    "fashion",
    "women",
    "female",
    "japanese"
  ],
  char: "👘",
  fitzpatrick_scale: false,
  category: "people"
};
const lipstick = {
  keywords: [
    "female",
    "girl",
    "fashion",
    "woman"
  ],
  char: "💄",
  fitzpatrick_scale: false,
  category: "people"
};
const kiss = {
  keywords: [
    "face",
    "lips",
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💋",
  fitzpatrick_scale: false,
  category: "people"
};
const footprints = {
  keywords: [
    "feet",
    "tracking",
    "walking",
    "beach"
  ],
  char: "👣",
  fitzpatrick_scale: false,
  category: "people"
};
const flat_shoe = {
  keywords: [
    "ballet",
    "slip-on",
    "slipper"
  ],
  char: "🥿",
  fitzpatrick_scale: false,
  category: "people"
};
const high_heel = {
  keywords: [
    "fashion",
    "shoes",
    "female",
    "pumps",
    "stiletto"
  ],
  char: "👠",
  fitzpatrick_scale: false,
  category: "people"
};
const sandal = {
  keywords: [
    "shoes",
    "fashion",
    "flip flops"
  ],
  char: "👡",
  fitzpatrick_scale: false,
  category: "people"
};
const boot = {
  keywords: [
    "shoes",
    "fashion"
  ],
  char: "👢",
  fitzpatrick_scale: false,
  category: "people"
};
const mans_shoe = {
  keywords: [
    "fashion",
    "male"
  ],
  char: "👞",
  fitzpatrick_scale: false,
  category: "people"
};
const athletic_shoe = {
  keywords: [
    "shoes",
    "sports",
    "sneakers"
  ],
  char: "👟",
  fitzpatrick_scale: false,
  category: "people"
};
const hiking_boot = {
  keywords: [
    "backpacking",
    "camping",
    "hiking"
  ],
  char: "🥾",
  fitzpatrick_scale: false,
  category: "people"
};
const socks = {
  keywords: [
    "stockings",
    "clothes"
  ],
  char: "🧦",
  fitzpatrick_scale: false,
  category: "people"
};
const gloves = {
  keywords: [
    "hands",
    "winter",
    "clothes"
  ],
  char: "🧤",
  fitzpatrick_scale: false,
  category: "people"
};
const scarf = {
  keywords: [
    "neck",
    "winter",
    "clothes"
  ],
  char: "🧣",
  fitzpatrick_scale: false,
  category: "people"
};
const womans_hat = {
  keywords: [
    "fashion",
    "accessories",
    "female",
    "lady",
    "spring"
  ],
  char: "👒",
  fitzpatrick_scale: false,
  category: "people"
};
const tophat = {
  keywords: [
    "magic",
    "gentleman",
    "classy",
    "circus"
  ],
  char: "🎩",
  fitzpatrick_scale: false,
  category: "people"
};
const billed_hat = {
  keywords: [
    "cap",
    "baseball"
  ],
  char: "🧢",
  fitzpatrick_scale: false,
  category: "people"
};
const rescue_worker_helmet = {
  keywords: [
    "construction",
    "build"
  ],
  char: "⛑",
  fitzpatrick_scale: false,
  category: "people"
};
const mortar_board = {
  keywords: [
    "school",
    "college",
    "degree",
    "university",
    "graduation",
    "cap",
    "hat",
    "legal",
    "learn",
    "education"
  ],
  char: "🎓",
  fitzpatrick_scale: false,
  category: "people"
};
const crown = {
  keywords: [
    "king",
    "kod",
    "leader",
    "royalty",
    "lord"
  ],
  char: "👑",
  fitzpatrick_scale: false,
  category: "people"
};
const school_satchel = {
  keywords: [
    "student",
    "education",
    "bag",
    "backpack"
  ],
  char: "🎒",
  fitzpatrick_scale: false,
  category: "people"
};
const luggage = {
  keywords: [
    "packing",
    "travel"
  ],
  char: "🧳",
  fitzpatrick_scale: false,
  category: "people"
};
const pouch = {
  keywords: [
    "bag",
    "accessories",
    "shopping"
  ],
  char: "👝",
  fitzpatrick_scale: false,
  category: "people"
};
const purse = {
  keywords: [
    "fashion",
    "accessories",
    "money",
    "sales",
    "shopping"
  ],
  char: "👛",
  fitzpatrick_scale: false,
  category: "people"
};
const handbag = {
  keywords: [
    "fashion",
    "accessory",
    "accessories",
    "shopping"
  ],
  char: "👜",
  fitzpatrick_scale: false,
  category: "people"
};
const briefcase = {
  keywords: [
    "business",
    "documents",
    "work",
    "law",
    "legal",
    "job",
    "career"
  ],
  char: "💼",
  fitzpatrick_scale: false,
  category: "people"
};
const eyeglasses = {
  keywords: [
    "fashion",
    "accessories",
    "eyesight",
    "nerdy",
    "dork",
    "geek"
  ],
  char: "👓",
  fitzpatrick_scale: false,
  category: "people"
};
const dark_sunglasses = {
  keywords: [
    "face",
    "cool",
    "accessories"
  ],
  char: "🕶",
  fitzpatrick_scale: false,
  category: "people"
};
const goggles = {
  keywords: [
    "eyes",
    "protection",
    "safety"
  ],
  char: "🥽",
  fitzpatrick_scale: false,
  category: "people"
};
const ring = {
  keywords: [
    "wedding",
    "propose",
    "marriage",
    "valentines",
    "diamond",
    "fashion",
    "jewelry",
    "gem",
    "engagement"
  ],
  char: "💍",
  fitzpatrick_scale: false,
  category: "people"
};
const closed_umbrella = {
  keywords: [
    "weather",
    "rain",
    "drizzle"
  ],
  char: "🌂",
  fitzpatrick_scale: false,
  category: "people"
};
const dog = {
  keywords: [
    "animal",
    "friend",
    "nature",
    "woof",
    "puppy",
    "pet",
    "faithful"
  ],
  char: "🐶",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cat = {
  keywords: [
    "animal",
    "meow",
    "nature",
    "pet",
    "kitten"
  ],
  char: "🐱",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const mouse = {
  keywords: [
    "animal",
    "nature",
    "cheese_wedge",
    "rodent"
  ],
  char: "🐭",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hamster = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐹",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const rabbit = {
  keywords: [
    "animal",
    "nature",
    "pet",
    "spring",
    "magic",
    "bunny"
  ],
  char: "🐰",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const fox_face = {
  keywords: [
    "animal",
    "nature",
    "face"
  ],
  char: "🦊",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const bear = {
  keywords: [
    "animal",
    "nature",
    "wild"
  ],
  char: "🐻",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const panda_face = {
  keywords: [
    "animal",
    "nature",
    "panda"
  ],
  char: "🐼",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const koala = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐨",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const tiger = {
  keywords: [
    "animal",
    "cat",
    "danger",
    "wild",
    "nature",
    "roar"
  ],
  char: "🐯",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const lion = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🦁",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cow = {
  keywords: [
    "beef",
    "ox",
    "animal",
    "nature",
    "moo",
    "milk"
  ],
  char: "🐮",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const pig = {
  keywords: [
    "animal",
    "oink",
    "nature"
  ],
  char: "🐷",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const pig_nose = {
  keywords: [
    "animal",
    "oink"
  ],
  char: "🐽",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const frog = {
  keywords: [
    "animal",
    "nature",
    "croak",
    "toad"
  ],
  char: "🐸",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const squid = {
  keywords: [
    "animal",
    "nature",
    "ocean",
    "sea"
  ],
  char: "🦑",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const octopus = {
  keywords: [
    "animal",
    "creature",
    "ocean",
    "sea",
    "nature",
    "beach"
  ],
  char: "🐙",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const shrimp = {
  keywords: [
    "animal",
    "ocean",
    "nature",
    "seafood"
  ],
  char: "🦐",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const monkey_face = {
  keywords: [
    "animal",
    "nature",
    "circus"
  ],
  char: "🐵",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const gorilla = {
  keywords: [
    "animal",
    "nature",
    "circus"
  ],
  char: "🦍",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const see_no_evil = {
  keywords: [
    "monkey",
    "animal",
    "nature",
    "haha"
  ],
  char: "🙈",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hear_no_evil = {
  keywords: [
    "animal",
    "monkey",
    "nature"
  ],
  char: "🙉",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const speak_no_evil = {
  keywords: [
    "monkey",
    "animal",
    "nature",
    "omg"
  ],
  char: "🙊",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const monkey = {
  keywords: [
    "animal",
    "nature",
    "banana",
    "circus"
  ],
  char: "🐒",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const chicken = {
  keywords: [
    "animal",
    "cluck",
    "nature",
    "bird"
  ],
  char: "🐔",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const penguin = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐧",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const bird = {
  keywords: [
    "animal",
    "nature",
    "fly",
    "tweet",
    "spring"
  ],
  char: "🐦",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const baby_chick = {
  keywords: [
    "animal",
    "chicken",
    "bird"
  ],
  char: "🐤",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hatching_chick = {
  keywords: [
    "animal",
    "chicken",
    "egg",
    "born",
    "baby",
    "bird"
  ],
  char: "🐣",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hatched_chick = {
  keywords: [
    "animal",
    "chicken",
    "baby",
    "bird"
  ],
  char: "🐥",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const duck = {
  keywords: [
    "animal",
    "nature",
    "bird",
    "mallard"
  ],
  char: "🦆",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const eagle = {
  keywords: [
    "animal",
    "nature",
    "bird"
  ],
  char: "🦅",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const owl = {
  keywords: [
    "animal",
    "nature",
    "bird",
    "hoot"
  ],
  char: "🦉",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const bat = {
  keywords: [
    "animal",
    "nature",
    "blind",
    "vampire"
  ],
  char: "🦇",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const wolf = {
  keywords: [
    "animal",
    "nature",
    "wild"
  ],
  char: "🐺",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const boar = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐗",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const horse = {
  keywords: [
    "animal",
    "brown",
    "nature"
  ],
  char: "🐴",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const unicorn = {
  keywords: [
    "animal",
    "nature",
    "mystical"
  ],
  char: "🦄",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const honeybee = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "bug",
    "spring",
    "honey"
  ],
  char: "🐝",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const bug = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "worm"
  ],
  char: "🐛",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const butterfly = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "caterpillar"
  ],
  char: "🦋",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const snail = {
  keywords: [
    "slow",
    "animal",
    "shell"
  ],
  char: "🐌",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const beetle = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "ladybug"
  ],
  char: "🐞",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const ant = {
  keywords: [
    "animal",
    "insect",
    "nature",
    "bug"
  ],
  char: "🐜",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const grasshopper = {
  keywords: [
    "animal",
    "cricket",
    "chirp"
  ],
  char: "🦗",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const spider = {
  keywords: [
    "animal",
    "arachnid"
  ],
  char: "🕷",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const scorpion = {
  keywords: [
    "animal",
    "arachnid"
  ],
  char: "🦂",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const crab = {
  keywords: [
    "animal",
    "crustacean"
  ],
  char: "🦀",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const snake = {
  keywords: [
    "animal",
    "evil",
    "nature",
    "hiss",
    "python"
  ],
  char: "🐍",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const lizard = {
  keywords: [
    "animal",
    "nature",
    "reptile"
  ],
  char: "🦎",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sauropod = {
  keywords: [
    "animal",
    "nature",
    "dinosaur",
    "brachiosaurus",
    "brontosaurus",
    "diplodocus",
    "extinct"
  ],
  char: "🦕",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const turtle = {
  keywords: [
    "animal",
    "slow",
    "nature",
    "tortoise"
  ],
  char: "🐢",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const tropical_fish = {
  keywords: [
    "animal",
    "swim",
    "ocean",
    "beach",
    "nemo"
  ],
  char: "🐠",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const fish = {
  keywords: [
    "animal",
    "food",
    "nature"
  ],
  char: "🐟",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const blowfish = {
  keywords: [
    "animal",
    "nature",
    "food",
    "sea",
    "ocean"
  ],
  char: "🐡",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dolphin = {
  keywords: [
    "animal",
    "nature",
    "fish",
    "sea",
    "ocean",
    "flipper",
    "fins",
    "beach"
  ],
  char: "🐬",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const shark = {
  keywords: [
    "animal",
    "nature",
    "fish",
    "sea",
    "ocean",
    "jaws",
    "fins",
    "beach"
  ],
  char: "🦈",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const whale = {
  keywords: [
    "animal",
    "nature",
    "sea",
    "ocean"
  ],
  char: "🐳",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const whale2 = {
  keywords: [
    "animal",
    "nature",
    "sea",
    "ocean"
  ],
  char: "🐋",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const crocodile = {
  keywords: [
    "animal",
    "nature",
    "reptile",
    "lizard",
    "alligator"
  ],
  char: "🐊",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const leopard = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐆",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const zebra = {
  keywords: [
    "animal",
    "nature",
    "stripes",
    "safari"
  ],
  char: "🦓",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const tiger2 = {
  keywords: [
    "animal",
    "nature",
    "roar"
  ],
  char: "🐅",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const water_buffalo = {
  keywords: [
    "animal",
    "nature",
    "ox",
    "cow"
  ],
  char: "🐃",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const ox = {
  keywords: [
    "animal",
    "cow",
    "beef"
  ],
  char: "🐂",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cow2 = {
  keywords: [
    "beef",
    "ox",
    "animal",
    "nature",
    "moo",
    "milk"
  ],
  char: "🐄",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const deer = {
  keywords: [
    "animal",
    "nature",
    "horns",
    "venison"
  ],
  char: "🦌",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dromedary_camel = {
  keywords: [
    "animal",
    "hot",
    "desert",
    "hump"
  ],
  char: "🐪",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const camel = {
  keywords: [
    "animal",
    "nature",
    "hot",
    "desert",
    "hump"
  ],
  char: "🐫",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const giraffe = {
  keywords: [
    "animal",
    "nature",
    "spots",
    "safari"
  ],
  char: "🦒",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const elephant = {
  keywords: [
    "animal",
    "nature",
    "nose",
    "th",
    "circus"
  ],
  char: "🐘",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const rhinoceros = {
  keywords: [
    "animal",
    "nature",
    "horn"
  ],
  char: "🦏",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const goat = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐐",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const ram = {
  keywords: [
    "animal",
    "sheep",
    "nature"
  ],
  char: "🐏",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sheep = {
  keywords: [
    "animal",
    "nature",
    "wool",
    "shipit"
  ],
  char: "🐑",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const racehorse = {
  keywords: [
    "animal",
    "gamble",
    "luck"
  ],
  char: "🐎",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const pig2 = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🐖",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const rat = {
  keywords: [
    "animal",
    "mouse",
    "rodent"
  ],
  char: "🐀",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const mouse2 = {
  keywords: [
    "animal",
    "nature",
    "rodent"
  ],
  char: "🐁",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const rooster = {
  keywords: [
    "animal",
    "nature",
    "chicken"
  ],
  char: "🐓",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const turkey = {
  keywords: [
    "animal",
    "bird"
  ],
  char: "🦃",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dove = {
  keywords: [
    "animal",
    "bird"
  ],
  char: "🕊",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dog2 = {
  keywords: [
    "animal",
    "nature",
    "friend",
    "doge",
    "pet",
    "faithful"
  ],
  char: "🐕",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const poodle = {
  keywords: [
    "dog",
    "animal",
    "101",
    "nature",
    "pet"
  ],
  char: "🐩",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cat2 = {
  keywords: [
    "animal",
    "meow",
    "pet",
    "cats"
  ],
  char: "🐈",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const rabbit2 = {
  keywords: [
    "animal",
    "nature",
    "pet",
    "magic",
    "spring"
  ],
  char: "🐇",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const chipmunk = {
  keywords: [
    "animal",
    "nature",
    "rodent",
    "squirrel"
  ],
  char: "🐿",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hedgehog = {
  keywords: [
    "animal",
    "nature",
    "spiny"
  ],
  char: "🦔",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const raccoon = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🦝",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const llama = {
  keywords: [
    "animal",
    "nature",
    "alpaca"
  ],
  char: "🦙",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hippopotamus = {
  keywords: [
    "animal",
    "nature"
  ],
  char: "🦛",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const kangaroo = {
  keywords: [
    "animal",
    "nature",
    "australia",
    "joey",
    "hop",
    "marsupial"
  ],
  char: "🦘",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const badger = {
  keywords: [
    "animal",
    "nature",
    "honey"
  ],
  char: "🦡",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const swan = {
  keywords: [
    "animal",
    "nature",
    "bird"
  ],
  char: "🦢",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const peacock = {
  keywords: [
    "animal",
    "nature",
    "peahen",
    "bird"
  ],
  char: "🦚",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const parrot = {
  keywords: [
    "animal",
    "nature",
    "bird",
    "pirate",
    "talk"
  ],
  char: "🦜",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const lobster = {
  keywords: [
    "animal",
    "nature",
    "bisque",
    "claws",
    "seafood"
  ],
  char: "🦞",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const mosquito = {
  keywords: [
    "animal",
    "nature",
    "insect",
    "malaria"
  ],
  char: "🦟",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const paw_prints = {
  keywords: [
    "animal",
    "tracking",
    "footprints",
    "dog",
    "cat",
    "pet",
    "feet"
  ],
  char: "🐾",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dragon = {
  keywords: [
    "animal",
    "myth",
    "nature",
    "chinese",
    "green"
  ],
  char: "🐉",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dragon_face = {
  keywords: [
    "animal",
    "myth",
    "nature",
    "chinese",
    "green"
  ],
  char: "🐲",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cactus = {
  keywords: [
    "vegetable",
    "plant",
    "nature"
  ],
  char: "🌵",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const christmas_tree = {
  keywords: [
    "festival",
    "vacation",
    "december",
    "xmas",
    "celebration"
  ],
  char: "🎄",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const evergreen_tree = {
  keywords: [
    "plant",
    "nature"
  ],
  char: "🌲",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const deciduous_tree = {
  keywords: [
    "plant",
    "nature"
  ],
  char: "🌳",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const palm_tree = {
  keywords: [
    "plant",
    "vegetable",
    "nature",
    "summer",
    "beach",
    "mojito",
    "tropical"
  ],
  char: "🌴",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const seedling = {
  keywords: [
    "plant",
    "nature",
    "grass",
    "lawn",
    "spring"
  ],
  char: "🌱",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const herb = {
  keywords: [
    "vegetable",
    "plant",
    "medicine",
    "weed",
    "grass",
    "lawn"
  ],
  char: "🌿",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const shamrock = {
  keywords: [
    "vegetable",
    "plant",
    "nature",
    "irish",
    "clover"
  ],
  char: "☘",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const four_leaf_clover = {
  keywords: [
    "vegetable",
    "plant",
    "nature",
    "lucky",
    "irish"
  ],
  char: "🍀",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const bamboo = {
  keywords: [
    "plant",
    "nature",
    "vegetable",
    "panda",
    "pine_decoration"
  ],
  char: "🎍",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const tanabata_tree = {
  keywords: [
    "plant",
    "nature",
    "branch",
    "summer"
  ],
  char: "🎋",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const leaves = {
  keywords: [
    "nature",
    "plant",
    "tree",
    "vegetable",
    "grass",
    "lawn",
    "spring"
  ],
  char: "🍃",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const fallen_leaf = {
  keywords: [
    "nature",
    "plant",
    "vegetable",
    "leaves"
  ],
  char: "🍂",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const maple_leaf = {
  keywords: [
    "nature",
    "plant",
    "vegetable",
    "ca",
    "fall"
  ],
  char: "🍁",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const ear_of_rice = {
  keywords: [
    "nature",
    "plant"
  ],
  char: "🌾",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const hibiscus = {
  keywords: [
    "plant",
    "vegetable",
    "flowers",
    "beach"
  ],
  char: "🌺",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sunflower = {
  keywords: [
    "nature",
    "plant",
    "fall"
  ],
  char: "🌻",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const rose = {
  keywords: [
    "flowers",
    "valentines",
    "love",
    "spring"
  ],
  char: "🌹",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const wilted_flower = {
  keywords: [
    "plant",
    "nature",
    "flower"
  ],
  char: "🥀",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const tulip = {
  keywords: [
    "flowers",
    "plant",
    "nature",
    "summer",
    "spring"
  ],
  char: "🌷",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const blossom = {
  keywords: [
    "nature",
    "flowers",
    "yellow"
  ],
  char: "🌼",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cherry_blossom = {
  keywords: [
    "nature",
    "plant",
    "spring",
    "flower"
  ],
  char: "🌸",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const bouquet = {
  keywords: [
    "flowers",
    "nature",
    "spring"
  ],
  char: "💐",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const mushroom = {
  keywords: [
    "plant",
    "vegetable"
  ],
  char: "🍄",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const chestnut = {
  keywords: [
    "food",
    "squirrel"
  ],
  char: "🌰",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const jack_o_lantern = {
  keywords: [
    "halloween",
    "light",
    "pumpkin",
    "creepy",
    "fall"
  ],
  char: "🎃",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const shell = {
  keywords: [
    "nature",
    "sea",
    "beach"
  ],
  char: "🐚",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const spider_web = {
  keywords: [
    "animal",
    "insect",
    "arachnid",
    "silk"
  ],
  char: "🕸",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const earth_americas = {
  keywords: [
    "globe",
    "world",
    "USA",
    "international"
  ],
  char: "🌎",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const earth_africa = {
  keywords: [
    "globe",
    "world",
    "international"
  ],
  char: "🌍",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const earth_asia = {
  keywords: [
    "globe",
    "world",
    "east",
    "international"
  ],
  char: "🌏",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const full_moon = {
  keywords: [
    "nature",
    "yellow",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌕",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const waning_gibbous_moon = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep",
    "waxing_gibbous_moon"
  ],
  char: "🌖",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const last_quarter_moon = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌗",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const waning_crescent_moon = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌘",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const new_moon = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌑",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const waxing_crescent_moon = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌒",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const first_quarter_moon = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌓",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const waxing_gibbous_moon = {
  keywords: [
    "nature",
    "night",
    "sky",
    "gray",
    "twilight",
    "planet",
    "space",
    "evening",
    "sleep"
  ],
  char: "🌔",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const new_moon_with_face = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌚",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const full_moon_with_face = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌝",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const first_quarter_moon_with_face = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌛",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const last_quarter_moon_with_face = {
  keywords: [
    "nature",
    "twilight",
    "planet",
    "space",
    "night",
    "evening",
    "sleep"
  ],
  char: "🌜",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sun_with_face = {
  keywords: [
    "nature",
    "morning",
    "sky"
  ],
  char: "🌞",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const crescent_moon = {
  keywords: [
    "night",
    "sleep",
    "sky",
    "evening",
    "magic"
  ],
  char: "🌙",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const star = {
  keywords: [
    "night",
    "yellow"
  ],
  char: "⭐",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const star2 = {
  keywords: [
    "night",
    "sparkle",
    "awesome",
    "good",
    "magic"
  ],
  char: "🌟",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dizzy = {
  keywords: [
    "star",
    "sparkle",
    "shoot",
    "magic"
  ],
  char: "💫",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sparkles = {
  keywords: [
    "stars",
    "shine",
    "shiny",
    "cool",
    "awesome",
    "good",
    "magic"
  ],
  char: "✨",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const comet = {
  keywords: [
    "space"
  ],
  char: "☄",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sunny = {
  keywords: [
    "weather",
    "nature",
    "brightness",
    "summer",
    "beach",
    "spring"
  ],
  char: "☀️",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sun_behind_small_cloud = {
  keywords: [
    "weather"
  ],
  char: "🌤",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const partly_sunny = {
  keywords: [
    "weather",
    "nature",
    "cloudy",
    "morning",
    "fall",
    "spring"
  ],
  char: "⛅",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sun_behind_large_cloud = {
  keywords: [
    "weather"
  ],
  char: "🌥",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sun_behind_rain_cloud = {
  keywords: [
    "weather"
  ],
  char: "🌦",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cloud = {
  keywords: [
    "weather",
    "sky"
  ],
  char: "☁️",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cloud_with_rain = {
  keywords: [
    "weather"
  ],
  char: "🌧",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cloud_with_lightning_and_rain = {
  keywords: [
    "weather",
    "lightning"
  ],
  char: "⛈",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cloud_with_lightning = {
  keywords: [
    "weather",
    "thunder"
  ],
  char: "🌩",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const zap = {
  keywords: [
    "thunder",
    "weather",
    "lightning bolt",
    "fast"
  ],
  char: "⚡",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const fire = {
  keywords: [
    "hot",
    "cook",
    "flame"
  ],
  char: "🔥",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const boom = {
  keywords: [
    "bomb",
    "explode",
    "explosion",
    "collision",
    "blown"
  ],
  char: "💥",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const snowflake = {
  keywords: [
    "winter",
    "season",
    "cold",
    "weather",
    "christmas",
    "xmas"
  ],
  char: "❄️",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const cloud_with_snow = {
  keywords: [
    "weather"
  ],
  char: "🌨",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const snowman = {
  keywords: [
    "winter",
    "season",
    "cold",
    "weather",
    "christmas",
    "xmas",
    "frozen",
    "without_snow"
  ],
  char: "⛄",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const snowman_with_snow = {
  keywords: [
    "winter",
    "season",
    "cold",
    "weather",
    "christmas",
    "xmas",
    "frozen"
  ],
  char: "☃",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const wind_face = {
  keywords: [
    "gust",
    "air"
  ],
  char: "🌬",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const dash$1 = {
  keywords: [
    "wind",
    "air",
    "fast",
    "shoo",
    "fart",
    "smoke",
    "puff"
  ],
  char: "💨",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const tornado = {
  keywords: [
    "weather",
    "cyclone",
    "twister"
  ],
  char: "🌪",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const fog = {
  keywords: [
    "weather"
  ],
  char: "🌫",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const open_umbrella = {
  keywords: [
    "weather",
    "spring"
  ],
  char: "☂",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const umbrella = {
  keywords: [
    "rainy",
    "weather",
    "spring"
  ],
  char: "☔",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const droplet = {
  keywords: [
    "water",
    "drip",
    "faucet",
    "spring"
  ],
  char: "💧",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const sweat_drops = {
  keywords: [
    "water",
    "drip",
    "oops"
  ],
  char: "💦",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const ocean = {
  keywords: [
    "sea",
    "water",
    "wave",
    "nature",
    "tsunami",
    "disaster"
  ],
  char: "🌊",
  fitzpatrick_scale: false,
  category: "animals_and_nature"
};
const green_apple = {
  keywords: [
    "fruit",
    "nature"
  ],
  char: "🍏",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const apple = {
  keywords: [
    "fruit",
    "mac",
    "school"
  ],
  char: "🍎",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const pear = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "🍐",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const tangerine = {
  keywords: [
    "food",
    "fruit",
    "nature",
    "orange"
  ],
  char: "🍊",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const lemon = {
  keywords: [
    "fruit",
    "nature"
  ],
  char: "🍋",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const banana = {
  keywords: [
    "fruit",
    "food",
    "monkey"
  ],
  char: "🍌",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const watermelon = {
  keywords: [
    "fruit",
    "food",
    "picnic",
    "summer"
  ],
  char: "🍉",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const grapes = {
  keywords: [
    "fruit",
    "food",
    "wine"
  ],
  char: "🍇",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const strawberry = {
  keywords: [
    "fruit",
    "food",
    "nature"
  ],
  char: "🍓",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const melon = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "🍈",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cherries = {
  keywords: [
    "food",
    "fruit"
  ],
  char: "🍒",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const peach = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "🍑",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const pineapple = {
  keywords: [
    "fruit",
    "nature",
    "food"
  ],
  char: "🍍",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const coconut = {
  keywords: [
    "fruit",
    "nature",
    "food",
    "palm"
  ],
  char: "🥥",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const kiwi_fruit = {
  keywords: [
    "fruit",
    "food"
  ],
  char: "🥝",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const mango = {
  keywords: [
    "fruit",
    "food",
    "tropical"
  ],
  char: "🥭",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const avocado = {
  keywords: [
    "fruit",
    "food"
  ],
  char: "🥑",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const broccoli = {
  keywords: [
    "fruit",
    "food",
    "vegetable"
  ],
  char: "🥦",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const tomato = {
  keywords: [
    "fruit",
    "vegetable",
    "nature",
    "food"
  ],
  char: "🍅",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const eggplant = {
  keywords: [
    "vegetable",
    "nature",
    "food",
    "aubergine"
  ],
  char: "🍆",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cucumber = {
  keywords: [
    "fruit",
    "food",
    "pickle"
  ],
  char: "🥒",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const carrot = {
  keywords: [
    "vegetable",
    "food",
    "orange"
  ],
  char: "🥕",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const hot_pepper = {
  keywords: [
    "food",
    "spicy",
    "chilli",
    "chili"
  ],
  char: "🌶",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const potato = {
  keywords: [
    "food",
    "tuber",
    "vegatable",
    "starch"
  ],
  char: "🥔",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const corn = {
  keywords: [
    "food",
    "vegetable",
    "plant"
  ],
  char: "🌽",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const leafy_greens = {
  keywords: [
    "food",
    "vegetable",
    "plant",
    "bok choy",
    "cabbage",
    "kale",
    "lettuce"
  ],
  char: "🥬",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const sweet_potato = {
  keywords: [
    "food",
    "nature"
  ],
  char: "🍠",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const peanuts = {
  keywords: [
    "food",
    "nut"
  ],
  char: "🥜",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const honey_pot = {
  keywords: [
    "bees",
    "sweet",
    "kitchen"
  ],
  char: "🍯",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const croissant = {
  keywords: [
    "food",
    "bread",
    "french"
  ],
  char: "🥐",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const bread = {
  keywords: [
    "food",
    "wheat",
    "breakfast",
    "toast"
  ],
  char: "🍞",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const baguette_bread = {
  keywords: [
    "food",
    "bread",
    "french"
  ],
  char: "🥖",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const bagel = {
  keywords: [
    "food",
    "bread",
    "bakery",
    "schmear"
  ],
  char: "🥯",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const pretzel = {
  keywords: [
    "food",
    "bread",
    "twisted"
  ],
  char: "🥨",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cheese = {
  keywords: [
    "food",
    "chadder"
  ],
  char: "🧀",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const egg = {
  keywords: [
    "food",
    "chicken",
    "breakfast"
  ],
  char: "🥚",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const bacon = {
  keywords: [
    "food",
    "breakfast",
    "pork",
    "pig",
    "meat"
  ],
  char: "🥓",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const steak = {
  keywords: [
    "food",
    "cow",
    "meat",
    "cut",
    "chop",
    "lambchop",
    "porkchop"
  ],
  char: "🥩",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const pancakes = {
  keywords: [
    "food",
    "breakfast",
    "flapjacks",
    "hotcakes"
  ],
  char: "🥞",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const poultry_leg = {
  keywords: [
    "food",
    "meat",
    "drumstick",
    "bird",
    "chicken",
    "turkey"
  ],
  char: "🍗",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const meat_on_bone = {
  keywords: [
    "good",
    "food",
    "drumstick"
  ],
  char: "🍖",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const bone = {
  keywords: [
    "skeleton"
  ],
  char: "🦴",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const fried_shrimp = {
  keywords: [
    "food",
    "animal",
    "appetizer",
    "summer"
  ],
  char: "🍤",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const fried_egg = {
  keywords: [
    "food",
    "breakfast",
    "kitchen",
    "egg"
  ],
  char: "🍳",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const hamburger = {
  keywords: [
    "meat",
    "fast food",
    "beef",
    "cheeseburger",
    "mcdonalds",
    "burger king"
  ],
  char: "🍔",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const fries = {
  keywords: [
    "chips",
    "snack",
    "fast food"
  ],
  char: "🍟",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const stuffed_flatbread = {
  keywords: [
    "food",
    "flatbread",
    "stuffed",
    "gyro"
  ],
  char: "🥙",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const hotdog = {
  keywords: [
    "food",
    "frankfurter"
  ],
  char: "🌭",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const pizza = {
  keywords: [
    "food",
    "party"
  ],
  char: "🍕",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const sandwich = {
  keywords: [
    "food",
    "lunch",
    "bread"
  ],
  char: "🥪",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const canned_food = {
  keywords: [
    "food",
    "soup"
  ],
  char: "🥫",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const spaghetti = {
  keywords: [
    "food",
    "italian",
    "noodle"
  ],
  char: "🍝",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const taco = {
  keywords: [
    "food",
    "mexican"
  ],
  char: "🌮",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const burrito = {
  keywords: [
    "food",
    "mexican"
  ],
  char: "🌯",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const green_salad = {
  keywords: [
    "food",
    "healthy",
    "lettuce"
  ],
  char: "🥗",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const shallow_pan_of_food = {
  keywords: [
    "food",
    "cooking",
    "casserole",
    "paella"
  ],
  char: "🥘",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const ramen = {
  keywords: [
    "food",
    "japanese",
    "noodle",
    "chopsticks"
  ],
  char: "🍜",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const stew = {
  keywords: [
    "food",
    "meat",
    "soup"
  ],
  char: "🍲",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const fish_cake = {
  keywords: [
    "food",
    "japan",
    "sea",
    "beach",
    "narutomaki",
    "pink",
    "swirl",
    "kamaboko",
    "surimi",
    "ramen"
  ],
  char: "🍥",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const fortune_cookie = {
  keywords: [
    "food",
    "prophecy"
  ],
  char: "🥠",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const sushi = {
  keywords: [
    "food",
    "fish",
    "japanese",
    "rice"
  ],
  char: "🍣",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const bento = {
  keywords: [
    "food",
    "japanese",
    "box"
  ],
  char: "🍱",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const curry = {
  keywords: [
    "food",
    "spicy",
    "hot",
    "indian"
  ],
  char: "🍛",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const rice_ball = {
  keywords: [
    "food",
    "japanese"
  ],
  char: "🍙",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const rice = {
  keywords: [
    "food",
    "china",
    "asian"
  ],
  char: "🍚",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const rice_cracker = {
  keywords: [
    "food",
    "japanese"
  ],
  char: "🍘",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const oden = {
  keywords: [
    "food",
    "japanese"
  ],
  char: "🍢",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const dango = {
  keywords: [
    "food",
    "dessert",
    "sweet",
    "japanese",
    "barbecue",
    "meat"
  ],
  char: "🍡",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const shaved_ice = {
  keywords: [
    "hot",
    "dessert",
    "summer"
  ],
  char: "🍧",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const ice_cream = {
  keywords: [
    "food",
    "hot",
    "dessert"
  ],
  char: "🍨",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const icecream = {
  keywords: [
    "food",
    "hot",
    "dessert",
    "summer"
  ],
  char: "🍦",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const pie = {
  keywords: [
    "food",
    "dessert",
    "pastry"
  ],
  char: "🥧",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cake = {
  keywords: [
    "food",
    "dessert"
  ],
  char: "🍰",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cupcake = {
  keywords: [
    "food",
    "dessert",
    "bakery",
    "sweet"
  ],
  char: "🧁",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const moon_cake = {
  keywords: [
    "food",
    "autumn"
  ],
  char: "🥮",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const birthday = {
  keywords: [
    "food",
    "dessert",
    "cake"
  ],
  char: "🎂",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const custard = {
  keywords: [
    "dessert",
    "food"
  ],
  char: "🍮",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const candy = {
  keywords: [
    "snack",
    "dessert",
    "sweet",
    "lolly"
  ],
  char: "🍬",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const lollipop = {
  keywords: [
    "food",
    "snack",
    "candy",
    "sweet"
  ],
  char: "🍭",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const chocolate_bar = {
  keywords: [
    "food",
    "snack",
    "dessert",
    "sweet"
  ],
  char: "🍫",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const popcorn = {
  keywords: [
    "food",
    "movie theater",
    "films",
    "snack"
  ],
  char: "🍿",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const dumpling = {
  keywords: [
    "food",
    "empanada",
    "pierogi",
    "potsticker"
  ],
  char: "🥟",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const doughnut = {
  keywords: [
    "food",
    "dessert",
    "snack",
    "sweet",
    "donut"
  ],
  char: "🍩",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cookie = {
  keywords: [
    "food",
    "snack",
    "oreo",
    "chocolate",
    "sweet",
    "dessert"
  ],
  char: "🍪",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const milk_glass = {
  keywords: [
    "beverage",
    "drink",
    "cow"
  ],
  char: "🥛",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const beer = {
  keywords: [
    "relax",
    "beverage",
    "drink",
    "drunk",
    "party",
    "pub",
    "summer",
    "alcohol",
    "booze"
  ],
  char: "🍺",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const beers = {
  keywords: [
    "relax",
    "beverage",
    "drink",
    "drunk",
    "party",
    "pub",
    "summer",
    "alcohol",
    "booze"
  ],
  char: "🍻",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const clinking_glasses = {
  keywords: [
    "beverage",
    "drink",
    "party",
    "alcohol",
    "celebrate",
    "cheers",
    "wine",
    "champagne",
    "toast"
  ],
  char: "🥂",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const wine_glass = {
  keywords: [
    "drink",
    "beverage",
    "drunk",
    "alcohol",
    "booze"
  ],
  char: "🍷",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const tumbler_glass = {
  keywords: [
    "drink",
    "beverage",
    "drunk",
    "alcohol",
    "liquor",
    "booze",
    "bourbon",
    "scotch",
    "whisky",
    "glass",
    "shot"
  ],
  char: "🥃",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cocktail = {
  keywords: [
    "drink",
    "drunk",
    "alcohol",
    "beverage",
    "booze",
    "mojito"
  ],
  char: "🍸",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const tropical_drink = {
  keywords: [
    "beverage",
    "cocktail",
    "summer",
    "beach",
    "alcohol",
    "booze",
    "mojito"
  ],
  char: "🍹",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const champagne = {
  keywords: [
    "drink",
    "wine",
    "bottle",
    "celebration"
  ],
  char: "🍾",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const sake = {
  keywords: [
    "wine",
    "drink",
    "drunk",
    "beverage",
    "japanese",
    "alcohol",
    "booze"
  ],
  char: "🍶",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const tea = {
  keywords: [
    "drink",
    "bowl",
    "breakfast",
    "green",
    "british"
  ],
  char: "🍵",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const cup_with_straw = {
  keywords: [
    "drink",
    "soda"
  ],
  char: "🥤",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const coffee = {
  keywords: [
    "beverage",
    "caffeine",
    "latte",
    "espresso"
  ],
  char: "☕",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const baby_bottle = {
  keywords: [
    "food",
    "container",
    "milk"
  ],
  char: "🍼",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const salt = {
  keywords: [
    "condiment",
    "shaker"
  ],
  char: "🧂",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const spoon = {
  keywords: [
    "cutlery",
    "kitchen",
    "tableware"
  ],
  char: "🥄",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const fork_and_knife = {
  keywords: [
    "cutlery",
    "kitchen"
  ],
  char: "🍴",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const plate_with_cutlery = {
  keywords: [
    "food",
    "eat",
    "meal",
    "lunch",
    "dinner",
    "restaurant"
  ],
  char: "🍽",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const bowl_with_spoon = {
  keywords: [
    "food",
    "breakfast",
    "cereal",
    "oatmeal",
    "porridge"
  ],
  char: "🥣",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const takeout_box = {
  keywords: [
    "food",
    "leftovers"
  ],
  char: "🥡",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const chopsticks = {
  keywords: [
    "food"
  ],
  char: "🥢",
  fitzpatrick_scale: false,
  category: "food_and_drink"
};
const soccer = {
  keywords: [
    "sports",
    "football"
  ],
  char: "⚽",
  fitzpatrick_scale: false,
  category: "activity"
};
const basketball = {
  keywords: [
    "sports",
    "balls",
    "NBA"
  ],
  char: "🏀",
  fitzpatrick_scale: false,
  category: "activity"
};
const football = {
  keywords: [
    "sports",
    "balls",
    "NFL"
  ],
  char: "🏈",
  fitzpatrick_scale: false,
  category: "activity"
};
const baseball = {
  keywords: [
    "sports",
    "balls"
  ],
  char: "⚾",
  fitzpatrick_scale: false,
  category: "activity"
};
const softball = {
  keywords: [
    "sports",
    "balls"
  ],
  char: "🥎",
  fitzpatrick_scale: false,
  category: "activity"
};
const tennis = {
  keywords: [
    "sports",
    "balls",
    "green"
  ],
  char: "🎾",
  fitzpatrick_scale: false,
  category: "activity"
};
const volleyball = {
  keywords: [
    "sports",
    "balls"
  ],
  char: "🏐",
  fitzpatrick_scale: false,
  category: "activity"
};
const rugby_football = {
  keywords: [
    "sports",
    "team"
  ],
  char: "🏉",
  fitzpatrick_scale: false,
  category: "activity"
};
const flying_disc = {
  keywords: [
    "sports",
    "frisbee",
    "ultimate"
  ],
  char: "🥏",
  fitzpatrick_scale: false,
  category: "activity"
};
const golf = {
  keywords: [
    "sports",
    "business",
    "flag",
    "hole",
    "summer"
  ],
  char: "⛳",
  fitzpatrick_scale: false,
  category: "activity"
};
const golfing_woman = {
  keywords: [
    "sports",
    "business",
    "woman",
    "female"
  ],
  char: "🏌️‍♀️",
  fitzpatrick_scale: false,
  category: "activity"
};
const golfing_man = {
  keywords: [
    "sports",
    "business"
  ],
  char: "🏌",
  fitzpatrick_scale: true,
  category: "activity"
};
const ping_pong = {
  keywords: [
    "sports",
    "pingpong"
  ],
  char: "🏓",
  fitzpatrick_scale: false,
  category: "activity"
};
const badminton = {
  keywords: [
    "sports"
  ],
  char: "🏸",
  fitzpatrick_scale: false,
  category: "activity"
};
const goal_net = {
  keywords: [
    "sports"
  ],
  char: "🥅",
  fitzpatrick_scale: false,
  category: "activity"
};
const ice_hockey = {
  keywords: [
    "sports"
  ],
  char: "🏒",
  fitzpatrick_scale: false,
  category: "activity"
};
const field_hockey = {
  keywords: [
    "sports"
  ],
  char: "🏑",
  fitzpatrick_scale: false,
  category: "activity"
};
const lacrosse = {
  keywords: [
    "sports",
    "ball",
    "stick"
  ],
  char: "🥍",
  fitzpatrick_scale: false,
  category: "activity"
};
const cricket = {
  keywords: [
    "sports"
  ],
  char: "🏏",
  fitzpatrick_scale: false,
  category: "activity"
};
const ski = {
  keywords: [
    "sports",
    "winter",
    "cold",
    "snow"
  ],
  char: "🎿",
  fitzpatrick_scale: false,
  category: "activity"
};
const skier = {
  keywords: [
    "sports",
    "winter",
    "snow"
  ],
  char: "⛷",
  fitzpatrick_scale: false,
  category: "activity"
};
const snowboarder = {
  keywords: [
    "sports",
    "winter"
  ],
  char: "🏂",
  fitzpatrick_scale: true,
  category: "activity"
};
const person_fencing = {
  keywords: [
    "sports",
    "fencing",
    "sword"
  ],
  char: "🤺",
  fitzpatrick_scale: false,
  category: "activity"
};
const women_wrestling = {
  keywords: [
    "sports",
    "wrestlers"
  ],
  char: "🤼‍♀️",
  fitzpatrick_scale: false,
  category: "activity"
};
const men_wrestling = {
  keywords: [
    "sports",
    "wrestlers"
  ],
  char: "🤼‍♂️",
  fitzpatrick_scale: false,
  category: "activity"
};
const woman_cartwheeling = {
  keywords: [
    "gymnastics"
  ],
  char: "🤸‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const man_cartwheeling = {
  keywords: [
    "gymnastics"
  ],
  char: "🤸‍♂️",
  fitzpatrick_scale: true,
  category: "activity"
};
const woman_playing_handball = {
  keywords: [
    "sports"
  ],
  char: "🤾‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const man_playing_handball = {
  keywords: [
    "sports"
  ],
  char: "🤾‍♂️",
  fitzpatrick_scale: true,
  category: "activity"
};
const ice_skate = {
  keywords: [
    "sports"
  ],
  char: "⛸",
  fitzpatrick_scale: false,
  category: "activity"
};
const curling_stone = {
  keywords: [
    "sports"
  ],
  char: "🥌",
  fitzpatrick_scale: false,
  category: "activity"
};
const skateboard = {
  keywords: [
    "board"
  ],
  char: "🛹",
  fitzpatrick_scale: false,
  category: "activity"
};
const sled = {
  keywords: [
    "sleigh",
    "luge",
    "toboggan"
  ],
  char: "🛷",
  fitzpatrick_scale: false,
  category: "activity"
};
const bow_and_arrow = {
  keywords: [
    "sports"
  ],
  char: "🏹",
  fitzpatrick_scale: false,
  category: "activity"
};
const fishing_pole_and_fish = {
  keywords: [
    "food",
    "hobby",
    "summer"
  ],
  char: "🎣",
  fitzpatrick_scale: false,
  category: "activity"
};
const boxing_glove = {
  keywords: [
    "sports",
    "fighting"
  ],
  char: "🥊",
  fitzpatrick_scale: false,
  category: "activity"
};
const martial_arts_uniform = {
  keywords: [
    "judo",
    "karate",
    "taekwondo"
  ],
  char: "🥋",
  fitzpatrick_scale: false,
  category: "activity"
};
const rowing_woman = {
  keywords: [
    "sports",
    "hobby",
    "water",
    "ship",
    "woman",
    "female"
  ],
  char: "🚣‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const rowing_man = {
  keywords: [
    "sports",
    "hobby",
    "water",
    "ship"
  ],
  char: "🚣",
  fitzpatrick_scale: true,
  category: "activity"
};
const climbing_woman = {
  keywords: [
    "sports",
    "hobby",
    "woman",
    "female",
    "rock"
  ],
  char: "🧗‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const climbing_man = {
  keywords: [
    "sports",
    "hobby",
    "man",
    "male",
    "rock"
  ],
  char: "🧗‍♂️",
  fitzpatrick_scale: true,
  category: "activity"
};
const swimming_woman = {
  keywords: [
    "sports",
    "exercise",
    "human",
    "athlete",
    "water",
    "summer",
    "woman",
    "female"
  ],
  char: "🏊‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const swimming_man = {
  keywords: [
    "sports",
    "exercise",
    "human",
    "athlete",
    "water",
    "summer"
  ],
  char: "🏊",
  fitzpatrick_scale: true,
  category: "activity"
};
const woman_playing_water_polo = {
  keywords: [
    "sports",
    "pool"
  ],
  char: "🤽‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const man_playing_water_polo = {
  keywords: [
    "sports",
    "pool"
  ],
  char: "🤽‍♂️",
  fitzpatrick_scale: true,
  category: "activity"
};
const woman_in_lotus_position = {
  keywords: [
    "woman",
    "female",
    "meditation",
    "yoga",
    "serenity",
    "zen",
    "mindfulness"
  ],
  char: "🧘‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const man_in_lotus_position = {
  keywords: [
    "man",
    "male",
    "meditation",
    "yoga",
    "serenity",
    "zen",
    "mindfulness"
  ],
  char: "🧘‍♂️",
  fitzpatrick_scale: true,
  category: "activity"
};
const surfing_woman = {
  keywords: [
    "sports",
    "ocean",
    "sea",
    "summer",
    "beach",
    "woman",
    "female"
  ],
  char: "🏄‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const surfing_man = {
  keywords: [
    "sports",
    "ocean",
    "sea",
    "summer",
    "beach"
  ],
  char: "🏄",
  fitzpatrick_scale: true,
  category: "activity"
};
const bath = {
  keywords: [
    "clean",
    "shower",
    "bathroom"
  ],
  char: "🛀",
  fitzpatrick_scale: true,
  category: "activity"
};
const basketball_woman = {
  keywords: [
    "sports",
    "human",
    "woman",
    "female"
  ],
  char: "⛹️‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const basketball_man = {
  keywords: [
    "sports",
    "human"
  ],
  char: "⛹",
  fitzpatrick_scale: true,
  category: "activity"
};
const weight_lifting_woman = {
  keywords: [
    "sports",
    "training",
    "exercise",
    "woman",
    "female"
  ],
  char: "🏋️‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const weight_lifting_man = {
  keywords: [
    "sports",
    "training",
    "exercise"
  ],
  char: "🏋",
  fitzpatrick_scale: true,
  category: "activity"
};
const biking_woman = {
  keywords: [
    "sports",
    "bike",
    "exercise",
    "hipster",
    "woman",
    "female"
  ],
  char: "🚴‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const biking_man = {
  keywords: [
    "sports",
    "bike",
    "exercise",
    "hipster"
  ],
  char: "🚴",
  fitzpatrick_scale: true,
  category: "activity"
};
const mountain_biking_woman = {
  keywords: [
    "transportation",
    "sports",
    "human",
    "race",
    "bike",
    "woman",
    "female"
  ],
  char: "🚵‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const mountain_biking_man = {
  keywords: [
    "transportation",
    "sports",
    "human",
    "race",
    "bike"
  ],
  char: "🚵",
  fitzpatrick_scale: true,
  category: "activity"
};
const horse_racing = {
  keywords: [
    "animal",
    "betting",
    "competition",
    "gambling",
    "luck"
  ],
  char: "🏇",
  fitzpatrick_scale: true,
  category: "activity"
};
const business_suit_levitating = {
  keywords: [
    "suit",
    "business",
    "levitate",
    "hover",
    "jump"
  ],
  char: "🕴",
  fitzpatrick_scale: true,
  category: "activity"
};
const trophy = {
  keywords: [
    "win",
    "award",
    "contest",
    "place",
    "ftw",
    "ceremony"
  ],
  char: "🏆",
  fitzpatrick_scale: false,
  category: "activity"
};
const running_shirt_with_sash = {
  keywords: [
    "play",
    "pageant"
  ],
  char: "🎽",
  fitzpatrick_scale: false,
  category: "activity"
};
const medal_sports = {
  keywords: [
    "award",
    "winning"
  ],
  char: "🏅",
  fitzpatrick_scale: false,
  category: "activity"
};
const medal_military = {
  keywords: [
    "award",
    "winning",
    "army"
  ],
  char: "🎖",
  fitzpatrick_scale: false,
  category: "activity"
};
const reminder_ribbon = {
  keywords: [
    "sports",
    "cause",
    "support",
    "awareness"
  ],
  char: "🎗",
  fitzpatrick_scale: false,
  category: "activity"
};
const rosette = {
  keywords: [
    "flower",
    "decoration",
    "military"
  ],
  char: "🏵",
  fitzpatrick_scale: false,
  category: "activity"
};
const ticket = {
  keywords: [
    "event",
    "concert",
    "pass"
  ],
  char: "🎫",
  fitzpatrick_scale: false,
  category: "activity"
};
const tickets = {
  keywords: [
    "sports",
    "concert",
    "entrance"
  ],
  char: "🎟",
  fitzpatrick_scale: false,
  category: "activity"
};
const performing_arts = {
  keywords: [
    "acting",
    "theater",
    "drama"
  ],
  char: "🎭",
  fitzpatrick_scale: false,
  category: "activity"
};
const art = {
  keywords: [
    "design",
    "paint",
    "draw",
    "colors"
  ],
  char: "🎨",
  fitzpatrick_scale: false,
  category: "activity"
};
const circus_tent = {
  keywords: [
    "festival",
    "carnival",
    "party"
  ],
  char: "🎪",
  fitzpatrick_scale: false,
  category: "activity"
};
const woman_juggling = {
  keywords: [
    "juggle",
    "balance",
    "skill",
    "multitask"
  ],
  char: "🤹‍♀️",
  fitzpatrick_scale: true,
  category: "activity"
};
const man_juggling = {
  keywords: [
    "juggle",
    "balance",
    "skill",
    "multitask"
  ],
  char: "🤹‍♂️",
  fitzpatrick_scale: true,
  category: "activity"
};
const microphone = {
  keywords: [
    "sound",
    "music",
    "PA",
    "sing",
    "talkshow"
  ],
  char: "🎤",
  fitzpatrick_scale: false,
  category: "activity"
};
const headphones = {
  keywords: [
    "music",
    "score",
    "gadgets"
  ],
  char: "🎧",
  fitzpatrick_scale: false,
  category: "activity"
};
const musical_score = {
  keywords: [
    "treble",
    "clef",
    "compose"
  ],
  char: "🎼",
  fitzpatrick_scale: false,
  category: "activity"
};
const musical_keyboard = {
  keywords: [
    "piano",
    "instrument",
    "compose"
  ],
  char: "🎹",
  fitzpatrick_scale: false,
  category: "activity"
};
const drum = {
  keywords: [
    "music",
    "instrument",
    "drumsticks",
    "snare"
  ],
  char: "🥁",
  fitzpatrick_scale: false,
  category: "activity"
};
const saxophone = {
  keywords: [
    "music",
    "instrument",
    "jazz",
    "blues"
  ],
  char: "🎷",
  fitzpatrick_scale: false,
  category: "activity"
};
const trumpet = {
  keywords: [
    "music",
    "brass"
  ],
  char: "🎺",
  fitzpatrick_scale: false,
  category: "activity"
};
const guitar = {
  keywords: [
    "music",
    "instrument"
  ],
  char: "🎸",
  fitzpatrick_scale: false,
  category: "activity"
};
const violin = {
  keywords: [
    "music",
    "instrument",
    "orchestra",
    "symphony"
  ],
  char: "🎻",
  fitzpatrick_scale: false,
  category: "activity"
};
const clapper = {
  keywords: [
    "movie",
    "film",
    "record"
  ],
  char: "🎬",
  fitzpatrick_scale: false,
  category: "activity"
};
const video_game = {
  keywords: [
    "play",
    "console",
    "PS4",
    "controller"
  ],
  char: "🎮",
  fitzpatrick_scale: false,
  category: "activity"
};
const space_invader = {
  keywords: [
    "game",
    "arcade",
    "play"
  ],
  char: "👾",
  fitzpatrick_scale: false,
  category: "activity"
};
const dart = {
  keywords: [
    "game",
    "play",
    "bar",
    "target",
    "bullseye"
  ],
  char: "🎯",
  fitzpatrick_scale: false,
  category: "activity"
};
const game_die = {
  keywords: [
    "dice",
    "random",
    "tabletop",
    "play",
    "luck"
  ],
  char: "🎲",
  fitzpatrick_scale: false,
  category: "activity"
};
const chess_pawn = {
  keywords: [
    "expendable"
  ],
  char: "♟",
  fitzpatrick_scale: false,
  category: "activity"
};
const slot_machine = {
  keywords: [
    "bet",
    "gamble",
    "vegas",
    "fruit machine",
    "luck",
    "casino"
  ],
  char: "🎰",
  fitzpatrick_scale: false,
  category: "activity"
};
const jigsaw = {
  keywords: [
    "interlocking",
    "puzzle",
    "piece"
  ],
  char: "🧩",
  fitzpatrick_scale: false,
  category: "activity"
};
const bowling = {
  keywords: [
    "sports",
    "fun",
    "play"
  ],
  char: "🎳",
  fitzpatrick_scale: false,
  category: "activity"
};
const red_car = {
  keywords: [
    "red",
    "transportation",
    "vehicle"
  ],
  char: "🚗",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const taxi = {
  keywords: [
    "uber",
    "vehicle",
    "cars",
    "transportation"
  ],
  char: "🚕",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const blue_car = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚙",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const bus = {
  keywords: [
    "car",
    "vehicle",
    "transportation"
  ],
  char: "🚌",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const trolleybus = {
  keywords: [
    "bart",
    "transportation",
    "vehicle"
  ],
  char: "🚎",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const racing_car = {
  keywords: [
    "sports",
    "race",
    "fast",
    "formula",
    "f1"
  ],
  char: "🏎",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const police_car = {
  keywords: [
    "vehicle",
    "cars",
    "transportation",
    "law",
    "legal",
    "enforcement"
  ],
  char: "🚓",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const ambulance = {
  keywords: [
    "health",
    "911",
    "hospital"
  ],
  char: "🚑",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const fire_engine = {
  keywords: [
    "transportation",
    "cars",
    "vehicle"
  ],
  char: "🚒",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const minibus = {
  keywords: [
    "vehicle",
    "car",
    "transportation"
  ],
  char: "🚐",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const truck = {
  keywords: [
    "cars",
    "transportation"
  ],
  char: "🚚",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const articulated_lorry = {
  keywords: [
    "vehicle",
    "cars",
    "transportation",
    "express"
  ],
  char: "🚛",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const tractor = {
  keywords: [
    "vehicle",
    "car",
    "farming",
    "agriculture"
  ],
  char: "🚜",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const kick_scooter = {
  keywords: [
    "vehicle",
    "kick",
    "razor"
  ],
  char: "🛴",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const motorcycle = {
  keywords: [
    "race",
    "sports",
    "fast"
  ],
  char: "🏍",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const bike = {
  keywords: [
    "sports",
    "bicycle",
    "exercise",
    "hipster"
  ],
  char: "🚲",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const motor_scooter = {
  keywords: [
    "vehicle",
    "vespa",
    "sasha"
  ],
  char: "🛵",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const rotating_light = {
  keywords: [
    "police",
    "ambulance",
    "911",
    "emergency",
    "alert",
    "error",
    "pinged",
    "law",
    "legal"
  ],
  char: "🚨",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const oncoming_police_car = {
  keywords: [
    "vehicle",
    "law",
    "legal",
    "enforcement",
    "911"
  ],
  char: "🚔",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const oncoming_bus = {
  keywords: [
    "vehicle",
    "transportation"
  ],
  char: "🚍",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const oncoming_automobile = {
  keywords: [
    "car",
    "vehicle",
    "transportation"
  ],
  char: "🚘",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const oncoming_taxi = {
  keywords: [
    "vehicle",
    "cars",
    "uber"
  ],
  char: "🚖",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const aerial_tramway = {
  keywords: [
    "transportation",
    "vehicle",
    "ski"
  ],
  char: "🚡",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const mountain_cableway = {
  keywords: [
    "transportation",
    "vehicle",
    "ski"
  ],
  char: "🚠",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const suspension_railway = {
  keywords: [
    "vehicle",
    "transportation"
  ],
  char: "🚟",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const railway_car = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚃",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const train = {
  keywords: [
    "transportation",
    "vehicle",
    "carriage",
    "public",
    "travel"
  ],
  char: "🚋",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const monorail = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚝",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const bullettrain_side = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚄",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const bullettrain_front = {
  keywords: [
    "transportation",
    "vehicle",
    "speed",
    "fast",
    "public",
    "travel"
  ],
  char: "🚅",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const light_rail = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚈",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const mountain_railway = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚞",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const steam_locomotive = {
  keywords: [
    "transportation",
    "vehicle",
    "train"
  ],
  char: "🚂",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const train2 = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚆",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const metro = {
  keywords: [
    "transportation",
    "blue-square",
    "mrt",
    "underground",
    "tube"
  ],
  char: "🚇",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const tram = {
  keywords: [
    "transportation",
    "vehicle"
  ],
  char: "🚊",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const station = {
  keywords: [
    "transportation",
    "vehicle",
    "public"
  ],
  char: "🚉",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const flying_saucer = {
  keywords: [
    "transportation",
    "vehicle",
    "ufo"
  ],
  char: "🛸",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const helicopter = {
  keywords: [
    "transportation",
    "vehicle",
    "fly"
  ],
  char: "🚁",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const small_airplane = {
  keywords: [
    "flight",
    "transportation",
    "fly",
    "vehicle"
  ],
  char: "🛩",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const airplane = {
  keywords: [
    "vehicle",
    "transportation",
    "flight",
    "fly"
  ],
  char: "✈️",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const flight_departure = {
  keywords: [
    "airport",
    "flight",
    "landing"
  ],
  char: "🛫",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const flight_arrival = {
  keywords: [
    "airport",
    "flight",
    "boarding"
  ],
  char: "🛬",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const sailboat = {
  keywords: [
    "ship",
    "summer",
    "transportation",
    "water",
    "sailing"
  ],
  char: "⛵",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const motor_boat = {
  keywords: [
    "ship"
  ],
  char: "🛥",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const speedboat = {
  keywords: [
    "ship",
    "transportation",
    "vehicle",
    "summer"
  ],
  char: "🚤",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const ferry = {
  keywords: [
    "boat",
    "ship",
    "yacht"
  ],
  char: "⛴",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const passenger_ship = {
  keywords: [
    "yacht",
    "cruise",
    "ferry"
  ],
  char: "🛳",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const rocket = {
  keywords: [
    "launch",
    "ship",
    "staffmode",
    "NASA",
    "outer space",
    "outer_space",
    "fly"
  ],
  char: "🚀",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const artificial_satellite = {
  keywords: [
    "communication",
    "gps",
    "orbit",
    "spaceflight",
    "NASA",
    "ISS"
  ],
  char: "🛰",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const seat = {
  keywords: [
    "sit",
    "airplane",
    "transport",
    "bus",
    "flight",
    "fly"
  ],
  char: "💺",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const canoe = {
  keywords: [
    "boat",
    "paddle",
    "water",
    "ship"
  ],
  char: "🛶",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const anchor = {
  keywords: [
    "ship",
    "ferry",
    "sea",
    "boat"
  ],
  char: "⚓",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const construction = {
  keywords: [
    "wip",
    "progress",
    "caution",
    "warning"
  ],
  char: "🚧",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const fuelpump = {
  keywords: [
    "gas station",
    "petroleum"
  ],
  char: "⛽",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const busstop = {
  keywords: [
    "transportation",
    "wait"
  ],
  char: "🚏",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const vertical_traffic_light = {
  keywords: [
    "transportation",
    "driving"
  ],
  char: "🚦",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const traffic_light = {
  keywords: [
    "transportation",
    "signal"
  ],
  char: "🚥",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const checkered_flag = {
  keywords: [
    "contest",
    "finishline",
    "race",
    "gokart"
  ],
  char: "🏁",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const ship = {
  keywords: [
    "transportation",
    "titanic",
    "deploy"
  ],
  char: "🚢",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const ferris_wheel = {
  keywords: [
    "photo",
    "carnival",
    "londoneye"
  ],
  char: "🎡",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const roller_coaster = {
  keywords: [
    "carnival",
    "playground",
    "photo",
    "fun"
  ],
  char: "🎢",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const carousel_horse = {
  keywords: [
    "photo",
    "carnival"
  ],
  char: "🎠",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const building_construction = {
  keywords: [
    "wip",
    "working",
    "progress"
  ],
  char: "🏗",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const foggy = {
  keywords: [
    "photo",
    "mountain"
  ],
  char: "🌁",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const tokyo_tower = {
  keywords: [
    "photo",
    "japanese"
  ],
  char: "🗼",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const factory = {
  keywords: [
    "building",
    "industry",
    "pollution",
    "smoke"
  ],
  char: "🏭",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const fountain = {
  keywords: [
    "photo",
    "summer",
    "water",
    "fresh"
  ],
  char: "⛲",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const rice_scene = {
  keywords: [
    "photo",
    "japan",
    "asia",
    "tsukimi"
  ],
  char: "🎑",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const mountain = {
  keywords: [
    "photo",
    "nature",
    "environment"
  ],
  char: "⛰",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const mountain_snow = {
  keywords: [
    "photo",
    "nature",
    "environment",
    "winter",
    "cold"
  ],
  char: "🏔",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const mount_fuji = {
  keywords: [
    "photo",
    "mountain",
    "nature",
    "japanese"
  ],
  char: "🗻",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const volcano = {
  keywords: [
    "photo",
    "nature",
    "disaster"
  ],
  char: "🌋",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const japan = {
  keywords: [
    "nation",
    "country",
    "japanese",
    "asia"
  ],
  char: "🗾",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const camping = {
  keywords: [
    "photo",
    "outdoors",
    "tent"
  ],
  char: "🏕",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const tent = {
  keywords: [
    "photo",
    "camping",
    "outdoors"
  ],
  char: "⛺",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const national_park = {
  keywords: [
    "photo",
    "environment",
    "nature"
  ],
  char: "🏞",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const motorway = {
  keywords: [
    "road",
    "cupertino",
    "interstate",
    "highway"
  ],
  char: "🛣",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const railway_track = {
  keywords: [
    "train",
    "transportation"
  ],
  char: "🛤",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const sunrise = {
  keywords: [
    "morning",
    "view",
    "vacation",
    "photo"
  ],
  char: "🌅",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const sunrise_over_mountains = {
  keywords: [
    "view",
    "vacation",
    "photo"
  ],
  char: "🌄",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const desert = {
  keywords: [
    "photo",
    "warm",
    "saharah"
  ],
  char: "🏜",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const beach_umbrella = {
  keywords: [
    "weather",
    "summer",
    "sunny",
    "sand",
    "mojito"
  ],
  char: "🏖",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const desert_island = {
  keywords: [
    "photo",
    "tropical",
    "mojito"
  ],
  char: "🏝",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const city_sunrise = {
  keywords: [
    "photo",
    "good morning",
    "dawn"
  ],
  char: "🌇",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const city_sunset = {
  keywords: [
    "photo",
    "evening",
    "sky",
    "buildings"
  ],
  char: "🌆",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const cityscape = {
  keywords: [
    "photo",
    "night life",
    "urban"
  ],
  char: "🏙",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const night_with_stars = {
  keywords: [
    "evening",
    "city",
    "downtown"
  ],
  char: "🌃",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const bridge_at_night = {
  keywords: [
    "photo",
    "sanfrancisco"
  ],
  char: "🌉",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const milky_way = {
  keywords: [
    "photo",
    "space",
    "stars"
  ],
  char: "🌌",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const stars = {
  keywords: [
    "night",
    "photo"
  ],
  char: "🌠",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const sparkler = {
  keywords: [
    "stars",
    "night",
    "shine"
  ],
  char: "🎇",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const fireworks = {
  keywords: [
    "photo",
    "festival",
    "carnival",
    "congratulations"
  ],
  char: "🎆",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const rainbow = {
  keywords: [
    "nature",
    "happy",
    "unicorn_face",
    "photo",
    "sky",
    "spring"
  ],
  char: "🌈",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const houses = {
  keywords: [
    "buildings",
    "photo"
  ],
  char: "🏘",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const european_castle = {
  keywords: [
    "building",
    "royalty",
    "history"
  ],
  char: "🏰",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const japanese_castle = {
  keywords: [
    "photo",
    "building"
  ],
  char: "🏯",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const stadium = {
  keywords: [
    "photo",
    "place",
    "sports",
    "concert",
    "venue"
  ],
  char: "🏟",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const statue_of_liberty = {
  keywords: [
    "american",
    "newyork"
  ],
  char: "🗽",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const house = {
  keywords: [
    "building",
    "home"
  ],
  char: "🏠",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const house_with_garden = {
  keywords: [
    "home",
    "plant",
    "nature"
  ],
  char: "🏡",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const derelict_house = {
  keywords: [
    "abandon",
    "evict",
    "broken",
    "building"
  ],
  char: "🏚",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const office = {
  keywords: [
    "building",
    "bureau",
    "work"
  ],
  char: "🏢",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const department_store = {
  keywords: [
    "building",
    "shopping",
    "mall"
  ],
  char: "🏬",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const post_office = {
  keywords: [
    "building",
    "envelope",
    "communication"
  ],
  char: "🏣",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const european_post_office = {
  keywords: [
    "building",
    "email"
  ],
  char: "🏤",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const hospital = {
  keywords: [
    "building",
    "health",
    "surgery",
    "doctor"
  ],
  char: "🏥",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const bank = {
  keywords: [
    "building",
    "money",
    "sales",
    "cash",
    "business",
    "enterprise"
  ],
  char: "🏦",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const hotel = {
  keywords: [
    "building",
    "accomodation",
    "checkin"
  ],
  char: "🏨",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const convenience_store = {
  keywords: [
    "building",
    "shopping",
    "groceries"
  ],
  char: "🏪",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const school = {
  keywords: [
    "building",
    "student",
    "education",
    "learn",
    "teach"
  ],
  char: "🏫",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const love_hotel = {
  keywords: [
    "like",
    "affection",
    "dating"
  ],
  char: "🏩",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const wedding = {
  keywords: [
    "love",
    "like",
    "affection",
    "couple",
    "marriage",
    "bride",
    "groom"
  ],
  char: "💒",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const classical_building = {
  keywords: [
    "art",
    "culture",
    "history"
  ],
  char: "🏛",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const church = {
  keywords: [
    "building",
    "religion",
    "christ"
  ],
  char: "⛪",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const mosque = {
  keywords: [
    "islam",
    "worship",
    "minaret"
  ],
  char: "🕌",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const synagogue = {
  keywords: [
    "judaism",
    "worship",
    "temple",
    "jewish"
  ],
  char: "🕍",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const kaaba = {
  keywords: [
    "mecca",
    "mosque",
    "islam"
  ],
  char: "🕋",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const shinto_shrine = {
  keywords: [
    "temple",
    "japan",
    "kyoto"
  ],
  char: "⛩",
  fitzpatrick_scale: false,
  category: "travel_and_places"
};
const watch = {
  keywords: [
    "time",
    "accessories"
  ],
  char: "⌚",
  fitzpatrick_scale: false,
  category: "objects"
};
const iphone = {
  keywords: [
    "technology",
    "apple",
    "gadgets",
    "dial"
  ],
  char: "📱",
  fitzpatrick_scale: false,
  category: "objects"
};
const calling = {
  keywords: [
    "iphone",
    "incoming"
  ],
  char: "📲",
  fitzpatrick_scale: false,
  category: "objects"
};
const computer = {
  keywords: [
    "technology",
    "laptop",
    "screen",
    "display",
    "monitor"
  ],
  char: "💻",
  fitzpatrick_scale: false,
  category: "objects"
};
const keyboard = {
  keywords: [
    "technology",
    "computer",
    "type",
    "input",
    "text"
  ],
  char: "⌨",
  fitzpatrick_scale: false,
  category: "objects"
};
const desktop_computer = {
  keywords: [
    "technology",
    "computing",
    "screen"
  ],
  char: "🖥",
  fitzpatrick_scale: false,
  category: "objects"
};
const printer = {
  keywords: [
    "paper",
    "ink"
  ],
  char: "🖨",
  fitzpatrick_scale: false,
  category: "objects"
};
const computer_mouse = {
  keywords: [
    "click"
  ],
  char: "🖱",
  fitzpatrick_scale: false,
  category: "objects"
};
const trackball = {
  keywords: [
    "technology",
    "trackpad"
  ],
  char: "🖲",
  fitzpatrick_scale: false,
  category: "objects"
};
const joystick = {
  keywords: [
    "game",
    "play"
  ],
  char: "🕹",
  fitzpatrick_scale: false,
  category: "objects"
};
const clamp = {
  keywords: [
    "tool"
  ],
  char: "🗜",
  fitzpatrick_scale: false,
  category: "objects"
};
const minidisc = {
  keywords: [
    "technology",
    "record",
    "data",
    "disk",
    "90s"
  ],
  char: "💽",
  fitzpatrick_scale: false,
  category: "objects"
};
const floppy_disk = {
  keywords: [
    "oldschool",
    "technology",
    "save",
    "90s",
    "80s"
  ],
  char: "💾",
  fitzpatrick_scale: false,
  category: "objects"
};
const cd = {
  keywords: [
    "technology",
    "dvd",
    "disk",
    "disc",
    "90s"
  ],
  char: "💿",
  fitzpatrick_scale: false,
  category: "objects"
};
const dvd = {
  keywords: [
    "cd",
    "disk",
    "disc"
  ],
  char: "📀",
  fitzpatrick_scale: false,
  category: "objects"
};
const vhs = {
  keywords: [
    "record",
    "video",
    "oldschool",
    "90s",
    "80s"
  ],
  char: "📼",
  fitzpatrick_scale: false,
  category: "objects"
};
const camera = {
  keywords: [
    "gadgets",
    "photography"
  ],
  char: "📷",
  fitzpatrick_scale: false,
  category: "objects"
};
const camera_flash = {
  keywords: [
    "photography",
    "gadgets"
  ],
  char: "📸",
  fitzpatrick_scale: false,
  category: "objects"
};
const video_camera = {
  keywords: [
    "film",
    "record"
  ],
  char: "📹",
  fitzpatrick_scale: false,
  category: "objects"
};
const movie_camera = {
  keywords: [
    "film",
    "record"
  ],
  char: "🎥",
  fitzpatrick_scale: false,
  category: "objects"
};
const film_projector = {
  keywords: [
    "video",
    "tape",
    "record",
    "movie"
  ],
  char: "📽",
  fitzpatrick_scale: false,
  category: "objects"
};
const film_strip = {
  keywords: [
    "movie"
  ],
  char: "🎞",
  fitzpatrick_scale: false,
  category: "objects"
};
const telephone_receiver = {
  keywords: [
    "technology",
    "communication",
    "dial"
  ],
  char: "📞",
  fitzpatrick_scale: false,
  category: "objects"
};
const phone = {
  keywords: [
    "technology",
    "communication",
    "dial",
    "telephone"
  ],
  char: "☎️",
  fitzpatrick_scale: false,
  category: "objects"
};
const pager = {
  keywords: [
    "bbcall",
    "oldschool",
    "90s"
  ],
  char: "📟",
  fitzpatrick_scale: false,
  category: "objects"
};
const fax = {
  keywords: [
    "communication",
    "technology"
  ],
  char: "📠",
  fitzpatrick_scale: false,
  category: "objects"
};
const tv = {
  keywords: [
    "technology",
    "program",
    "oldschool",
    "show",
    "television"
  ],
  char: "📺",
  fitzpatrick_scale: false,
  category: "objects"
};
const radio = {
  keywords: [
    "communication",
    "music",
    "podcast",
    "program"
  ],
  char: "📻",
  fitzpatrick_scale: false,
  category: "objects"
};
const studio_microphone = {
  keywords: [
    "sing",
    "recording",
    "artist",
    "talkshow"
  ],
  char: "🎙",
  fitzpatrick_scale: false,
  category: "objects"
};
const level_slider = {
  keywords: [
    "scale"
  ],
  char: "🎚",
  fitzpatrick_scale: false,
  category: "objects"
};
const control_knobs = {
  keywords: [
    "dial"
  ],
  char: "🎛",
  fitzpatrick_scale: false,
  category: "objects"
};
const compass = {
  keywords: [
    "magnetic",
    "navigation",
    "orienteering"
  ],
  char: "🧭",
  fitzpatrick_scale: false,
  category: "objects"
};
const stopwatch = {
  keywords: [
    "time",
    "deadline"
  ],
  char: "⏱",
  fitzpatrick_scale: false,
  category: "objects"
};
const timer_clock = {
  keywords: [
    "alarm"
  ],
  char: "⏲",
  fitzpatrick_scale: false,
  category: "objects"
};
const alarm_clock = {
  keywords: [
    "time",
    "wake"
  ],
  char: "⏰",
  fitzpatrick_scale: false,
  category: "objects"
};
const mantelpiece_clock = {
  keywords: [
    "time"
  ],
  char: "🕰",
  fitzpatrick_scale: false,
  category: "objects"
};
const hourglass_flowing_sand = {
  keywords: [
    "oldschool",
    "time",
    "countdown"
  ],
  char: "⏳",
  fitzpatrick_scale: false,
  category: "objects"
};
const hourglass = {
  keywords: [
    "time",
    "clock",
    "oldschool",
    "limit",
    "exam",
    "quiz",
    "test"
  ],
  char: "⌛",
  fitzpatrick_scale: false,
  category: "objects"
};
const satellite = {
  keywords: [
    "communication",
    "future",
    "radio",
    "space"
  ],
  char: "📡",
  fitzpatrick_scale: false,
  category: "objects"
};
const battery = {
  keywords: [
    "power",
    "energy",
    "sustain"
  ],
  char: "🔋",
  fitzpatrick_scale: false,
  category: "objects"
};
const electric_plug = {
  keywords: [
    "charger",
    "power"
  ],
  char: "🔌",
  fitzpatrick_scale: false,
  category: "objects"
};
const bulb = {
  keywords: [
    "light",
    "electricity",
    "idea"
  ],
  char: "💡",
  fitzpatrick_scale: false,
  category: "objects"
};
const flashlight = {
  keywords: [
    "dark",
    "camping",
    "sight",
    "night"
  ],
  char: "🔦",
  fitzpatrick_scale: false,
  category: "objects"
};
const candle = {
  keywords: [
    "fire",
    "wax"
  ],
  char: "🕯",
  fitzpatrick_scale: false,
  category: "objects"
};
const fire_extinguisher = {
  keywords: [
    "quench"
  ],
  char: "🧯",
  fitzpatrick_scale: false,
  category: "objects"
};
const wastebasket = {
  keywords: [
    "bin",
    "trash",
    "rubbish",
    "garbage",
    "toss"
  ],
  char: "🗑",
  fitzpatrick_scale: false,
  category: "objects"
};
const oil_drum = {
  keywords: [
    "barrell"
  ],
  char: "🛢",
  fitzpatrick_scale: false,
  category: "objects"
};
const money_with_wings = {
  keywords: [
    "dollar",
    "bills",
    "payment",
    "sale"
  ],
  char: "💸",
  fitzpatrick_scale: false,
  category: "objects"
};
const dollar = {
  keywords: [
    "money",
    "sales",
    "bill",
    "currency"
  ],
  char: "💵",
  fitzpatrick_scale: false,
  category: "objects"
};
const yen = {
  keywords: [
    "money",
    "sales",
    "japanese",
    "dollar",
    "currency"
  ],
  char: "💴",
  fitzpatrick_scale: false,
  category: "objects"
};
const euro = {
  keywords: [
    "money",
    "sales",
    "dollar",
    "currency"
  ],
  char: "💶",
  fitzpatrick_scale: false,
  category: "objects"
};
const pound = {
  keywords: [
    "british",
    "sterling",
    "money",
    "sales",
    "bills",
    "uk",
    "england",
    "currency"
  ],
  char: "💷",
  fitzpatrick_scale: false,
  category: "objects"
};
const moneybag = {
  keywords: [
    "dollar",
    "payment",
    "coins",
    "sale"
  ],
  char: "💰",
  fitzpatrick_scale: false,
  category: "objects"
};
const credit_card = {
  keywords: [
    "money",
    "sales",
    "dollar",
    "bill",
    "payment",
    "shopping"
  ],
  char: "💳",
  fitzpatrick_scale: false,
  category: "objects"
};
const gem = {
  keywords: [
    "blue",
    "ruby",
    "diamond",
    "jewelry"
  ],
  char: "💎",
  fitzpatrick_scale: false,
  category: "objects"
};
const balance_scale = {
  keywords: [
    "law",
    "fairness",
    "weight"
  ],
  char: "⚖",
  fitzpatrick_scale: false,
  category: "objects"
};
const toolbox = {
  keywords: [
    "tools",
    "diy",
    "fix",
    "maintainer",
    "mechanic"
  ],
  char: "🧰",
  fitzpatrick_scale: false,
  category: "objects"
};
const wrench = {
  keywords: [
    "tools",
    "diy",
    "ikea",
    "fix",
    "maintainer"
  ],
  char: "🔧",
  fitzpatrick_scale: false,
  category: "objects"
};
const hammer = {
  keywords: [
    "tools",
    "build",
    "create"
  ],
  char: "🔨",
  fitzpatrick_scale: false,
  category: "objects"
};
const hammer_and_pick = {
  keywords: [
    "tools",
    "build",
    "create"
  ],
  char: "⚒",
  fitzpatrick_scale: false,
  category: "objects"
};
const hammer_and_wrench = {
  keywords: [
    "tools",
    "build",
    "create"
  ],
  char: "🛠",
  fitzpatrick_scale: false,
  category: "objects"
};
const pick = {
  keywords: [
    "tools",
    "dig"
  ],
  char: "⛏",
  fitzpatrick_scale: false,
  category: "objects"
};
const nut_and_bolt = {
  keywords: [
    "handy",
    "tools",
    "fix"
  ],
  char: "🔩",
  fitzpatrick_scale: false,
  category: "objects"
};
const gear = {
  keywords: [
    "cog"
  ],
  char: "⚙",
  fitzpatrick_scale: false,
  category: "objects"
};
const brick = {
  keywords: [
    "bricks"
  ],
  char: "🧱",
  fitzpatrick_scale: false,
  category: "objects"
};
const chains = {
  keywords: [
    "lock",
    "arrest"
  ],
  char: "⛓",
  fitzpatrick_scale: false,
  category: "objects"
};
const magnet = {
  keywords: [
    "attraction",
    "magnetic"
  ],
  char: "🧲",
  fitzpatrick_scale: false,
  category: "objects"
};
const gun = {
  keywords: [
    "violence",
    "weapon",
    "pistol",
    "revolver"
  ],
  char: "🔫",
  fitzpatrick_scale: false,
  category: "objects"
};
const bomb = {
  keywords: [
    "boom",
    "explode",
    "explosion",
    "terrorism"
  ],
  char: "💣",
  fitzpatrick_scale: false,
  category: "objects"
};
const firecracker = {
  keywords: [
    "dynamite",
    "boom",
    "explode",
    "explosion",
    "explosive"
  ],
  char: "🧨",
  fitzpatrick_scale: false,
  category: "objects"
};
const hocho = {
  keywords: [
    "knife",
    "blade",
    "cutlery",
    "kitchen",
    "weapon"
  ],
  char: "🔪",
  fitzpatrick_scale: false,
  category: "objects"
};
const dagger = {
  keywords: [
    "weapon"
  ],
  char: "🗡",
  fitzpatrick_scale: false,
  category: "objects"
};
const crossed_swords = {
  keywords: [
    "weapon"
  ],
  char: "⚔",
  fitzpatrick_scale: false,
  category: "objects"
};
const shield = {
  keywords: [
    "protection",
    "security"
  ],
  char: "🛡",
  fitzpatrick_scale: false,
  category: "objects"
};
const smoking = {
  keywords: [
    "kills",
    "tobacco",
    "cigarette",
    "joint",
    "smoke"
  ],
  char: "🚬",
  fitzpatrick_scale: false,
  category: "objects"
};
const skull_and_crossbones = {
  keywords: [
    "poison",
    "danger",
    "deadly",
    "scary",
    "death",
    "pirate",
    "evil"
  ],
  char: "☠",
  fitzpatrick_scale: false,
  category: "objects"
};
const coffin = {
  keywords: [
    "vampire",
    "dead",
    "die",
    "death",
    "rip",
    "graveyard",
    "cemetery",
    "casket",
    "funeral",
    "box"
  ],
  char: "⚰",
  fitzpatrick_scale: false,
  category: "objects"
};
const funeral_urn = {
  keywords: [
    "dead",
    "die",
    "death",
    "rip",
    "ashes"
  ],
  char: "⚱",
  fitzpatrick_scale: false,
  category: "objects"
};
const amphora = {
  keywords: [
    "vase",
    "jar"
  ],
  char: "🏺",
  fitzpatrick_scale: false,
  category: "objects"
};
const crystal_ball = {
  keywords: [
    "disco",
    "party",
    "magic",
    "circus",
    "fortune_teller"
  ],
  char: "🔮",
  fitzpatrick_scale: false,
  category: "objects"
};
const prayer_beads = {
  keywords: [
    "dhikr",
    "religious"
  ],
  char: "📿",
  fitzpatrick_scale: false,
  category: "objects"
};
const nazar_amulet = {
  keywords: [
    "bead",
    "charm"
  ],
  char: "🧿",
  fitzpatrick_scale: false,
  category: "objects"
};
const barber = {
  keywords: [
    "hair",
    "salon",
    "style"
  ],
  char: "💈",
  fitzpatrick_scale: false,
  category: "objects"
};
const alembic = {
  keywords: [
    "distilling",
    "science",
    "experiment",
    "chemistry"
  ],
  char: "⚗",
  fitzpatrick_scale: false,
  category: "objects"
};
const telescope = {
  keywords: [
    "stars",
    "space",
    "zoom",
    "science",
    "astronomy"
  ],
  char: "🔭",
  fitzpatrick_scale: false,
  category: "objects"
};
const microscope = {
  keywords: [
    "laboratory",
    "experiment",
    "zoomin",
    "science",
    "study"
  ],
  char: "🔬",
  fitzpatrick_scale: false,
  category: "objects"
};
const hole = {
  keywords: [
    "embarrassing"
  ],
  char: "🕳",
  fitzpatrick_scale: false,
  category: "objects"
};
const pill = {
  keywords: [
    "health",
    "medicine",
    "doctor",
    "pharmacy",
    "drug"
  ],
  char: "💊",
  fitzpatrick_scale: false,
  category: "objects"
};
const syringe = {
  keywords: [
    "health",
    "hospital",
    "drugs",
    "blood",
    "medicine",
    "needle",
    "doctor",
    "nurse"
  ],
  char: "💉",
  fitzpatrick_scale: false,
  category: "objects"
};
const dna = {
  keywords: [
    "biologist",
    "genetics",
    "life"
  ],
  char: "🧬",
  fitzpatrick_scale: false,
  category: "objects"
};
const microbe = {
  keywords: [
    "amoeba",
    "bacteria",
    "germs"
  ],
  char: "🦠",
  fitzpatrick_scale: false,
  category: "objects"
};
const petri_dish = {
  keywords: [
    "bacteria",
    "biology",
    "culture",
    "lab"
  ],
  char: "🧫",
  fitzpatrick_scale: false,
  category: "objects"
};
const test_tube = {
  keywords: [
    "chemistry",
    "experiment",
    "lab",
    "science"
  ],
  char: "🧪",
  fitzpatrick_scale: false,
  category: "objects"
};
const thermometer = {
  keywords: [
    "weather",
    "temperature",
    "hot",
    "cold"
  ],
  char: "🌡",
  fitzpatrick_scale: false,
  category: "objects"
};
const broom = {
  keywords: [
    "cleaning",
    "sweeping",
    "witch"
  ],
  char: "🧹",
  fitzpatrick_scale: false,
  category: "objects"
};
const basket = {
  keywords: [
    "laundry"
  ],
  char: "🧺",
  fitzpatrick_scale: false,
  category: "objects"
};
const toilet_paper = {
  keywords: [
    "roll"
  ],
  char: "🧻",
  fitzpatrick_scale: false,
  category: "objects"
};
const label = {
  keywords: [
    "sale",
    "tag"
  ],
  char: "🏷",
  fitzpatrick_scale: false,
  category: "objects"
};
const bookmark = {
  keywords: [
    "favorite",
    "label",
    "save"
  ],
  char: "🔖",
  fitzpatrick_scale: false,
  category: "objects"
};
const toilet = {
  keywords: [
    "restroom",
    "wc",
    "washroom",
    "bathroom",
    "potty"
  ],
  char: "🚽",
  fitzpatrick_scale: false,
  category: "objects"
};
const shower = {
  keywords: [
    "clean",
    "water",
    "bathroom"
  ],
  char: "🚿",
  fitzpatrick_scale: false,
  category: "objects"
};
const bathtub = {
  keywords: [
    "clean",
    "shower",
    "bathroom"
  ],
  char: "🛁",
  fitzpatrick_scale: false,
  category: "objects"
};
const soap = {
  keywords: [
    "bar",
    "bathing",
    "cleaning",
    "lather"
  ],
  char: "🧼",
  fitzpatrick_scale: false,
  category: "objects"
};
const sponge = {
  keywords: [
    "absorbing",
    "cleaning",
    "porous"
  ],
  char: "🧽",
  fitzpatrick_scale: false,
  category: "objects"
};
const lotion_bottle = {
  keywords: [
    "moisturizer",
    "sunscreen"
  ],
  char: "🧴",
  fitzpatrick_scale: false,
  category: "objects"
};
const key = {
  keywords: [
    "lock",
    "door",
    "password"
  ],
  char: "🔑",
  fitzpatrick_scale: false,
  category: "objects"
};
const old_key = {
  keywords: [
    "lock",
    "door",
    "password"
  ],
  char: "🗝",
  fitzpatrick_scale: false,
  category: "objects"
};
const couch_and_lamp = {
  keywords: [
    "read",
    "chill"
  ],
  char: "🛋",
  fitzpatrick_scale: false,
  category: "objects"
};
const sleeping_bed = {
  keywords: [
    "bed",
    "rest"
  ],
  char: "🛌",
  fitzpatrick_scale: true,
  category: "objects"
};
const bed = {
  keywords: [
    "sleep",
    "rest"
  ],
  char: "🛏",
  fitzpatrick_scale: false,
  category: "objects"
};
const door = {
  keywords: [
    "house",
    "entry",
    "exit"
  ],
  char: "🚪",
  fitzpatrick_scale: false,
  category: "objects"
};
const bellhop_bell = {
  keywords: [
    "service"
  ],
  char: "🛎",
  fitzpatrick_scale: false,
  category: "objects"
};
const teddy_bear = {
  keywords: [
    "plush",
    "stuffed"
  ],
  char: "🧸",
  fitzpatrick_scale: false,
  category: "objects"
};
const framed_picture = {
  keywords: [
    "photography"
  ],
  char: "🖼",
  fitzpatrick_scale: false,
  category: "objects"
};
const world_map = {
  keywords: [
    "location",
    "direction"
  ],
  char: "🗺",
  fitzpatrick_scale: false,
  category: "objects"
};
const parasol_on_ground = {
  keywords: [
    "weather",
    "summer"
  ],
  char: "⛱",
  fitzpatrick_scale: false,
  category: "objects"
};
const moyai = {
  keywords: [
    "rock",
    "easter island",
    "moai"
  ],
  char: "🗿",
  fitzpatrick_scale: false,
  category: "objects"
};
const shopping = {
  keywords: [
    "mall",
    "buy",
    "purchase"
  ],
  char: "🛍",
  fitzpatrick_scale: false,
  category: "objects"
};
const shopping_cart = {
  keywords: [
    "trolley"
  ],
  char: "🛒",
  fitzpatrick_scale: false,
  category: "objects"
};
const balloon = {
  keywords: [
    "party",
    "celebration",
    "birthday",
    "circus"
  ],
  char: "🎈",
  fitzpatrick_scale: false,
  category: "objects"
};
const flags = {
  keywords: [
    "fish",
    "japanese",
    "koinobori",
    "carp",
    "banner"
  ],
  char: "🎏",
  fitzpatrick_scale: false,
  category: "objects"
};
const ribbon = {
  keywords: [
    "decoration",
    "pink",
    "girl",
    "bowtie"
  ],
  char: "🎀",
  fitzpatrick_scale: false,
  category: "objects"
};
const gift = {
  keywords: [
    "present",
    "birthday",
    "christmas",
    "xmas"
  ],
  char: "🎁",
  fitzpatrick_scale: false,
  category: "objects"
};
const confetti_ball = {
  keywords: [
    "festival",
    "party",
    "birthday",
    "circus"
  ],
  char: "🎊",
  fitzpatrick_scale: false,
  category: "objects"
};
const tada = {
  keywords: [
    "party",
    "congratulations",
    "birthday",
    "magic",
    "circus",
    "celebration"
  ],
  char: "🎉",
  fitzpatrick_scale: false,
  category: "objects"
};
const dolls = {
  keywords: [
    "japanese",
    "toy",
    "kimono"
  ],
  char: "🎎",
  fitzpatrick_scale: false,
  category: "objects"
};
const wind_chime = {
  keywords: [
    "nature",
    "ding",
    "spring",
    "bell"
  ],
  char: "🎐",
  fitzpatrick_scale: false,
  category: "objects"
};
const crossed_flags = {
  keywords: [
    "japanese",
    "nation",
    "country",
    "border"
  ],
  char: "🎌",
  fitzpatrick_scale: false,
  category: "objects"
};
const izakaya_lantern = {
  keywords: [
    "light",
    "paper",
    "halloween",
    "spooky"
  ],
  char: "🏮",
  fitzpatrick_scale: false,
  category: "objects"
};
const red_envelope = {
  keywords: [
    "gift"
  ],
  char: "🧧",
  fitzpatrick_scale: false,
  category: "objects"
};
const email = {
  keywords: [
    "letter",
    "postal",
    "inbox",
    "communication"
  ],
  char: "✉️",
  fitzpatrick_scale: false,
  category: "objects"
};
const envelope_with_arrow = {
  keywords: [
    "email",
    "communication"
  ],
  char: "📩",
  fitzpatrick_scale: false,
  category: "objects"
};
const incoming_envelope = {
  keywords: [
    "email",
    "inbox"
  ],
  char: "📨",
  fitzpatrick_scale: false,
  category: "objects"
};
const love_letter = {
  keywords: [
    "email",
    "like",
    "affection",
    "envelope",
    "valentines"
  ],
  char: "💌",
  fitzpatrick_scale: false,
  category: "objects"
};
const postbox = {
  keywords: [
    "email",
    "letter",
    "envelope"
  ],
  char: "📮",
  fitzpatrick_scale: false,
  category: "objects"
};
const mailbox_closed = {
  keywords: [
    "email",
    "communication",
    "inbox"
  ],
  char: "📪",
  fitzpatrick_scale: false,
  category: "objects"
};
const mailbox = {
  keywords: [
    "email",
    "inbox",
    "communication"
  ],
  char: "📫",
  fitzpatrick_scale: false,
  category: "objects"
};
const mailbox_with_mail = {
  keywords: [
    "email",
    "inbox",
    "communication"
  ],
  char: "📬",
  fitzpatrick_scale: false,
  category: "objects"
};
const mailbox_with_no_mail = {
  keywords: [
    "email",
    "inbox"
  ],
  char: "📭",
  fitzpatrick_scale: false,
  category: "objects"
};
const postal_horn = {
  keywords: [
    "instrument",
    "music"
  ],
  char: "📯",
  fitzpatrick_scale: false,
  category: "objects"
};
const inbox_tray = {
  keywords: [
    "email",
    "documents"
  ],
  char: "📥",
  fitzpatrick_scale: false,
  category: "objects"
};
const outbox_tray = {
  keywords: [
    "inbox",
    "email"
  ],
  char: "📤",
  fitzpatrick_scale: false,
  category: "objects"
};
const scroll = {
  keywords: [
    "documents",
    "ancient",
    "history",
    "paper"
  ],
  char: "📜",
  fitzpatrick_scale: false,
  category: "objects"
};
const page_with_curl = {
  keywords: [
    "documents",
    "office",
    "paper"
  ],
  char: "📃",
  fitzpatrick_scale: false,
  category: "objects"
};
const bookmark_tabs = {
  keywords: [
    "favorite",
    "save",
    "order",
    "tidy"
  ],
  char: "📑",
  fitzpatrick_scale: false,
  category: "objects"
};
const receipt = {
  keywords: [
    "accounting",
    "expenses"
  ],
  char: "🧾",
  fitzpatrick_scale: false,
  category: "objects"
};
const bar_chart = {
  keywords: [
    "graph",
    "presentation",
    "stats"
  ],
  char: "📊",
  fitzpatrick_scale: false,
  category: "objects"
};
const chart_with_upwards_trend = {
  keywords: [
    "graph",
    "presentation",
    "stats",
    "recovery",
    "business",
    "economics",
    "money",
    "sales",
    "good",
    "success"
  ],
  char: "📈",
  fitzpatrick_scale: false,
  category: "objects"
};
const chart_with_downwards_trend = {
  keywords: [
    "graph",
    "presentation",
    "stats",
    "recession",
    "business",
    "economics",
    "money",
    "sales",
    "bad",
    "failure"
  ],
  char: "📉",
  fitzpatrick_scale: false,
  category: "objects"
};
const page_facing_up = {
  keywords: [
    "documents",
    "office",
    "paper",
    "information"
  ],
  char: "📄",
  fitzpatrick_scale: false,
  category: "objects"
};
const date = {
  keywords: [
    "calendar",
    "schedule"
  ],
  char: "📅",
  fitzpatrick_scale: false,
  category: "objects"
};
const calendar = {
  keywords: [
    "schedule",
    "date",
    "planning"
  ],
  char: "📆",
  fitzpatrick_scale: false,
  category: "objects"
};
const spiral_calendar = {
  keywords: [
    "date",
    "schedule",
    "planning"
  ],
  char: "🗓",
  fitzpatrick_scale: false,
  category: "objects"
};
const card_index = {
  keywords: [
    "business",
    "stationery"
  ],
  char: "📇",
  fitzpatrick_scale: false,
  category: "objects"
};
const card_file_box = {
  keywords: [
    "business",
    "stationery"
  ],
  char: "🗃",
  fitzpatrick_scale: false,
  category: "objects"
};
const ballot_box = {
  keywords: [
    "election",
    "vote"
  ],
  char: "🗳",
  fitzpatrick_scale: false,
  category: "objects"
};
const file_cabinet = {
  keywords: [
    "filing",
    "organizing"
  ],
  char: "🗄",
  fitzpatrick_scale: false,
  category: "objects"
};
const clipboard = {
  keywords: [
    "stationery",
    "documents"
  ],
  char: "📋",
  fitzpatrick_scale: false,
  category: "objects"
};
const spiral_notepad = {
  keywords: [
    "memo",
    "stationery"
  ],
  char: "🗒",
  fitzpatrick_scale: false,
  category: "objects"
};
const file_folder = {
  keywords: [
    "documents",
    "business",
    "office"
  ],
  char: "📁",
  fitzpatrick_scale: false,
  category: "objects"
};
const open_file_folder = {
  keywords: [
    "documents",
    "load"
  ],
  char: "📂",
  fitzpatrick_scale: false,
  category: "objects"
};
const card_index_dividers = {
  keywords: [
    "organizing",
    "business",
    "stationery"
  ],
  char: "🗂",
  fitzpatrick_scale: false,
  category: "objects"
};
const newspaper_roll = {
  keywords: [
    "press",
    "headline"
  ],
  char: "🗞",
  fitzpatrick_scale: false,
  category: "objects"
};
const newspaper = {
  keywords: [
    "press",
    "headline"
  ],
  char: "📰",
  fitzpatrick_scale: false,
  category: "objects"
};
const notebook = {
  keywords: [
    "stationery",
    "record",
    "notes",
    "paper",
    "study"
  ],
  char: "📓",
  fitzpatrick_scale: false,
  category: "objects"
};
const closed_book = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "textbook",
    "learn"
  ],
  char: "📕",
  fitzpatrick_scale: false,
  category: "objects"
};
const green_book = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "study"
  ],
  char: "📗",
  fitzpatrick_scale: false,
  category: "objects"
};
const blue_book = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "learn",
    "study"
  ],
  char: "📘",
  fitzpatrick_scale: false,
  category: "objects"
};
const orange_book = {
  keywords: [
    "read",
    "library",
    "knowledge",
    "textbook",
    "study"
  ],
  char: "📙",
  fitzpatrick_scale: false,
  category: "objects"
};
const notebook_with_decorative_cover = {
  keywords: [
    "classroom",
    "notes",
    "record",
    "paper",
    "study"
  ],
  char: "📔",
  fitzpatrick_scale: false,
  category: "objects"
};
const ledger = {
  keywords: [
    "notes",
    "paper"
  ],
  char: "📒",
  fitzpatrick_scale: false,
  category: "objects"
};
const books = {
  keywords: [
    "literature",
    "library",
    "study"
  ],
  char: "📚",
  fitzpatrick_scale: false,
  category: "objects"
};
const open_book = {
  keywords: [
    "book",
    "read",
    "library",
    "knowledge",
    "literature",
    "learn",
    "study"
  ],
  char: "📖",
  fitzpatrick_scale: false,
  category: "objects"
};
const safety_pin = {
  keywords: [
    "diaper"
  ],
  char: "🧷",
  fitzpatrick_scale: false,
  category: "objects"
};
const link$1 = {
  keywords: [
    "rings",
    "url"
  ],
  char: "🔗",
  fitzpatrick_scale: false,
  category: "objects"
};
const paperclip = {
  keywords: [
    "documents",
    "stationery"
  ],
  char: "📎",
  fitzpatrick_scale: false,
  category: "objects"
};
const paperclips = {
  keywords: [
    "documents",
    "stationery"
  ],
  char: "🖇",
  fitzpatrick_scale: false,
  category: "objects"
};
const scissors = {
  keywords: [
    "stationery",
    "cut"
  ],
  char: "✂️",
  fitzpatrick_scale: false,
  category: "objects"
};
const triangular_ruler = {
  keywords: [
    "stationery",
    "math",
    "architect",
    "sketch"
  ],
  char: "📐",
  fitzpatrick_scale: false,
  category: "objects"
};
const straight_ruler = {
  keywords: [
    "stationery",
    "calculate",
    "length",
    "math",
    "school",
    "drawing",
    "architect",
    "sketch"
  ],
  char: "📏",
  fitzpatrick_scale: false,
  category: "objects"
};
const abacus = {
  keywords: [
    "calculation"
  ],
  char: "🧮",
  fitzpatrick_scale: false,
  category: "objects"
};
const pushpin = {
  keywords: [
    "stationery",
    "mark",
    "here"
  ],
  char: "📌",
  fitzpatrick_scale: false,
  category: "objects"
};
const round_pushpin = {
  keywords: [
    "stationery",
    "location",
    "map",
    "here"
  ],
  char: "📍",
  fitzpatrick_scale: false,
  category: "objects"
};
const triangular_flag_on_post = {
  keywords: [
    "mark",
    "milestone",
    "place"
  ],
  char: "🚩",
  fitzpatrick_scale: false,
  category: "objects"
};
const white_flag = {
  keywords: [
    "losing",
    "loser",
    "lost",
    "surrender",
    "give up",
    "fail"
  ],
  char: "🏳",
  fitzpatrick_scale: false,
  category: "objects"
};
const black_flag = {
  keywords: [
    "pirate"
  ],
  char: "🏴",
  fitzpatrick_scale: false,
  category: "objects"
};
const rainbow_flag = {
  keywords: [
    "flag",
    "rainbow",
    "pride",
    "gay",
    "lgbt",
    "glbt",
    "queer",
    "homosexual",
    "lesbian",
    "bisexual",
    "transgender"
  ],
  char: "🏳️‍🌈",
  fitzpatrick_scale: false,
  category: "objects"
};
const closed_lock_with_key = {
  keywords: [
    "security",
    "privacy"
  ],
  char: "🔐",
  fitzpatrick_scale: false,
  category: "objects"
};
const lock = {
  keywords: [
    "security",
    "password",
    "padlock"
  ],
  char: "🔒",
  fitzpatrick_scale: false,
  category: "objects"
};
const unlock = {
  keywords: [
    "privacy",
    "security"
  ],
  char: "🔓",
  fitzpatrick_scale: false,
  category: "objects"
};
const lock_with_ink_pen = {
  keywords: [
    "security",
    "secret"
  ],
  char: "🔏",
  fitzpatrick_scale: false,
  category: "objects"
};
const pen = {
  keywords: [
    "stationery",
    "writing",
    "write"
  ],
  char: "🖊",
  fitzpatrick_scale: false,
  category: "objects"
};
const fountain_pen = {
  keywords: [
    "stationery",
    "writing",
    "write"
  ],
  char: "🖋",
  fitzpatrick_scale: false,
  category: "objects"
};
const black_nib = {
  keywords: [
    "pen",
    "stationery",
    "writing",
    "write"
  ],
  char: "✒️",
  fitzpatrick_scale: false,
  category: "objects"
};
const memo = {
  keywords: [
    "write",
    "documents",
    "stationery",
    "pencil",
    "paper",
    "writing",
    "legal",
    "exam",
    "quiz",
    "test",
    "study",
    "compose"
  ],
  char: "📝",
  fitzpatrick_scale: false,
  category: "objects"
};
const pencil2 = {
  keywords: [
    "stationery",
    "write",
    "paper",
    "writing",
    "school",
    "study"
  ],
  char: "✏️",
  fitzpatrick_scale: false,
  category: "objects"
};
const crayon = {
  keywords: [
    "drawing",
    "creativity"
  ],
  char: "🖍",
  fitzpatrick_scale: false,
  category: "objects"
};
const paintbrush = {
  keywords: [
    "drawing",
    "creativity",
    "art"
  ],
  char: "🖌",
  fitzpatrick_scale: false,
  category: "objects"
};
const mag = {
  keywords: [
    "search",
    "zoom",
    "find",
    "detective"
  ],
  char: "🔍",
  fitzpatrick_scale: false,
  category: "objects"
};
const mag_right = {
  keywords: [
    "search",
    "zoom",
    "find",
    "detective"
  ],
  char: "🔎",
  fitzpatrick_scale: false,
  category: "objects"
};
const heart = {
  keywords: [
    "love",
    "like",
    "valentines"
  ],
  char: "❤️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const orange_heart = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "🧡",
  fitzpatrick_scale: false,
  category: "symbols"
};
const yellow_heart = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💛",
  fitzpatrick_scale: false,
  category: "symbols"
};
const green_heart = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💚",
  fitzpatrick_scale: false,
  category: "symbols"
};
const blue_heart = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💙",
  fitzpatrick_scale: false,
  category: "symbols"
};
const purple_heart = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💜",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_heart = {
  keywords: [
    "evil"
  ],
  char: "🖤",
  fitzpatrick_scale: false,
  category: "symbols"
};
const broken_heart = {
  keywords: [
    "sad",
    "sorry",
    "break",
    "heart",
    "heartbreak"
  ],
  char: "💔",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_heart_exclamation = {
  keywords: [
    "decoration",
    "love"
  ],
  char: "❣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const two_hearts = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines",
    "heart"
  ],
  char: "💕",
  fitzpatrick_scale: false,
  category: "symbols"
};
const revolving_hearts = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💞",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heartbeat = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines",
    "pink",
    "heart"
  ],
  char: "💓",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heartpulse = {
  keywords: [
    "like",
    "love",
    "affection",
    "valentines",
    "pink"
  ],
  char: "💗",
  fitzpatrick_scale: false,
  category: "symbols"
};
const sparkling_heart = {
  keywords: [
    "love",
    "like",
    "affection",
    "valentines"
  ],
  char: "💖",
  fitzpatrick_scale: false,
  category: "symbols"
};
const cupid = {
  keywords: [
    "love",
    "like",
    "heart",
    "affection",
    "valentines"
  ],
  char: "💘",
  fitzpatrick_scale: false,
  category: "symbols"
};
const gift_heart = {
  keywords: [
    "love",
    "valentines"
  ],
  char: "💝",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heart_decoration = {
  keywords: [
    "purple-square",
    "love",
    "like"
  ],
  char: "💟",
  fitzpatrick_scale: false,
  category: "symbols"
};
const peace_symbol = {
  keywords: [
    "hippie"
  ],
  char: "☮",
  fitzpatrick_scale: false,
  category: "symbols"
};
const latin_cross = {
  keywords: [
    "christianity"
  ],
  char: "✝",
  fitzpatrick_scale: false,
  category: "symbols"
};
const star_and_crescent = {
  keywords: [
    "islam"
  ],
  char: "☪",
  fitzpatrick_scale: false,
  category: "symbols"
};
const om = {
  keywords: [
    "hinduism",
    "buddhism",
    "sikhism",
    "jainism"
  ],
  char: "🕉",
  fitzpatrick_scale: false,
  category: "symbols"
};
const wheel_of_dharma = {
  keywords: [
    "hinduism",
    "buddhism",
    "sikhism",
    "jainism"
  ],
  char: "☸",
  fitzpatrick_scale: false,
  category: "symbols"
};
const star_of_david = {
  keywords: [
    "judaism"
  ],
  char: "✡",
  fitzpatrick_scale: false,
  category: "symbols"
};
const six_pointed_star = {
  keywords: [
    "purple-square",
    "religion",
    "jewish",
    "hexagram"
  ],
  char: "🔯",
  fitzpatrick_scale: false,
  category: "symbols"
};
const menorah = {
  keywords: [
    "hanukkah",
    "candles",
    "jewish"
  ],
  char: "🕎",
  fitzpatrick_scale: false,
  category: "symbols"
};
const yin_yang = {
  keywords: [
    "balance"
  ],
  char: "☯",
  fitzpatrick_scale: false,
  category: "symbols"
};
const orthodox_cross = {
  keywords: [
    "suppedaneum",
    "religion"
  ],
  char: "☦",
  fitzpatrick_scale: false,
  category: "symbols"
};
const place_of_worship = {
  keywords: [
    "religion",
    "church",
    "temple",
    "prayer"
  ],
  char: "🛐",
  fitzpatrick_scale: false,
  category: "symbols"
};
const ophiuchus = {
  keywords: [
    "sign",
    "purple-square",
    "constellation",
    "astrology"
  ],
  char: "⛎",
  fitzpatrick_scale: false,
  category: "symbols"
};
const aries = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "♈",
  fitzpatrick_scale: false,
  category: "symbols"
};
const taurus = {
  keywords: [
    "purple-square",
    "sign",
    "zodiac",
    "astrology"
  ],
  char: "♉",
  fitzpatrick_scale: false,
  category: "symbols"
};
const gemini = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "♊",
  fitzpatrick_scale: false,
  category: "symbols"
};
const cancer = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "♋",
  fitzpatrick_scale: false,
  category: "symbols"
};
const leo = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "♌",
  fitzpatrick_scale: false,
  category: "symbols"
};
const virgo = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "♍",
  fitzpatrick_scale: false,
  category: "symbols"
};
const libra = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "♎",
  fitzpatrick_scale: false,
  category: "symbols"
};
const scorpius = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology",
    "scorpio"
  ],
  char: "♏",
  fitzpatrick_scale: false,
  category: "symbols"
};
const sagittarius = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "♐",
  fitzpatrick_scale: false,
  category: "symbols"
};
const capricorn = {
  keywords: [
    "sign",
    "zodiac",
    "purple-square",
    "astrology"
  ],
  char: "♑",
  fitzpatrick_scale: false,
  category: "symbols"
};
const aquarius = {
  keywords: [
    "sign",
    "purple-square",
    "zodiac",
    "astrology"
  ],
  char: "♒",
  fitzpatrick_scale: false,
  category: "symbols"
};
const pisces = {
  keywords: [
    "purple-square",
    "sign",
    "zodiac",
    "astrology"
  ],
  char: "♓",
  fitzpatrick_scale: false,
  category: "symbols"
};
const id = {
  keywords: [
    "purple-square",
    "words"
  ],
  char: "🆔",
  fitzpatrick_scale: false,
  category: "symbols"
};
const atom_symbol = {
  keywords: [
    "science",
    "physics",
    "chemistry"
  ],
  char: "⚛",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u7a7a = {
  keywords: [
    "kanji",
    "japanese",
    "chinese",
    "empty",
    "sky",
    "blue-square"
  ],
  char: "🈳",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u5272 = {
  keywords: [
    "cut",
    "divide",
    "chinese",
    "kanji",
    "pink-square"
  ],
  char: "🈹",
  fitzpatrick_scale: false,
  category: "symbols"
};
const radioactive = {
  keywords: [
    "nuclear",
    "danger"
  ],
  char: "☢",
  fitzpatrick_scale: false,
  category: "symbols"
};
const biohazard = {
  keywords: [
    "danger"
  ],
  char: "☣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const mobile_phone_off = {
  keywords: [
    "mute",
    "orange-square",
    "silence",
    "quiet"
  ],
  char: "📴",
  fitzpatrick_scale: false,
  category: "symbols"
};
const vibration_mode = {
  keywords: [
    "orange-square",
    "phone"
  ],
  char: "📳",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u6709 = {
  keywords: [
    "orange-square",
    "chinese",
    "have",
    "kanji"
  ],
  char: "🈶",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u7121 = {
  keywords: [
    "nothing",
    "chinese",
    "kanji",
    "japanese",
    "orange-square"
  ],
  char: "🈚",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u7533 = {
  keywords: [
    "chinese",
    "japanese",
    "kanji",
    "orange-square"
  ],
  char: "🈸",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u55b6 = {
  keywords: [
    "japanese",
    "opening hours",
    "orange-square"
  ],
  char: "🈺",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u6708 = {
  keywords: [
    "chinese",
    "month",
    "moon",
    "japanese",
    "orange-square",
    "kanji"
  ],
  char: "🈷️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const eight_pointed_black_star = {
  keywords: [
    "orange-square",
    "shape",
    "polygon"
  ],
  char: "✴️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const vs = {
  keywords: [
    "words",
    "orange-square"
  ],
  char: "🆚",
  fitzpatrick_scale: false,
  category: "symbols"
};
const accept = {
  keywords: [
    "ok",
    "good",
    "chinese",
    "kanji",
    "agree",
    "yes",
    "orange-circle"
  ],
  char: "🉑",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_flower = {
  keywords: [
    "japanese",
    "spring"
  ],
  char: "💮",
  fitzpatrick_scale: false,
  category: "symbols"
};
const ideograph_advantage = {
  keywords: [
    "chinese",
    "kanji",
    "obtain",
    "get",
    "circle"
  ],
  char: "🉐",
  fitzpatrick_scale: false,
  category: "symbols"
};
const secret = {
  keywords: [
    "privacy",
    "chinese",
    "sshh",
    "kanji",
    "red-circle"
  ],
  char: "㊙️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const congratulations = {
  keywords: [
    "chinese",
    "kanji",
    "japanese",
    "red-circle"
  ],
  char: "㊗️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u5408 = {
  keywords: [
    "japanese",
    "chinese",
    "join",
    "kanji",
    "red-square"
  ],
  char: "🈴",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u6e80 = {
  keywords: [
    "full",
    "chinese",
    "japanese",
    "red-square",
    "kanji"
  ],
  char: "🈵",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u7981 = {
  keywords: [
    "kanji",
    "japanese",
    "chinese",
    "forbidden",
    "limit",
    "restricted",
    "red-square"
  ],
  char: "🈲",
  fitzpatrick_scale: false,
  category: "symbols"
};
const a = {
  keywords: [
    "red-square",
    "alphabet",
    "letter"
  ],
  char: "🅰️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const b = {
  keywords: [
    "red-square",
    "alphabet",
    "letter"
  ],
  char: "🅱️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const ab = {
  keywords: [
    "red-square",
    "alphabet"
  ],
  char: "🆎",
  fitzpatrick_scale: false,
  category: "symbols"
};
const cl = {
  keywords: [
    "alphabet",
    "words",
    "red-square"
  ],
  char: "🆑",
  fitzpatrick_scale: false,
  category: "symbols"
};
const o2 = {
  keywords: [
    "alphabet",
    "red-square",
    "letter"
  ],
  char: "🅾️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const sos = {
  keywords: [
    "help",
    "red-square",
    "words",
    "emergency",
    "911"
  ],
  char: "🆘",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_entry = {
  keywords: [
    "limit",
    "security",
    "privacy",
    "bad",
    "denied",
    "stop",
    "circle"
  ],
  char: "⛔",
  fitzpatrick_scale: false,
  category: "symbols"
};
const name_badge = {
  keywords: [
    "fire",
    "forbid"
  ],
  char: "📛",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_entry_sign = {
  keywords: [
    "forbid",
    "stop",
    "limit",
    "denied",
    "disallow",
    "circle"
  ],
  char: "🚫",
  fitzpatrick_scale: false,
  category: "symbols"
};
const x = {
  keywords: [
    "no",
    "delete",
    "remove",
    "cancel",
    "red"
  ],
  char: "❌",
  fitzpatrick_scale: false,
  category: "symbols"
};
const o = {
  keywords: [
    "circle",
    "round"
  ],
  char: "⭕",
  fitzpatrick_scale: false,
  category: "symbols"
};
const stop_sign = {
  keywords: [
    "stop"
  ],
  char: "🛑",
  fitzpatrick_scale: false,
  category: "symbols"
};
const anger = {
  keywords: [
    "angry",
    "mad"
  ],
  char: "💢",
  fitzpatrick_scale: false,
  category: "symbols"
};
const hotsprings = {
  keywords: [
    "bath",
    "warm",
    "relax"
  ],
  char: "♨️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_pedestrians = {
  keywords: [
    "rules",
    "crossing",
    "walking",
    "circle"
  ],
  char: "🚷",
  fitzpatrick_scale: false,
  category: "symbols"
};
const do_not_litter = {
  keywords: [
    "trash",
    "bin",
    "garbage",
    "circle"
  ],
  char: "🚯",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_bicycles = {
  keywords: [
    "cyclist",
    "prohibited",
    "circle"
  ],
  char: "🚳",
  fitzpatrick_scale: false,
  category: "symbols"
};
const underage = {
  keywords: [
    "18",
    "drink",
    "pub",
    "night",
    "minor",
    "circle"
  ],
  char: "🔞",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_mobile_phones = {
  keywords: [
    "iphone",
    "mute",
    "circle"
  ],
  char: "📵",
  fitzpatrick_scale: false,
  category: "symbols"
};
const exclamation = {
  keywords: [
    "heavy_exclamation_mark",
    "danger",
    "surprise",
    "punctuation",
    "wow",
    "warning"
  ],
  char: "❗",
  fitzpatrick_scale: false,
  category: "symbols"
};
const grey_exclamation = {
  keywords: [
    "surprise",
    "punctuation",
    "gray",
    "wow",
    "warning"
  ],
  char: "❕",
  fitzpatrick_scale: false,
  category: "symbols"
};
const question = {
  keywords: [
    "doubt",
    "confused"
  ],
  char: "❓",
  fitzpatrick_scale: false,
  category: "symbols"
};
const grey_question = {
  keywords: [
    "doubts",
    "gray",
    "huh",
    "confused"
  ],
  char: "❔",
  fitzpatrick_scale: false,
  category: "symbols"
};
const bangbang = {
  keywords: [
    "exclamation",
    "surprise"
  ],
  char: "‼️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const interrobang = {
  keywords: [
    "wat",
    "punctuation",
    "surprise"
  ],
  char: "⁉️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const low_brightness = {
  keywords: [
    "sun",
    "afternoon",
    "warm",
    "summer"
  ],
  char: "🔅",
  fitzpatrick_scale: false,
  category: "symbols"
};
const high_brightness = {
  keywords: [
    "sun",
    "light"
  ],
  char: "🔆",
  fitzpatrick_scale: false,
  category: "symbols"
};
const trident = {
  keywords: [
    "weapon",
    "spear"
  ],
  char: "🔱",
  fitzpatrick_scale: false,
  category: "symbols"
};
const fleur_de_lis = {
  keywords: [
    "decorative",
    "scout"
  ],
  char: "⚜",
  fitzpatrick_scale: false,
  category: "symbols"
};
const part_alternation_mark = {
  keywords: [
    "graph",
    "presentation",
    "stats",
    "business",
    "economics",
    "bad"
  ],
  char: "〽️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const warning = {
  keywords: [
    "exclamation",
    "wip",
    "alert",
    "error",
    "problem",
    "issue"
  ],
  char: "⚠️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const children_crossing = {
  keywords: [
    "school",
    "warning",
    "danger",
    "sign",
    "driving",
    "yellow-diamond"
  ],
  char: "🚸",
  fitzpatrick_scale: false,
  category: "symbols"
};
const beginner = {
  keywords: [
    "badge",
    "shield"
  ],
  char: "🔰",
  fitzpatrick_scale: false,
  category: "symbols"
};
const recycle = {
  keywords: [
    "arrow",
    "environment",
    "garbage",
    "trash"
  ],
  char: "♻️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const u6307 = {
  keywords: [
    "chinese",
    "point",
    "green-square",
    "kanji"
  ],
  char: "🈯",
  fitzpatrick_scale: false,
  category: "symbols"
};
const chart = {
  keywords: [
    "green-square",
    "graph",
    "presentation",
    "stats"
  ],
  char: "💹",
  fitzpatrick_scale: false,
  category: "symbols"
};
const sparkle = {
  keywords: [
    "stars",
    "green-square",
    "awesome",
    "good",
    "fireworks"
  ],
  char: "❇️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const eight_spoked_asterisk = {
  keywords: [
    "star",
    "sparkle",
    "green-square"
  ],
  char: "✳️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const negative_squared_cross_mark = {
  keywords: [
    "x",
    "green-square",
    "no",
    "deny"
  ],
  char: "❎",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_check_mark = {
  keywords: [
    "green-square",
    "ok",
    "agree",
    "vote",
    "election",
    "answer",
    "tick"
  ],
  char: "✅",
  fitzpatrick_scale: false,
  category: "symbols"
};
const diamond_shape_with_a_dot_inside = {
  keywords: [
    "jewel",
    "blue",
    "gem",
    "crystal",
    "fancy"
  ],
  char: "💠",
  fitzpatrick_scale: false,
  category: "symbols"
};
const cyclone = {
  keywords: [
    "weather",
    "swirl",
    "blue",
    "cloud",
    "vortex",
    "spiral",
    "whirlpool",
    "spin",
    "tornado",
    "hurricane",
    "typhoon"
  ],
  char: "🌀",
  fitzpatrick_scale: false,
  category: "symbols"
};
const loop = {
  keywords: [
    "tape",
    "cassette"
  ],
  char: "➿",
  fitzpatrick_scale: false,
  category: "symbols"
};
const globe_with_meridians = {
  keywords: [
    "earth",
    "international",
    "world",
    "internet",
    "interweb",
    "i18n"
  ],
  char: "🌐",
  fitzpatrick_scale: false,
  category: "symbols"
};
const m = {
  keywords: [
    "alphabet",
    "blue-circle",
    "letter"
  ],
  char: "Ⓜ️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const atm = {
  keywords: [
    "money",
    "sales",
    "cash",
    "blue-square",
    "payment",
    "bank"
  ],
  char: "🏧",
  fitzpatrick_scale: false,
  category: "symbols"
};
const sa = {
  keywords: [
    "japanese",
    "blue-square",
    "katakana"
  ],
  char: "🈂️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const passport_control = {
  keywords: [
    "custom",
    "blue-square"
  ],
  char: "🛂",
  fitzpatrick_scale: false,
  category: "symbols"
};
const customs = {
  keywords: [
    "passport",
    "border",
    "blue-square"
  ],
  char: "🛃",
  fitzpatrick_scale: false,
  category: "symbols"
};
const baggage_claim = {
  keywords: [
    "blue-square",
    "airport",
    "transport"
  ],
  char: "🛄",
  fitzpatrick_scale: false,
  category: "symbols"
};
const left_luggage = {
  keywords: [
    "blue-square",
    "travel"
  ],
  char: "🛅",
  fitzpatrick_scale: false,
  category: "symbols"
};
const wheelchair = {
  keywords: [
    "blue-square",
    "disabled",
    "a11y",
    "accessibility"
  ],
  char: "♿",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_smoking = {
  keywords: [
    "cigarette",
    "blue-square",
    "smell",
    "smoke"
  ],
  char: "🚭",
  fitzpatrick_scale: false,
  category: "symbols"
};
const wc = {
  keywords: [
    "toilet",
    "restroom",
    "blue-square"
  ],
  char: "🚾",
  fitzpatrick_scale: false,
  category: "symbols"
};
const parking = {
  keywords: [
    "cars",
    "blue-square",
    "alphabet",
    "letter"
  ],
  char: "🅿️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const potable_water = {
  keywords: [
    "blue-square",
    "liquid",
    "restroom",
    "cleaning",
    "faucet"
  ],
  char: "🚰",
  fitzpatrick_scale: false,
  category: "symbols"
};
const mens = {
  keywords: [
    "toilet",
    "restroom",
    "wc",
    "blue-square",
    "gender",
    "male"
  ],
  char: "🚹",
  fitzpatrick_scale: false,
  category: "symbols"
};
const womens = {
  keywords: [
    "purple-square",
    "woman",
    "female",
    "toilet",
    "loo",
    "restroom",
    "gender"
  ],
  char: "🚺",
  fitzpatrick_scale: false,
  category: "symbols"
};
const baby_symbol = {
  keywords: [
    "orange-square",
    "child"
  ],
  char: "🚼",
  fitzpatrick_scale: false,
  category: "symbols"
};
const restroom = {
  keywords: [
    "blue-square",
    "toilet",
    "refresh",
    "wc",
    "gender"
  ],
  char: "🚻",
  fitzpatrick_scale: false,
  category: "symbols"
};
const put_litter_in_its_place = {
  keywords: [
    "blue-square",
    "sign",
    "human",
    "info"
  ],
  char: "🚮",
  fitzpatrick_scale: false,
  category: "symbols"
};
const cinema = {
  keywords: [
    "blue-square",
    "record",
    "film",
    "movie",
    "curtain",
    "stage",
    "theater"
  ],
  char: "🎦",
  fitzpatrick_scale: false,
  category: "symbols"
};
const signal_strength = {
  keywords: [
    "blue-square",
    "reception",
    "phone",
    "internet",
    "connection",
    "wifi",
    "bluetooth",
    "bars"
  ],
  char: "📶",
  fitzpatrick_scale: false,
  category: "symbols"
};
const koko = {
  keywords: [
    "blue-square",
    "here",
    "katakana",
    "japanese",
    "destination"
  ],
  char: "🈁",
  fitzpatrick_scale: false,
  category: "symbols"
};
const ng = {
  keywords: [
    "blue-square",
    "words",
    "shape",
    "icon"
  ],
  char: "🆖",
  fitzpatrick_scale: false,
  category: "symbols"
};
const ok = {
  keywords: [
    "good",
    "agree",
    "yes",
    "blue-square"
  ],
  char: "🆗",
  fitzpatrick_scale: false,
  category: "symbols"
};
const up = {
  keywords: [
    "blue-square",
    "above",
    "high"
  ],
  char: "🆙",
  fitzpatrick_scale: false,
  category: "symbols"
};
const cool = {
  keywords: [
    "words",
    "blue-square"
  ],
  char: "🆒",
  fitzpatrick_scale: false,
  category: "symbols"
};
const free = {
  keywords: [
    "blue-square",
    "words"
  ],
  char: "🆓",
  fitzpatrick_scale: false,
  category: "symbols"
};
const zero = {
  keywords: [
    "0",
    "numbers",
    "blue-square",
    "null"
  ],
  char: "0️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const one$1 = {
  keywords: [
    "blue-square",
    "numbers",
    "1"
  ],
  char: "1️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const two = {
  keywords: [
    "numbers",
    "2",
    "prime",
    "blue-square"
  ],
  char: "2️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const three = {
  keywords: [
    "3",
    "numbers",
    "prime",
    "blue-square"
  ],
  char: "3️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const four = {
  keywords: [
    "4",
    "numbers",
    "blue-square"
  ],
  char: "4️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const five = {
  keywords: [
    "5",
    "numbers",
    "blue-square",
    "prime"
  ],
  char: "5️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const six = {
  keywords: [
    "6",
    "numbers",
    "blue-square"
  ],
  char: "6️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const seven = {
  keywords: [
    "7",
    "numbers",
    "blue-square",
    "prime"
  ],
  char: "7️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const eight = {
  keywords: [
    "8",
    "blue-square",
    "numbers"
  ],
  char: "8️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const nine = {
  keywords: [
    "blue-square",
    "numbers",
    "9"
  ],
  char: "9️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const keycap_ten = {
  keywords: [
    "numbers",
    "10",
    "blue-square"
  ],
  char: "🔟",
  fitzpatrick_scale: false,
  category: "symbols"
};
const asterisk = {
  keywords: [
    "star",
    "keycap"
  ],
  char: "*⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const eject_button = {
  keywords: [
    "blue-square"
  ],
  char: "⏏️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_forward = {
  keywords: [
    "blue-square",
    "right",
    "direction",
    "play"
  ],
  char: "▶️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const pause_button = {
  keywords: [
    "pause",
    "blue-square"
  ],
  char: "⏸",
  fitzpatrick_scale: false,
  category: "symbols"
};
const next_track_button = {
  keywords: [
    "forward",
    "next",
    "blue-square"
  ],
  char: "⏭",
  fitzpatrick_scale: false,
  category: "symbols"
};
const stop_button = {
  keywords: [
    "blue-square"
  ],
  char: "⏹",
  fitzpatrick_scale: false,
  category: "symbols"
};
const record_button = {
  keywords: [
    "blue-square"
  ],
  char: "⏺",
  fitzpatrick_scale: false,
  category: "symbols"
};
const play_or_pause_button = {
  keywords: [
    "blue-square",
    "play",
    "pause"
  ],
  char: "⏯",
  fitzpatrick_scale: false,
  category: "symbols"
};
const previous_track_button = {
  keywords: [
    "backward"
  ],
  char: "⏮",
  fitzpatrick_scale: false,
  category: "symbols"
};
const fast_forward = {
  keywords: [
    "blue-square",
    "play",
    "speed",
    "continue"
  ],
  char: "⏩",
  fitzpatrick_scale: false,
  category: "symbols"
};
const rewind = {
  keywords: [
    "play",
    "blue-square"
  ],
  char: "⏪",
  fitzpatrick_scale: false,
  category: "symbols"
};
const twisted_rightwards_arrows = {
  keywords: [
    "blue-square",
    "shuffle",
    "music",
    "random"
  ],
  char: "🔀",
  fitzpatrick_scale: false,
  category: "symbols"
};
const repeat = {
  keywords: [
    "loop",
    "record"
  ],
  char: "🔁",
  fitzpatrick_scale: false,
  category: "symbols"
};
const repeat_one = {
  keywords: [
    "blue-square",
    "loop"
  ],
  char: "🔂",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_backward = {
  keywords: [
    "blue-square",
    "left",
    "direction"
  ],
  char: "◀️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_up_small = {
  keywords: [
    "blue-square",
    "triangle",
    "direction",
    "point",
    "forward",
    "top"
  ],
  char: "🔼",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_down_small = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "🔽",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_double_up = {
  keywords: [
    "blue-square",
    "direction",
    "top"
  ],
  char: "⏫",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_double_down = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "⏬",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_right = {
  keywords: [
    "blue-square",
    "next"
  ],
  char: "➡️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_left = {
  keywords: [
    "blue-square",
    "previous",
    "back"
  ],
  char: "⬅️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_up = {
  keywords: [
    "blue-square",
    "continue",
    "top",
    "direction"
  ],
  char: "⬆️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_down = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "⬇️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_upper_right = {
  keywords: [
    "blue-square",
    "point",
    "direction",
    "diagonal",
    "northeast"
  ],
  char: "↗️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_lower_right = {
  keywords: [
    "blue-square",
    "direction",
    "diagonal",
    "southeast"
  ],
  char: "↘️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_lower_left = {
  keywords: [
    "blue-square",
    "direction",
    "diagonal",
    "southwest"
  ],
  char: "↙️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_upper_left = {
  keywords: [
    "blue-square",
    "point",
    "direction",
    "diagonal",
    "northwest"
  ],
  char: "↖️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_up_down = {
  keywords: [
    "blue-square",
    "direction",
    "way",
    "vertical"
  ],
  char: "↕️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const left_right_arrow = {
  keywords: [
    "shape",
    "direction",
    "horizontal",
    "sideways"
  ],
  char: "↔️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrows_counterclockwise = {
  keywords: [
    "blue-square",
    "sync",
    "cycle"
  ],
  char: "🔄",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_right_hook = {
  keywords: [
    "blue-square",
    "return",
    "rotate",
    "direction"
  ],
  char: "↪️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const leftwards_arrow_with_hook = {
  keywords: [
    "back",
    "return",
    "blue-square",
    "undo",
    "enter"
  ],
  char: "↩️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_heading_up = {
  keywords: [
    "blue-square",
    "direction",
    "top"
  ],
  char: "⤴️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrow_heading_down = {
  keywords: [
    "blue-square",
    "direction",
    "bottom"
  ],
  char: "⤵️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const hash = {
  keywords: [
    "symbol",
    "blue-square",
    "twitter"
  ],
  char: "#️⃣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const information_source = {
  keywords: [
    "blue-square",
    "alphabet",
    "letter"
  ],
  char: "ℹ️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const abc = {
  keywords: [
    "blue-square",
    "alphabet"
  ],
  char: "🔤",
  fitzpatrick_scale: false,
  category: "symbols"
};
const abcd = {
  keywords: [
    "blue-square",
    "alphabet"
  ],
  char: "🔡",
  fitzpatrick_scale: false,
  category: "symbols"
};
const capital_abcd = {
  keywords: [
    "alphabet",
    "words",
    "blue-square"
  ],
  char: "🔠",
  fitzpatrick_scale: false,
  category: "symbols"
};
const symbols = {
  keywords: [
    "blue-square",
    "music",
    "note",
    "ampersand",
    "percent",
    "glyphs",
    "characters"
  ],
  char: "🔣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const musical_note = {
  keywords: [
    "score",
    "tone",
    "sound"
  ],
  char: "🎵",
  fitzpatrick_scale: false,
  category: "symbols"
};
const notes = {
  keywords: [
    "music",
    "score"
  ],
  char: "🎶",
  fitzpatrick_scale: false,
  category: "symbols"
};
const wavy_dash = {
  keywords: [
    "draw",
    "line",
    "moustache",
    "mustache",
    "squiggle",
    "scribble"
  ],
  char: "〰️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const curly_loop = {
  keywords: [
    "scribble",
    "draw",
    "shape",
    "squiggle"
  ],
  char: "➰",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_check_mark = {
  keywords: [
    "ok",
    "nike",
    "answer",
    "yes",
    "tick"
  ],
  char: "✔️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const arrows_clockwise = {
  keywords: [
    "sync",
    "cycle",
    "round",
    "repeat"
  ],
  char: "🔃",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_plus_sign = {
  keywords: [
    "math",
    "calculation",
    "addition",
    "more",
    "increase"
  ],
  char: "➕",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_minus_sign = {
  keywords: [
    "math",
    "calculation",
    "subtract",
    "less"
  ],
  char: "➖",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_division_sign = {
  keywords: [
    "divide",
    "math",
    "calculation"
  ],
  char: "➗",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_multiplication_x = {
  keywords: [
    "math",
    "calculation"
  ],
  char: "✖️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const infinity = {
  keywords: [
    "forever"
  ],
  char: "♾",
  fitzpatrick_scale: false,
  category: "symbols"
};
const heavy_dollar_sign = {
  keywords: [
    "money",
    "sales",
    "payment",
    "currency",
    "buck"
  ],
  char: "💲",
  fitzpatrick_scale: false,
  category: "symbols"
};
const currency_exchange = {
  keywords: [
    "money",
    "sales",
    "dollar",
    "travel"
  ],
  char: "💱",
  fitzpatrick_scale: false,
  category: "symbols"
};
const copyright = {
  keywords: [
    "ip",
    "license",
    "circle",
    "law",
    "legal"
  ],
  char: "©️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const registered = {
  keywords: [
    "alphabet",
    "circle"
  ],
  char: "®️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const tm = {
  keywords: [
    "trademark",
    "brand",
    "law",
    "legal"
  ],
  char: "™️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const end = {
  keywords: [
    "words",
    "arrow"
  ],
  char: "🔚",
  fitzpatrick_scale: false,
  category: "symbols"
};
const back = {
  keywords: [
    "arrow",
    "words",
    "return"
  ],
  char: "🔙",
  fitzpatrick_scale: false,
  category: "symbols"
};
const on = {
  keywords: [
    "arrow",
    "words"
  ],
  char: "🔛",
  fitzpatrick_scale: false,
  category: "symbols"
};
const top = {
  keywords: [
    "words",
    "blue-square"
  ],
  char: "🔝",
  fitzpatrick_scale: false,
  category: "symbols"
};
const soon = {
  keywords: [
    "arrow",
    "words"
  ],
  char: "🔜",
  fitzpatrick_scale: false,
  category: "symbols"
};
const ballot_box_with_check = {
  keywords: [
    "ok",
    "agree",
    "confirm",
    "black-square",
    "vote",
    "election",
    "yes",
    "tick"
  ],
  char: "☑️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const radio_button = {
  keywords: [
    "input",
    "old",
    "music",
    "circle"
  ],
  char: "🔘",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_circle = {
  keywords: [
    "shape",
    "round"
  ],
  char: "⚪",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_circle = {
  keywords: [
    "shape",
    "button",
    "round"
  ],
  char: "⚫",
  fitzpatrick_scale: false,
  category: "symbols"
};
const red_circle = {
  keywords: [
    "shape",
    "error",
    "danger"
  ],
  char: "🔴",
  fitzpatrick_scale: false,
  category: "symbols"
};
const large_blue_circle = {
  keywords: [
    "shape",
    "icon",
    "button"
  ],
  char: "🔵",
  fitzpatrick_scale: false,
  category: "symbols"
};
const small_orange_diamond = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "🔸",
  fitzpatrick_scale: false,
  category: "symbols"
};
const small_blue_diamond = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "🔹",
  fitzpatrick_scale: false,
  category: "symbols"
};
const large_orange_diamond = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "🔶",
  fitzpatrick_scale: false,
  category: "symbols"
};
const large_blue_diamond = {
  keywords: [
    "shape",
    "jewel",
    "gem"
  ],
  char: "🔷",
  fitzpatrick_scale: false,
  category: "symbols"
};
const small_red_triangle = {
  keywords: [
    "shape",
    "direction",
    "up",
    "top"
  ],
  char: "🔺",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_small_square = {
  keywords: [
    "shape",
    "icon"
  ],
  char: "▪️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_small_square = {
  keywords: [
    "shape",
    "icon"
  ],
  char: "▫️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_large_square = {
  keywords: [
    "shape",
    "icon",
    "button"
  ],
  char: "⬛",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_large_square = {
  keywords: [
    "shape",
    "icon",
    "stone",
    "button"
  ],
  char: "⬜",
  fitzpatrick_scale: false,
  category: "symbols"
};
const small_red_triangle_down = {
  keywords: [
    "shape",
    "direction",
    "bottom"
  ],
  char: "🔻",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_medium_square = {
  keywords: [
    "shape",
    "button",
    "icon"
  ],
  char: "◼️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_medium_square = {
  keywords: [
    "shape",
    "stone",
    "icon"
  ],
  char: "◻️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_medium_small_square = {
  keywords: [
    "icon",
    "shape",
    "button"
  ],
  char: "◾",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_medium_small_square = {
  keywords: [
    "shape",
    "stone",
    "icon",
    "button"
  ],
  char: "◽",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_square_button = {
  keywords: [
    "shape",
    "input",
    "frame"
  ],
  char: "🔲",
  fitzpatrick_scale: false,
  category: "symbols"
};
const white_square_button = {
  keywords: [
    "shape",
    "input"
  ],
  char: "🔳",
  fitzpatrick_scale: false,
  category: "symbols"
};
const speaker = {
  keywords: [
    "sound",
    "volume",
    "silence",
    "broadcast"
  ],
  char: "🔈",
  fitzpatrick_scale: false,
  category: "symbols"
};
const sound = {
  keywords: [
    "volume",
    "speaker",
    "broadcast"
  ],
  char: "🔉",
  fitzpatrick_scale: false,
  category: "symbols"
};
const loud_sound = {
  keywords: [
    "volume",
    "noise",
    "noisy",
    "speaker",
    "broadcast"
  ],
  char: "🔊",
  fitzpatrick_scale: false,
  category: "symbols"
};
const mute = {
  keywords: [
    "sound",
    "volume",
    "silence",
    "quiet"
  ],
  char: "🔇",
  fitzpatrick_scale: false,
  category: "symbols"
};
const mega = {
  keywords: [
    "sound",
    "speaker",
    "volume"
  ],
  char: "📣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const loudspeaker = {
  keywords: [
    "volume",
    "sound"
  ],
  char: "📢",
  fitzpatrick_scale: false,
  category: "symbols"
};
const bell = {
  keywords: [
    "sound",
    "notification",
    "christmas",
    "xmas",
    "chime"
  ],
  char: "🔔",
  fitzpatrick_scale: false,
  category: "symbols"
};
const no_bell = {
  keywords: [
    "sound",
    "volume",
    "mute",
    "quiet",
    "silent"
  ],
  char: "🔕",
  fitzpatrick_scale: false,
  category: "symbols"
};
const black_joker = {
  keywords: [
    "poker",
    "cards",
    "game",
    "play",
    "magic"
  ],
  char: "🃏",
  fitzpatrick_scale: false,
  category: "symbols"
};
const mahjong = {
  keywords: [
    "game",
    "play",
    "chinese",
    "kanji"
  ],
  char: "🀄",
  fitzpatrick_scale: false,
  category: "symbols"
};
const spades = {
  keywords: [
    "poker",
    "cards",
    "suits",
    "magic"
  ],
  char: "♠️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clubs = {
  keywords: [
    "poker",
    "cards",
    "magic",
    "suits"
  ],
  char: "♣️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const hearts = {
  keywords: [
    "poker",
    "cards",
    "magic",
    "suits"
  ],
  char: "♥️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const diamonds = {
  keywords: [
    "poker",
    "cards",
    "magic",
    "suits"
  ],
  char: "♦️",
  fitzpatrick_scale: false,
  category: "symbols"
};
const flower_playing_cards = {
  keywords: [
    "game",
    "sunset",
    "red"
  ],
  char: "🎴",
  fitzpatrick_scale: false,
  category: "symbols"
};
const thought_balloon = {
  keywords: [
    "bubble",
    "cloud",
    "speech",
    "thinking",
    "dream"
  ],
  char: "💭",
  fitzpatrick_scale: false,
  category: "symbols"
};
const right_anger_bubble = {
  keywords: [
    "caption",
    "speech",
    "thinking",
    "mad"
  ],
  char: "🗯",
  fitzpatrick_scale: false,
  category: "symbols"
};
const speech_balloon = {
  keywords: [
    "bubble",
    "words",
    "message",
    "talk",
    "chatting"
  ],
  char: "💬",
  fitzpatrick_scale: false,
  category: "symbols"
};
const left_speech_bubble = {
  keywords: [
    "words",
    "message",
    "talk",
    "chatting"
  ],
  char: "🗨",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock1 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕐",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock2 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕑",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock3 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕒",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock4 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕓",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock5 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕔",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock6 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule",
    "dawn",
    "dusk"
  ],
  char: "🕕",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock7 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕖",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock8 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕗",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock9 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕘",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock10 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕙",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock11 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕚",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock12 = {
  keywords: [
    "time",
    "noon",
    "midnight",
    "midday",
    "late",
    "early",
    "schedule"
  ],
  char: "🕛",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock130 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕜",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock230 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕝",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock330 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕞",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock430 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕟",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock530 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕠",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock630 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕡",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock730 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕢",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock830 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕣",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock930 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕤",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock1030 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕥",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock1130 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕦",
  fitzpatrick_scale: false,
  category: "symbols"
};
const clock1230 = {
  keywords: [
    "time",
    "late",
    "early",
    "schedule"
  ],
  char: "🕧",
  fitzpatrick_scale: false,
  category: "symbols"
};
const afghanistan = {
  keywords: [
    "af",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const aland_islands = {
  keywords: [
    "Åland",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇽",
  fitzpatrick_scale: false,
  category: "flags"
};
const albania = {
  keywords: [
    "al",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const algeria = {
  keywords: [
    "dz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇩🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const american_samoa = {
  keywords: [
    "american",
    "ws",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const andorra = {
  keywords: [
    "ad",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const angola = {
  keywords: [
    "ao",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const anguilla = {
  keywords: [
    "ai",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const antarctica = {
  keywords: [
    "aq",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇶",
  fitzpatrick_scale: false,
  category: "flags"
};
const antigua_barbuda = {
  keywords: [
    "antigua",
    "barbuda",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const argentina = {
  keywords: [
    "ar",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const armenia = {
  keywords: [
    "am",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const aruba = {
  keywords: [
    "aw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const australia = {
  keywords: [
    "au",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const austria = {
  keywords: [
    "at",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const azerbaijan = {
  keywords: [
    "az",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const bahamas = {
  keywords: [
    "bs",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const bahrain = {
  keywords: [
    "bh",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const bangladesh = {
  keywords: [
    "bd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const barbados = {
  keywords: [
    "bb",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇧",
  fitzpatrick_scale: false,
  category: "flags"
};
const belarus = {
  keywords: [
    "by",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const belgium = {
  keywords: [
    "be",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const belize = {
  keywords: [
    "bz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const benin = {
  keywords: [
    "bj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇯",
  fitzpatrick_scale: false,
  category: "flags"
};
const bermuda = {
  keywords: [
    "bm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const bhutan = {
  keywords: [
    "bt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const bolivia = {
  keywords: [
    "bo",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const caribbean_netherlands = {
  keywords: [
    "bonaire",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇶",
  fitzpatrick_scale: false,
  category: "flags"
};
const bosnia_herzegovina = {
  keywords: [
    "bosnia",
    "herzegovina",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const botswana = {
  keywords: [
    "bw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const brazil = {
  keywords: [
    "br",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const british_indian_ocean_territory = {
  keywords: [
    "british",
    "indian",
    "ocean",
    "territory",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const british_virgin_islands = {
  keywords: [
    "british",
    "virgin",
    "islands",
    "bvi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const brunei = {
  keywords: [
    "bn",
    "darussalam",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const bulgaria = {
  keywords: [
    "bg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const burkina_faso = {
  keywords: [
    "burkina",
    "faso",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const burundi = {
  keywords: [
    "bi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const cape_verde = {
  keywords: [
    "cabo",
    "verde",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇻",
  fitzpatrick_scale: false,
  category: "flags"
};
const cambodia = {
  keywords: [
    "kh",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const cameroon = {
  keywords: [
    "cm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const canada = {
  keywords: [
    "ca",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const canary_islands = {
  keywords: [
    "canary",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const cayman_islands = {
  keywords: [
    "cayman",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const central_african_republic = {
  keywords: [
    "central",
    "african",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const chad = {
  keywords: [
    "td",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const chile = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const cn = {
  keywords: [
    "china",
    "chinese",
    "prc",
    "flag",
    "country",
    "nation",
    "banner"
  ],
  char: "🇨🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const christmas_island = {
  keywords: [
    "christmas",
    "island",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇽",
  fitzpatrick_scale: false,
  category: "flags"
};
const cocos_islands = {
  keywords: [
    "cocos",
    "keeling",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const colombia = {
  keywords: [
    "co",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const comoros = {
  keywords: [
    "km",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const congo_brazzaville = {
  keywords: [
    "congo",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const congo_kinshasa = {
  keywords: [
    "congo",
    "democratic",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const cook_islands = {
  keywords: [
    "cook",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const costa_rica = {
  keywords: [
    "costa",
    "rica",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const croatia = {
  keywords: [
    "hr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇭🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const cuba = {
  keywords: [
    "cu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const curacao = {
  keywords: [
    "curaçao",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const cyprus = {
  keywords: [
    "cy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const czech_republic = {
  keywords: [
    "cz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const denmark = {
  keywords: [
    "dk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇩🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const djibouti = {
  keywords: [
    "dj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇩🇯",
  fitzpatrick_scale: false,
  category: "flags"
};
const dominica = {
  keywords: [
    "dm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇩🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const dominican_republic = {
  keywords: [
    "dominican",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇩🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const ecuador = {
  keywords: [
    "ec",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const egypt = {
  keywords: [
    "eg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const el_salvador = {
  keywords: [
    "el",
    "salvador",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇻",
  fitzpatrick_scale: false,
  category: "flags"
};
const equatorial_guinea = {
  keywords: [
    "equatorial",
    "gn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇶",
  fitzpatrick_scale: false,
  category: "flags"
};
const eritrea = {
  keywords: [
    "er",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const estonia = {
  keywords: [
    "ee",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const ethiopia = {
  keywords: [
    "et",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const eu = {
  keywords: [
    "european",
    "union",
    "flag",
    "banner"
  ],
  char: "🇪🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const falkland_islands = {
  keywords: [
    "falkland",
    "islands",
    "malvinas",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇫🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const faroe_islands = {
  keywords: [
    "faroe",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇫🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const fiji = {
  keywords: [
    "fj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇫🇯",
  fitzpatrick_scale: false,
  category: "flags"
};
const finland = {
  keywords: [
    "fi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇫🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const fr = {
  keywords: [
    "banner",
    "flag",
    "nation",
    "france",
    "french",
    "country"
  ],
  char: "🇫🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const french_guiana = {
  keywords: [
    "french",
    "guiana",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const french_polynesia = {
  keywords: [
    "french",
    "polynesia",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const french_southern_territories = {
  keywords: [
    "french",
    "southern",
    "territories",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const gabon = {
  keywords: [
    "ga",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const gambia = {
  keywords: [
    "gm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const georgia = {
  keywords: [
    "ge",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const de = {
  keywords: [
    "german",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "🇩🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const ghana = {
  keywords: [
    "gh",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const gibraltar = {
  keywords: [
    "gi",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const greece = {
  keywords: [
    "gr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const greenland = {
  keywords: [
    "gl",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const grenada = {
  keywords: [
    "gd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const guadeloupe = {
  keywords: [
    "gp",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇵",
  fitzpatrick_scale: false,
  category: "flags"
};
const guam = {
  keywords: [
    "gu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const guatemala = {
  keywords: [
    "gt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const guernsey = {
  keywords: [
    "gg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const guinea = {
  keywords: [
    "gn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const guinea_bissau = {
  keywords: [
    "gw",
    "bissau",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const guyana = {
  keywords: [
    "gy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const haiti = {
  keywords: [
    "ht",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇭🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const honduras = {
  keywords: [
    "hn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇭🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const hong_kong = {
  keywords: [
    "hong",
    "kong",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇭🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const hungary = {
  keywords: [
    "hu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇭🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const iceland = {
  keywords: [
    "is",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const india = {
  keywords: [
    "in",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const indonesia = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const iran = {
  keywords: [
    "iran,",
    "islamic",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const iraq = {
  keywords: [
    "iq",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇶",
  fitzpatrick_scale: false,
  category: "flags"
};
const ireland = {
  keywords: [
    "ie",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const isle_of_man = {
  keywords: [
    "isle",
    "man",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const israel = {
  keywords: [
    "il",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const it = {
  keywords: [
    "italy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇮🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const cote_divoire = {
  keywords: [
    "ivory",
    "coast",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const jamaica = {
  keywords: [
    "jm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇯🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const jp = {
  keywords: [
    "japanese",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "🇯🇵",
  fitzpatrick_scale: false,
  category: "flags"
};
const jersey = {
  keywords: [
    "je",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇯🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const jordan = {
  keywords: [
    "jo",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇯🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const kazakhstan = {
  keywords: [
    "kz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const kenya = {
  keywords: [
    "ke",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const kiribati = {
  keywords: [
    "ki",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const kosovo = {
  keywords: [
    "xk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇽🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const kuwait = {
  keywords: [
    "kw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const kyrgyzstan = {
  keywords: [
    "kg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const laos = {
  keywords: [
    "lao",
    "democratic",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const latvia = {
  keywords: [
    "lv",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇻",
  fitzpatrick_scale: false,
  category: "flags"
};
const lebanon = {
  keywords: [
    "lb",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇧",
  fitzpatrick_scale: false,
  category: "flags"
};
const lesotho = {
  keywords: [
    "ls",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const liberia = {
  keywords: [
    "lr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const libya = {
  keywords: [
    "ly",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const liechtenstein = {
  keywords: [
    "li",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const lithuania = {
  keywords: [
    "lt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const luxembourg = {
  keywords: [
    "lu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const macau = {
  keywords: [
    "macao",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const macedonia = {
  keywords: [
    "macedonia,",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const madagascar = {
  keywords: [
    "mg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const malawi = {
  keywords: [
    "mw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const malaysia = {
  keywords: [
    "my",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const maldives = {
  keywords: [
    "mv",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇻",
  fitzpatrick_scale: false,
  category: "flags"
};
const mali = {
  keywords: [
    "ml",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const malta = {
  keywords: [
    "mt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const marshall_islands = {
  keywords: [
    "marshall",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const martinique = {
  keywords: [
    "mq",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇶",
  fitzpatrick_scale: false,
  category: "flags"
};
const mauritania = {
  keywords: [
    "mr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const mauritius = {
  keywords: [
    "mu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const mayotte = {
  keywords: [
    "yt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇾🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const mexico = {
  keywords: [
    "mx",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇽",
  fitzpatrick_scale: false,
  category: "flags"
};
const micronesia = {
  keywords: [
    "micronesia,",
    "federated",
    "states",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇫🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const moldova = {
  keywords: [
    "moldova,",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const monaco = {
  keywords: [
    "mc",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const mongolia = {
  keywords: [
    "mn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const montenegro = {
  keywords: [
    "me",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const montserrat = {
  keywords: [
    "ms",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const morocco = {
  keywords: [
    "ma",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const mozambique = {
  keywords: [
    "mz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const myanmar = {
  keywords: [
    "mm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const namibia = {
  keywords: [
    "na",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const nauru = {
  keywords: [
    "nr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const nepal = {
  keywords: [
    "np",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇵",
  fitzpatrick_scale: false,
  category: "flags"
};
const netherlands = {
  keywords: [
    "nl",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const new_caledonia = {
  keywords: [
    "new",
    "caledonia",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const new_zealand = {
  keywords: [
    "new",
    "zealand",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const nicaragua = {
  keywords: [
    "ni",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const niger = {
  keywords: [
    "ne",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const nigeria = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const niue = {
  keywords: [
    "nu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const norfolk_island = {
  keywords: [
    "norfolk",
    "island",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const northern_mariana_islands = {
  keywords: [
    "northern",
    "mariana",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇲🇵",
  fitzpatrick_scale: false,
  category: "flags"
};
const north_korea = {
  keywords: [
    "north",
    "korea",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "🇰🇵",
  fitzpatrick_scale: false,
  category: "flags"
};
const norway = {
  keywords: [
    "no",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇳🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const oman = {
  keywords: [
    "om_symbol",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇴🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const pakistan = {
  keywords: [
    "pk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const palau = {
  keywords: [
    "pw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const palestinian_territories = {
  keywords: [
    "palestine",
    "palestinian",
    "territories",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const panama = {
  keywords: [
    "pa",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const papua_new_guinea = {
  keywords: [
    "papua",
    "new",
    "guinea",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const paraguay = {
  keywords: [
    "py",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const peru = {
  keywords: [
    "pe",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const philippines = {
  keywords: [
    "ph",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const pitcairn_islands = {
  keywords: [
    "pitcairn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const poland = {
  keywords: [
    "pl",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const portugal = {
  keywords: [
    "pt",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const puerto_rico = {
  keywords: [
    "puerto",
    "rico",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const qatar = {
  keywords: [
    "qa",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇶🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const reunion = {
  keywords: [
    "réunion",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇷🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const romania = {
  keywords: [
    "ro",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇷🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const ru = {
  keywords: [
    "russian",
    "federation",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇷🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const rwanda = {
  keywords: [
    "rw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇷🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const st_barthelemy = {
  keywords: [
    "saint",
    "barthélemy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇧🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const st_helena = {
  keywords: [
    "saint",
    "helena",
    "ascension",
    "tristan",
    "cunha",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const st_kitts_nevis = {
  keywords: [
    "saint",
    "kitts",
    "nevis",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇰🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const st_lucia = {
  keywords: [
    "saint",
    "lucia",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const st_pierre_miquelon = {
  keywords: [
    "saint",
    "pierre",
    "miquelon",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇵🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const st_vincent_grenadines = {
  keywords: [
    "saint",
    "vincent",
    "grenadines",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const samoa = {
  keywords: [
    "ws",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇼🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const san_marino = {
  keywords: [
    "san",
    "marino",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const sao_tome_principe = {
  keywords: [
    "sao",
    "tome",
    "principe",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const saudi_arabia = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const senegal = {
  keywords: [
    "sn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const serbia = {
  keywords: [
    "rs",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇷🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const seychelles = {
  keywords: [
    "sc",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const sierra_leone = {
  keywords: [
    "sierra",
    "leone",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const singapore = {
  keywords: [
    "sg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const sint_maarten = {
  keywords: [
    "sint",
    "maarten",
    "dutch",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇽",
  fitzpatrick_scale: false,
  category: "flags"
};
const slovakia = {
  keywords: [
    "sk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const slovenia = {
  keywords: [
    "si",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const solomon_islands = {
  keywords: [
    "solomon",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇧",
  fitzpatrick_scale: false,
  category: "flags"
};
const somalia = {
  keywords: [
    "so",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const south_africa = {
  keywords: [
    "south",
    "africa",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇿🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const south_georgia_south_sandwich_islands = {
  keywords: [
    "south",
    "georgia",
    "sandwich",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇬🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const kr = {
  keywords: [
    "south",
    "korea",
    "nation",
    "flag",
    "country",
    "banner"
  ],
  char: "🇰🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const south_sudan = {
  keywords: [
    "south",
    "sd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const es = {
  keywords: [
    "spain",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const sri_lanka = {
  keywords: [
    "sri",
    "lanka",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇱🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const sudan = {
  keywords: [
    "sd",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇩",
  fitzpatrick_scale: false,
  category: "flags"
};
const suriname = {
  keywords: [
    "sr",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const swaziland = {
  keywords: [
    "sz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const sweden = {
  keywords: [
    "se",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const switzerland = {
  keywords: [
    "ch",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇨🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const syria = {
  keywords: [
    "syrian",
    "arab",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇸🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const taiwan = {
  keywords: [
    "tw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const tajikistan = {
  keywords: [
    "tj",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇯",
  fitzpatrick_scale: false,
  category: "flags"
};
const tanzania = {
  keywords: [
    "tanzania,",
    "united",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const thailand = {
  keywords: [
    "th",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const timor_leste = {
  keywords: [
    "timor",
    "leste",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇱",
  fitzpatrick_scale: false,
  category: "flags"
};
const togo = {
  keywords: [
    "tg",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const tokelau = {
  keywords: [
    "tk",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇰",
  fitzpatrick_scale: false,
  category: "flags"
};
const tonga = {
  keywords: [
    "to",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇴",
  fitzpatrick_scale: false,
  category: "flags"
};
const trinidad_tobago = {
  keywords: [
    "trinidad",
    "tobago",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇹",
  fitzpatrick_scale: false,
  category: "flags"
};
const tunisia = {
  keywords: [
    "tn",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const tr = {
  keywords: [
    "turkey",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇷",
  fitzpatrick_scale: false,
  category: "flags"
};
const turkmenistan = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const turks_caicos_islands = {
  keywords: [
    "turks",
    "caicos",
    "islands",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇨",
  fitzpatrick_scale: false,
  category: "flags"
};
const tuvalu = {
  keywords: [
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇹🇻",
  fitzpatrick_scale: false,
  category: "flags"
};
const uganda = {
  keywords: [
    "ug",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇺🇬",
  fitzpatrick_scale: false,
  category: "flags"
};
const ukraine = {
  keywords: [
    "ua",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇺🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const united_arab_emirates = {
  keywords: [
    "united",
    "arab",
    "emirates",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇦🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const uk = {
  keywords: [
    "united",
    "kingdom",
    "great",
    "britain",
    "northern",
    "ireland",
    "flag",
    "nation",
    "country",
    "banner",
    "british",
    "UK",
    "english",
    "england",
    "union jack"
  ],
  char: "🇬🇧",
  fitzpatrick_scale: false,
  category: "flags"
};
const england = {
  keywords: [
    "flag",
    "english"
  ],
  char: "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
  fitzpatrick_scale: false,
  category: "flags"
};
const scotland = {
  keywords: [
    "flag",
    "scottish"
  ],
  char: "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
  fitzpatrick_scale: false,
  category: "flags"
};
const wales = {
  keywords: [
    "flag",
    "welsh"
  ],
  char: "🏴󠁧󠁢󠁷󠁬󠁳󠁿",
  fitzpatrick_scale: false,
  category: "flags"
};
const us = {
  keywords: [
    "united",
    "states",
    "america",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇺🇸",
  fitzpatrick_scale: false,
  category: "flags"
};
const us_virgin_islands = {
  keywords: [
    "virgin",
    "islands",
    "us",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇮",
  fitzpatrick_scale: false,
  category: "flags"
};
const uruguay = {
  keywords: [
    "uy",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇺🇾",
  fitzpatrick_scale: false,
  category: "flags"
};
const uzbekistan = {
  keywords: [
    "uz",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇺🇿",
  fitzpatrick_scale: false,
  category: "flags"
};
const vanuatu = {
  keywords: [
    "vu",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇺",
  fitzpatrick_scale: false,
  category: "flags"
};
const vatican_city = {
  keywords: [
    "vatican",
    "city",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇦",
  fitzpatrick_scale: false,
  category: "flags"
};
const venezuela = {
  keywords: [
    "ve",
    "bolivarian",
    "republic",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const vietnam = {
  keywords: [
    "viet",
    "nam",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇻🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const wallis_futuna = {
  keywords: [
    "wallis",
    "futuna",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇼🇫",
  fitzpatrick_scale: false,
  category: "flags"
};
const western_sahara = {
  keywords: [
    "western",
    "sahara",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇪🇭",
  fitzpatrick_scale: false,
  category: "flags"
};
const yemen = {
  keywords: [
    "ye",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇾🇪",
  fitzpatrick_scale: false,
  category: "flags"
};
const zambia = {
  keywords: [
    "zm",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇿🇲",
  fitzpatrick_scale: false,
  category: "flags"
};
const zimbabwe = {
  keywords: [
    "zw",
    "flag",
    "nation",
    "country",
    "banner"
  ],
  char: "🇿🇼",
  fitzpatrick_scale: false,
  category: "flags"
};
const united_nations = {
  keywords: [
    "un",
    "flag",
    "banner"
  ],
  char: "🇺🇳",
  fitzpatrick_scale: false,
  category: "flags"
};
const pirate_flag = {
  keywords: [
    "skull",
    "crossbones",
    "flag",
    "banner"
  ],
  char: "🏴‍☠️",
  fitzpatrick_scale: false,
  category: "flags"
};
const require$$0 = {
  "100": {
    keywords: [
      "score",
      "perfect",
      "numbers",
      "century",
      "exam",
      "quiz",
      "test",
      "pass",
      "hundred"
    ],
    char: "💯",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  "1234": {
    keywords: [
      "numbers",
      "blue-square"
    ],
    char: "🔢",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  grinning,
  grimacing,
  grin,
  joy,
  rofl,
  partying,
  smiley,
  smile,
  sweat_smile,
  laughing,
  innocent,
  wink,
  blush,
  slightly_smiling_face,
  upside_down_face,
  relaxed,
  yum,
  relieved,
  heart_eyes,
  smiling_face_with_three_hearts,
  kissing_heart,
  kissing,
  kissing_smiling_eyes,
  kissing_closed_eyes,
  stuck_out_tongue_winking_eye,
  zany,
  raised_eyebrow,
  monocle,
  stuck_out_tongue_closed_eyes,
  stuck_out_tongue,
  money_mouth_face,
  nerd_face,
  sunglasses,
  star_struck,
  clown_face,
  cowboy_hat_face,
  hugs,
  smirk,
  no_mouth,
  neutral_face,
  expressionless,
  unamused,
  roll_eyes,
  thinking,
  lying_face,
  hand_over_mouth,
  shushing,
  symbols_over_mouth,
  exploding_head,
  flushed,
  disappointed,
  worried,
  angry,
  rage,
  pensive,
  confused,
  slightly_frowning_face,
  frowning_face,
  persevere,
  confounded,
  tired_face,
  weary,
  pleading,
  triumph,
  open_mouth,
  scream,
  fearful,
  cold_sweat,
  hushed,
  frowning,
  anguished,
  cry,
  disappointed_relieved,
  drooling_face,
  sleepy,
  sweat,
  hot,
  cold,
  sob,
  dizzy_face,
  astonished,
  zipper_mouth_face,
  nauseated_face,
  sneezing_face,
  vomiting,
  mask,
  face_with_thermometer,
  face_with_head_bandage,
  woozy,
  sleeping,
  zzz,
  poop,
  smiling_imp,
  imp,
  japanese_ogre,
  japanese_goblin,
  skull,
  ghost,
  alien,
  robot,
  smiley_cat,
  smile_cat,
  joy_cat,
  heart_eyes_cat,
  smirk_cat,
  kissing_cat,
  scream_cat,
  crying_cat_face,
  pouting_cat,
  palms_up,
  raised_hands,
  clap,
  wave,
  call_me_hand,
  "+1": {
    keywords: [
      "thumbsup",
      "yes",
      "awesome",
      "good",
      "agree",
      "accept",
      "cool",
      "hand",
      "like"
    ],
    char: "👍",
    fitzpatrick_scale: true,
    category: "people"
  },
  "-1": {
    keywords: [
      "thumbsdown",
      "no",
      "dislike",
      "hand"
    ],
    char: "👎",
    fitzpatrick_scale: true,
    category: "people"
  },
  facepunch,
  fist,
  fist_left,
  fist_right,
  v,
  ok_hand,
  raised_hand,
  raised_back_of_hand,
  open_hands,
  muscle,
  pray,
  foot,
  leg,
  handshake,
  point_up,
  point_up_2,
  point_down,
  point_left,
  point_right,
  fu,
  raised_hand_with_fingers_splayed,
  love_you,
  metal,
  crossed_fingers,
  vulcan_salute,
  writing_hand,
  selfie,
  nail_care,
  lips,
  tooth,
  tongue,
  ear,
  nose,
  eye,
  eyes,
  brain,
  bust_in_silhouette,
  busts_in_silhouette,
  speaking_head,
  baby,
  child,
  boy,
  girl,
  adult,
  man,
  woman,
  blonde_woman,
  blonde_man,
  bearded_person,
  older_adult,
  older_man,
  older_woman,
  man_with_gua_pi_mao,
  woman_with_headscarf,
  woman_with_turban,
  man_with_turban,
  policewoman,
  policeman,
  construction_worker_woman,
  construction_worker_man,
  guardswoman,
  guardsman,
  female_detective,
  male_detective,
  woman_health_worker,
  man_health_worker,
  woman_farmer,
  man_farmer,
  woman_cook,
  man_cook,
  woman_student,
  man_student,
  woman_singer,
  man_singer,
  woman_teacher,
  man_teacher,
  woman_factory_worker,
  man_factory_worker,
  woman_technologist,
  man_technologist,
  woman_office_worker,
  man_office_worker,
  woman_mechanic,
  man_mechanic,
  woman_scientist,
  man_scientist,
  woman_artist,
  man_artist,
  woman_firefighter,
  man_firefighter,
  woman_pilot,
  man_pilot,
  woman_astronaut,
  man_astronaut,
  woman_judge,
  man_judge,
  woman_superhero,
  man_superhero,
  woman_supervillain,
  man_supervillain,
  mrs_claus,
  santa,
  sorceress,
  wizard,
  woman_elf,
  man_elf,
  woman_vampire,
  man_vampire,
  woman_zombie,
  man_zombie,
  woman_genie,
  man_genie,
  mermaid,
  merman,
  woman_fairy,
  man_fairy,
  angel,
  pregnant_woman,
  breastfeeding,
  princess,
  prince,
  bride_with_veil,
  man_in_tuxedo,
  running_woman,
  running_man,
  walking_woman,
  walking_man,
  dancer,
  man_dancing,
  dancing_women,
  dancing_men,
  couple,
  two_men_holding_hands,
  two_women_holding_hands,
  bowing_woman,
  bowing_man,
  man_facepalming,
  woman_facepalming,
  woman_shrugging,
  man_shrugging,
  tipping_hand_woman,
  tipping_hand_man,
  no_good_woman,
  no_good_man,
  ok_woman,
  ok_man,
  raising_hand_woman,
  raising_hand_man,
  pouting_woman,
  pouting_man,
  frowning_woman,
  frowning_man,
  haircut_woman,
  haircut_man,
  massage_woman,
  massage_man,
  woman_in_steamy_room,
  man_in_steamy_room,
  couple_with_heart_woman_man,
  couple_with_heart_woman_woman,
  couple_with_heart_man_man,
  couplekiss_man_woman,
  couplekiss_woman_woman,
  couplekiss_man_man,
  family_man_woman_boy,
  family_man_woman_girl,
  family_man_woman_girl_boy,
  family_man_woman_boy_boy,
  family_man_woman_girl_girl,
  family_woman_woman_boy,
  family_woman_woman_girl,
  family_woman_woman_girl_boy,
  family_woman_woman_boy_boy,
  family_woman_woman_girl_girl,
  family_man_man_boy,
  family_man_man_girl,
  family_man_man_girl_boy,
  family_man_man_boy_boy,
  family_man_man_girl_girl,
  family_woman_boy,
  family_woman_girl,
  family_woman_girl_boy,
  family_woman_boy_boy,
  family_woman_girl_girl,
  family_man_boy,
  family_man_girl,
  family_man_girl_boy,
  family_man_boy_boy,
  family_man_girl_girl,
  yarn,
  thread,
  coat,
  labcoat,
  womans_clothes,
  tshirt,
  jeans,
  necktie,
  dress,
  bikini,
  kimono,
  lipstick,
  kiss,
  footprints,
  flat_shoe,
  high_heel,
  sandal,
  boot,
  mans_shoe,
  athletic_shoe,
  hiking_boot,
  socks,
  gloves,
  scarf,
  womans_hat,
  tophat,
  billed_hat,
  rescue_worker_helmet,
  mortar_board,
  crown,
  school_satchel,
  luggage,
  pouch,
  purse,
  handbag,
  briefcase,
  eyeglasses,
  dark_sunglasses,
  goggles,
  ring,
  closed_umbrella,
  dog,
  cat,
  mouse,
  hamster,
  rabbit,
  fox_face,
  bear,
  panda_face,
  koala,
  tiger,
  lion,
  cow,
  pig,
  pig_nose,
  frog,
  squid,
  octopus,
  shrimp,
  monkey_face,
  gorilla,
  see_no_evil,
  hear_no_evil,
  speak_no_evil,
  monkey,
  chicken,
  penguin,
  bird,
  baby_chick,
  hatching_chick,
  hatched_chick,
  duck,
  eagle,
  owl,
  bat,
  wolf,
  boar,
  horse,
  unicorn,
  honeybee,
  bug,
  butterfly,
  snail,
  beetle,
  ant,
  grasshopper,
  spider,
  scorpion,
  crab,
  snake,
  lizard,
  "t-rex": {
    keywords: [
      "animal",
      "nature",
      "dinosaur",
      "tyrannosaurus",
      "extinct"
    ],
    char: "🦖",
    fitzpatrick_scale: false,
    category: "animals_and_nature"
  },
  sauropod,
  turtle,
  tropical_fish,
  fish,
  blowfish,
  dolphin,
  shark,
  whale,
  whale2,
  crocodile,
  leopard,
  zebra,
  tiger2,
  water_buffalo,
  ox,
  cow2,
  deer,
  dromedary_camel,
  camel,
  giraffe,
  elephant,
  rhinoceros,
  goat,
  ram,
  sheep,
  racehorse,
  pig2,
  rat,
  mouse2,
  rooster,
  turkey,
  dove,
  dog2,
  poodle,
  cat2,
  rabbit2,
  chipmunk,
  hedgehog,
  raccoon,
  llama,
  hippopotamus,
  kangaroo,
  badger,
  swan,
  peacock,
  parrot,
  lobster,
  mosquito,
  paw_prints,
  dragon,
  dragon_face,
  cactus,
  christmas_tree,
  evergreen_tree,
  deciduous_tree,
  palm_tree,
  seedling,
  herb,
  shamrock,
  four_leaf_clover,
  bamboo,
  tanabata_tree,
  leaves,
  fallen_leaf,
  maple_leaf,
  ear_of_rice,
  hibiscus,
  sunflower,
  rose,
  wilted_flower,
  tulip,
  blossom,
  cherry_blossom,
  bouquet,
  mushroom,
  chestnut,
  jack_o_lantern,
  shell,
  spider_web,
  earth_americas,
  earth_africa,
  earth_asia,
  full_moon,
  waning_gibbous_moon,
  last_quarter_moon,
  waning_crescent_moon,
  new_moon,
  waxing_crescent_moon,
  first_quarter_moon,
  waxing_gibbous_moon,
  new_moon_with_face,
  full_moon_with_face,
  first_quarter_moon_with_face,
  last_quarter_moon_with_face,
  sun_with_face,
  crescent_moon,
  star,
  star2,
  dizzy,
  sparkles,
  comet,
  sunny,
  sun_behind_small_cloud,
  partly_sunny,
  sun_behind_large_cloud,
  sun_behind_rain_cloud,
  cloud,
  cloud_with_rain,
  cloud_with_lightning_and_rain,
  cloud_with_lightning,
  zap,
  fire,
  boom,
  snowflake,
  cloud_with_snow,
  snowman,
  snowman_with_snow,
  wind_face,
  dash: dash$1,
  tornado,
  fog,
  open_umbrella,
  umbrella,
  droplet,
  sweat_drops,
  ocean,
  green_apple,
  apple,
  pear,
  tangerine,
  lemon,
  banana,
  watermelon,
  grapes,
  strawberry,
  melon,
  cherries,
  peach,
  pineapple,
  coconut,
  kiwi_fruit,
  mango,
  avocado,
  broccoli,
  tomato,
  eggplant,
  cucumber,
  carrot,
  hot_pepper,
  potato,
  corn,
  leafy_greens,
  sweet_potato,
  peanuts,
  honey_pot,
  croissant,
  bread,
  baguette_bread,
  bagel,
  pretzel,
  cheese,
  egg,
  bacon,
  steak,
  pancakes,
  poultry_leg,
  meat_on_bone,
  bone,
  fried_shrimp,
  fried_egg,
  hamburger,
  fries,
  stuffed_flatbread,
  hotdog,
  pizza,
  sandwich,
  canned_food,
  spaghetti,
  taco,
  burrito,
  green_salad,
  shallow_pan_of_food,
  ramen,
  stew,
  fish_cake,
  fortune_cookie,
  sushi,
  bento,
  curry,
  rice_ball,
  rice,
  rice_cracker,
  oden,
  dango,
  shaved_ice,
  ice_cream,
  icecream,
  pie,
  cake,
  cupcake,
  moon_cake,
  birthday,
  custard,
  candy,
  lollipop,
  chocolate_bar,
  popcorn,
  dumpling,
  doughnut,
  cookie,
  milk_glass,
  beer,
  beers,
  clinking_glasses,
  wine_glass,
  tumbler_glass,
  cocktail,
  tropical_drink,
  champagne,
  sake,
  tea,
  cup_with_straw,
  coffee,
  baby_bottle,
  salt,
  spoon,
  fork_and_knife,
  plate_with_cutlery,
  bowl_with_spoon,
  takeout_box,
  chopsticks,
  soccer,
  basketball,
  football,
  baseball,
  softball,
  tennis,
  volleyball,
  rugby_football,
  flying_disc,
  "8ball": {
    keywords: [
      "pool",
      "hobby",
      "game",
      "luck",
      "magic"
    ],
    char: "🎱",
    fitzpatrick_scale: false,
    category: "activity"
  },
  golf,
  golfing_woman,
  golfing_man,
  ping_pong,
  badminton,
  goal_net,
  ice_hockey,
  field_hockey,
  lacrosse,
  cricket,
  ski,
  skier,
  snowboarder,
  person_fencing,
  women_wrestling,
  men_wrestling,
  woman_cartwheeling,
  man_cartwheeling,
  woman_playing_handball,
  man_playing_handball,
  ice_skate,
  curling_stone,
  skateboard,
  sled,
  bow_and_arrow,
  fishing_pole_and_fish,
  boxing_glove,
  martial_arts_uniform,
  rowing_woman,
  rowing_man,
  climbing_woman,
  climbing_man,
  swimming_woman,
  swimming_man,
  woman_playing_water_polo,
  man_playing_water_polo,
  woman_in_lotus_position,
  man_in_lotus_position,
  surfing_woman,
  surfing_man,
  bath,
  basketball_woman,
  basketball_man,
  weight_lifting_woman,
  weight_lifting_man,
  biking_woman,
  biking_man,
  mountain_biking_woman,
  mountain_biking_man,
  horse_racing,
  business_suit_levitating,
  trophy,
  running_shirt_with_sash,
  medal_sports,
  medal_military,
  "1st_place_medal": {
    keywords: [
      "award",
      "winning",
      "first"
    ],
    char: "🥇",
    fitzpatrick_scale: false,
    category: "activity"
  },
  "2nd_place_medal": {
    keywords: [
      "award",
      "second"
    ],
    char: "🥈",
    fitzpatrick_scale: false,
    category: "activity"
  },
  "3rd_place_medal": {
    keywords: [
      "award",
      "third"
    ],
    char: "🥉",
    fitzpatrick_scale: false,
    category: "activity"
  },
  reminder_ribbon,
  rosette,
  ticket,
  tickets,
  performing_arts,
  art,
  circus_tent,
  woman_juggling,
  man_juggling,
  microphone,
  headphones,
  musical_score,
  musical_keyboard,
  drum,
  saxophone,
  trumpet,
  guitar,
  violin,
  clapper,
  video_game,
  space_invader,
  dart,
  game_die,
  chess_pawn,
  slot_machine,
  jigsaw,
  bowling,
  red_car,
  taxi,
  blue_car,
  bus,
  trolleybus,
  racing_car,
  police_car,
  ambulance,
  fire_engine,
  minibus,
  truck,
  articulated_lorry,
  tractor,
  kick_scooter,
  motorcycle,
  bike,
  motor_scooter,
  rotating_light,
  oncoming_police_car,
  oncoming_bus,
  oncoming_automobile,
  oncoming_taxi,
  aerial_tramway,
  mountain_cableway,
  suspension_railway,
  railway_car,
  train,
  monorail,
  bullettrain_side,
  bullettrain_front,
  light_rail,
  mountain_railway,
  steam_locomotive,
  train2,
  metro,
  tram,
  station,
  flying_saucer,
  helicopter,
  small_airplane,
  airplane,
  flight_departure,
  flight_arrival,
  sailboat,
  motor_boat,
  speedboat,
  ferry,
  passenger_ship,
  rocket,
  artificial_satellite,
  seat,
  canoe,
  anchor,
  construction,
  fuelpump,
  busstop,
  vertical_traffic_light,
  traffic_light,
  checkered_flag,
  ship,
  ferris_wheel,
  roller_coaster,
  carousel_horse,
  building_construction,
  foggy,
  tokyo_tower,
  factory,
  fountain,
  rice_scene,
  mountain,
  mountain_snow,
  mount_fuji,
  volcano,
  japan,
  camping,
  tent,
  national_park,
  motorway,
  railway_track,
  sunrise,
  sunrise_over_mountains,
  desert,
  beach_umbrella,
  desert_island,
  city_sunrise,
  city_sunset,
  cityscape,
  night_with_stars,
  bridge_at_night,
  milky_way,
  stars,
  sparkler,
  fireworks,
  rainbow,
  houses,
  european_castle,
  japanese_castle,
  stadium,
  statue_of_liberty,
  house,
  house_with_garden,
  derelict_house,
  office,
  department_store,
  post_office,
  european_post_office,
  hospital,
  bank,
  hotel,
  convenience_store,
  school,
  love_hotel,
  wedding,
  classical_building,
  church,
  mosque,
  synagogue,
  kaaba,
  shinto_shrine,
  watch,
  iphone,
  calling,
  computer,
  keyboard,
  desktop_computer,
  printer,
  computer_mouse,
  trackball,
  joystick,
  clamp,
  minidisc,
  floppy_disk,
  cd,
  dvd,
  vhs,
  camera,
  camera_flash,
  video_camera,
  movie_camera,
  film_projector,
  film_strip,
  telephone_receiver,
  phone,
  pager,
  fax,
  tv,
  radio,
  studio_microphone,
  level_slider,
  control_knobs,
  compass,
  stopwatch,
  timer_clock,
  alarm_clock,
  mantelpiece_clock,
  hourglass_flowing_sand,
  hourglass,
  satellite,
  battery,
  electric_plug,
  bulb,
  flashlight,
  candle,
  fire_extinguisher,
  wastebasket,
  oil_drum,
  money_with_wings,
  dollar,
  yen,
  euro,
  pound,
  moneybag,
  credit_card,
  gem,
  balance_scale,
  toolbox,
  wrench,
  hammer,
  hammer_and_pick,
  hammer_and_wrench,
  pick,
  nut_and_bolt,
  gear,
  brick,
  chains,
  magnet,
  gun,
  bomb,
  firecracker,
  hocho,
  dagger,
  crossed_swords,
  shield,
  smoking,
  skull_and_crossbones,
  coffin,
  funeral_urn,
  amphora,
  crystal_ball,
  prayer_beads,
  nazar_amulet,
  barber,
  alembic,
  telescope,
  microscope,
  hole,
  pill,
  syringe,
  dna,
  microbe,
  petri_dish,
  test_tube,
  thermometer,
  broom,
  basket,
  toilet_paper,
  label,
  bookmark,
  toilet,
  shower,
  bathtub,
  soap,
  sponge,
  lotion_bottle,
  key,
  old_key,
  couch_and_lamp,
  sleeping_bed,
  bed,
  door,
  bellhop_bell,
  teddy_bear,
  framed_picture,
  world_map,
  parasol_on_ground,
  moyai,
  shopping,
  shopping_cart,
  balloon,
  flags,
  ribbon,
  gift,
  confetti_ball,
  tada,
  dolls,
  wind_chime,
  crossed_flags,
  izakaya_lantern,
  red_envelope,
  email,
  envelope_with_arrow,
  incoming_envelope,
  "e-mail": {
    keywords: [
      "communication",
      "inbox"
    ],
    char: "📧",
    fitzpatrick_scale: false,
    category: "objects"
  },
  love_letter,
  postbox,
  mailbox_closed,
  mailbox,
  mailbox_with_mail,
  mailbox_with_no_mail,
  "package": {
    keywords: [
      "mail",
      "gift",
      "cardboard",
      "box",
      "moving"
    ],
    char: "📦",
    fitzpatrick_scale: false,
    category: "objects"
  },
  postal_horn,
  inbox_tray,
  outbox_tray,
  scroll,
  page_with_curl,
  bookmark_tabs,
  receipt,
  bar_chart,
  chart_with_upwards_trend,
  chart_with_downwards_trend,
  page_facing_up,
  date,
  calendar,
  spiral_calendar,
  card_index,
  card_file_box,
  ballot_box,
  file_cabinet,
  clipboard,
  spiral_notepad,
  file_folder,
  open_file_folder,
  card_index_dividers,
  newspaper_roll,
  newspaper,
  notebook,
  closed_book,
  green_book,
  blue_book,
  orange_book,
  notebook_with_decorative_cover,
  ledger,
  books,
  open_book,
  safety_pin,
  link: link$1,
  paperclip,
  paperclips,
  scissors,
  triangular_ruler,
  straight_ruler,
  abacus,
  pushpin,
  round_pushpin,
  triangular_flag_on_post,
  white_flag,
  black_flag,
  rainbow_flag,
  closed_lock_with_key,
  lock,
  unlock,
  lock_with_ink_pen,
  pen,
  fountain_pen,
  black_nib,
  memo,
  pencil2,
  crayon,
  paintbrush,
  mag,
  mag_right,
  heart,
  orange_heart,
  yellow_heart,
  green_heart,
  blue_heart,
  purple_heart,
  black_heart,
  broken_heart,
  heavy_heart_exclamation,
  two_hearts,
  revolving_hearts,
  heartbeat,
  heartpulse,
  sparkling_heart,
  cupid,
  gift_heart,
  heart_decoration,
  peace_symbol,
  latin_cross,
  star_and_crescent,
  om,
  wheel_of_dharma,
  star_of_david,
  six_pointed_star,
  menorah,
  yin_yang,
  orthodox_cross,
  place_of_worship,
  ophiuchus,
  aries,
  taurus,
  gemini,
  cancer,
  leo,
  virgo,
  libra,
  scorpius,
  sagittarius,
  capricorn,
  aquarius,
  pisces,
  id,
  atom_symbol,
  u7a7a,
  u5272,
  radioactive,
  biohazard,
  mobile_phone_off,
  vibration_mode,
  u6709,
  u7121,
  u7533,
  u55b6,
  u6708,
  eight_pointed_black_star,
  vs,
  accept,
  white_flower,
  ideograph_advantage,
  secret,
  congratulations,
  u5408,
  u6e80,
  u7981,
  a,
  b,
  ab,
  cl,
  o2,
  sos,
  no_entry,
  name_badge,
  no_entry_sign,
  x,
  o,
  stop_sign,
  anger,
  hotsprings,
  no_pedestrians,
  do_not_litter,
  no_bicycles,
  "non-potable_water": {
    keywords: [
      "drink",
      "faucet",
      "tap",
      "circle"
    ],
    char: "🚱",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  underage,
  no_mobile_phones,
  exclamation,
  grey_exclamation,
  question,
  grey_question,
  bangbang,
  interrobang,
  low_brightness,
  high_brightness,
  trident,
  fleur_de_lis,
  part_alternation_mark,
  warning,
  children_crossing,
  beginner,
  recycle,
  u6307,
  chart,
  sparkle,
  eight_spoked_asterisk,
  negative_squared_cross_mark,
  white_check_mark,
  diamond_shape_with_a_dot_inside,
  cyclone,
  loop,
  globe_with_meridians,
  m,
  atm,
  sa,
  passport_control,
  customs,
  baggage_claim,
  left_luggage,
  wheelchair,
  no_smoking,
  wc,
  parking,
  potable_water,
  mens,
  womens,
  baby_symbol,
  restroom,
  put_litter_in_its_place,
  cinema,
  signal_strength,
  koko,
  ng,
  ok,
  up,
  cool,
  "new": {
    keywords: [
      "blue-square",
      "words",
      "start"
    ],
    char: "🆕",
    fitzpatrick_scale: false,
    category: "symbols"
  },
  free,
  zero,
  one: one$1,
  two,
  three,
  four,
  five,
  six,
  seven,
  eight,
  nine,
  keycap_ten,
  asterisk,
  eject_button,
  arrow_forward,
  pause_button,
  next_track_button,
  stop_button,
  record_button,
  play_or_pause_button,
  previous_track_button,
  fast_forward,
  rewind,
  twisted_rightwards_arrows,
  repeat,
  repeat_one,
  arrow_backward,
  arrow_up_small,
  arrow_down_small,
  arrow_double_up,
  arrow_double_down,
  arrow_right,
  arrow_left,
  arrow_up,
  arrow_down,
  arrow_upper_right,
  arrow_lower_right,
  arrow_lower_left,
  arrow_upper_left,
  arrow_up_down,
  left_right_arrow,
  arrows_counterclockwise,
  arrow_right_hook,
  leftwards_arrow_with_hook,
  arrow_heading_up,
  arrow_heading_down,
  hash,
  information_source,
  abc,
  abcd,
  capital_abcd,
  symbols,
  musical_note,
  notes,
  wavy_dash,
  curly_loop,
  heavy_check_mark,
  arrows_clockwise,
  heavy_plus_sign,
  heavy_minus_sign,
  heavy_division_sign,
  heavy_multiplication_x,
  infinity,
  heavy_dollar_sign,
  currency_exchange,
  copyright,
  registered,
  tm,
  end,
  back,
  on,
  top,
  soon,
  ballot_box_with_check,
  radio_button,
  white_circle,
  black_circle,
  red_circle,
  large_blue_circle,
  small_orange_diamond,
  small_blue_diamond,
  large_orange_diamond,
  large_blue_diamond,
  small_red_triangle,
  black_small_square,
  white_small_square,
  black_large_square,
  white_large_square,
  small_red_triangle_down,
  black_medium_square,
  white_medium_square,
  black_medium_small_square,
  white_medium_small_square,
  black_square_button,
  white_square_button,
  speaker,
  sound,
  loud_sound,
  mute,
  mega,
  loudspeaker,
  bell,
  no_bell,
  black_joker,
  mahjong,
  spades,
  clubs,
  hearts,
  diamonds,
  flower_playing_cards,
  thought_balloon,
  right_anger_bubble,
  speech_balloon,
  left_speech_bubble,
  clock1,
  clock2,
  clock3,
  clock4,
  clock5,
  clock6,
  clock7,
  clock8,
  clock9,
  clock10,
  clock11,
  clock12,
  clock130,
  clock230,
  clock330,
  clock430,
  clock530,
  clock630,
  clock730,
  clock830,
  clock930,
  clock1030,
  clock1130,
  clock1230,
  afghanistan,
  aland_islands,
  albania,
  algeria,
  american_samoa,
  andorra,
  angola,
  anguilla,
  antarctica,
  antigua_barbuda,
  argentina,
  armenia,
  aruba,
  australia,
  austria,
  azerbaijan,
  bahamas,
  bahrain,
  bangladesh,
  barbados,
  belarus,
  belgium,
  belize,
  benin,
  bermuda,
  bhutan,
  bolivia,
  caribbean_netherlands,
  bosnia_herzegovina,
  botswana,
  brazil,
  british_indian_ocean_territory,
  british_virgin_islands,
  brunei,
  bulgaria,
  burkina_faso,
  burundi,
  cape_verde,
  cambodia,
  cameroon,
  canada,
  canary_islands,
  cayman_islands,
  central_african_republic,
  chad,
  chile,
  cn,
  christmas_island,
  cocos_islands,
  colombia,
  comoros,
  congo_brazzaville,
  congo_kinshasa,
  cook_islands,
  costa_rica,
  croatia,
  cuba,
  curacao,
  cyprus,
  czech_republic,
  denmark,
  djibouti,
  dominica,
  dominican_republic,
  ecuador,
  egypt,
  el_salvador,
  equatorial_guinea,
  eritrea,
  estonia,
  ethiopia,
  eu,
  falkland_islands,
  faroe_islands,
  fiji,
  finland,
  fr,
  french_guiana,
  french_polynesia,
  french_southern_territories,
  gabon,
  gambia,
  georgia,
  de,
  ghana,
  gibraltar,
  greece,
  greenland,
  grenada,
  guadeloupe,
  guam,
  guatemala,
  guernsey,
  guinea,
  guinea_bissau,
  guyana,
  haiti,
  honduras,
  hong_kong,
  hungary,
  iceland,
  india,
  indonesia,
  iran,
  iraq,
  ireland,
  isle_of_man,
  israel,
  it,
  cote_divoire,
  jamaica,
  jp,
  jersey,
  jordan,
  kazakhstan,
  kenya,
  kiribati,
  kosovo,
  kuwait,
  kyrgyzstan,
  laos,
  latvia,
  lebanon,
  lesotho,
  liberia,
  libya,
  liechtenstein,
  lithuania,
  luxembourg,
  macau,
  macedonia,
  madagascar,
  malawi,
  malaysia,
  maldives,
  mali,
  malta,
  marshall_islands,
  martinique,
  mauritania,
  mauritius,
  mayotte,
  mexico,
  micronesia,
  moldova,
  monaco,
  mongolia,
  montenegro,
  montserrat,
  morocco,
  mozambique,
  myanmar,
  namibia,
  nauru,
  nepal,
  netherlands,
  new_caledonia,
  new_zealand,
  nicaragua,
  niger,
  nigeria,
  niue,
  norfolk_island,
  northern_mariana_islands,
  north_korea,
  norway,
  oman,
  pakistan,
  palau,
  palestinian_territories,
  panama,
  papua_new_guinea,
  paraguay,
  peru,
  philippines,
  pitcairn_islands,
  poland,
  portugal,
  puerto_rico,
  qatar,
  reunion,
  romania,
  ru,
  rwanda,
  st_barthelemy,
  st_helena,
  st_kitts_nevis,
  st_lucia,
  st_pierre_miquelon,
  st_vincent_grenadines,
  samoa,
  san_marino,
  sao_tome_principe,
  saudi_arabia,
  senegal,
  serbia,
  seychelles,
  sierra_leone,
  singapore,
  sint_maarten,
  slovakia,
  slovenia,
  solomon_islands,
  somalia,
  south_africa,
  south_georgia_south_sandwich_islands,
  kr,
  south_sudan,
  es,
  sri_lanka,
  sudan,
  suriname,
  swaziland,
  sweden,
  switzerland,
  syria,
  taiwan,
  tajikistan,
  tanzania,
  thailand,
  timor_leste,
  togo,
  tokelau,
  tonga,
  trinidad_tobago,
  tunisia,
  tr,
  turkmenistan,
  turks_caicos_islands,
  tuvalu,
  uganda,
  ukraine,
  united_arab_emirates,
  uk,
  england,
  scotland,
  wales,
  us,
  us_virgin_islands,
  uruguay,
  uzbekistan,
  vanuatu,
  vatican_city,
  venezuela,
  vietnam,
  wallis_futuna,
  western_sahara,
  yemen,
  zambia,
  zimbabwe,
  united_nations,
  pirate_flag
};
const require$$1 = [
  "grinning",
  "smiley",
  "smile",
  "grin",
  "laughing",
  "sweat_smile",
  "joy",
  "rofl",
  "relaxed",
  "blush",
  "innocent",
  "slightly_smiling_face",
  "upside_down_face",
  "wink",
  "relieved",
  "heart_eyes",
  "smiling_face_with_three_hearts",
  "kissing_heart",
  "kissing",
  "kissing_smiling_eyes",
  "kissing_closed_eyes",
  "yum",
  "stuck_out_tongue",
  "stuck_out_tongue_closed_eyes",
  "stuck_out_tongue_winking_eye",
  "zany",
  "raised_eyebrow",
  "monocle",
  "nerd_face",
  "sunglasses",
  "star_struck",
  "partying",
  "smirk",
  "unamused",
  "disappointed",
  "pensive",
  "worried",
  "confused",
  "slightly_frowning_face",
  "frowning_face",
  "persevere",
  "confounded",
  "tired_face",
  "weary",
  "pleading",
  "cry",
  "sob",
  "triumph",
  "angry",
  "rage",
  "symbols_over_mouth",
  "exploding_head",
  "flushed",
  "hot",
  "cold",
  "scream",
  "fearful",
  "cold_sweat",
  "disappointed_relieved",
  "sweat",
  "hugs",
  "thinking",
  "hand_over_mouth",
  "shushing",
  "lying_face",
  "no_mouth",
  "neutral_face",
  "expressionless",
  "grimacing",
  "roll_eyes",
  "hushed",
  "frowning",
  "anguished",
  "open_mouth",
  "astonished",
  "sleeping",
  "drooling_face",
  "sleepy",
  "dizzy_face",
  "zipper_mouth_face",
  "woozy",
  "nauseated_face",
  "vomiting",
  "sneezing_face",
  "mask",
  "face_with_thermometer",
  "face_with_head_bandage",
  "money_mouth_face",
  "cowboy_hat_face",
  "smiling_imp",
  "imp",
  "japanese_ogre",
  "japanese_goblin",
  "clown_face",
  "poop",
  "ghost",
  "skull",
  "skull_and_crossbones",
  "alien",
  "space_invader",
  "robot",
  "jack_o_lantern",
  "smiley_cat",
  "smile_cat",
  "joy_cat",
  "heart_eyes_cat",
  "smirk_cat",
  "kissing_cat",
  "scream_cat",
  "crying_cat_face",
  "pouting_cat",
  "palms_up",
  "open_hands",
  "raised_hands",
  "clap",
  "handshake",
  "+1",
  "-1",
  "facepunch",
  "fist",
  "fist_left",
  "fist_right",
  "crossed_fingers",
  "v",
  "love_you",
  "metal",
  "ok_hand",
  "point_left",
  "point_right",
  "point_up",
  "point_down",
  "point_up_2",
  "raised_hand",
  "raised_back_of_hand",
  "raised_hand_with_fingers_splayed",
  "vulcan_salute",
  "wave",
  "call_me_hand",
  "muscle",
  "fu",
  "writing_hand",
  "pray",
  "foot",
  "leg",
  "ring",
  "lipstick",
  "kiss",
  "lips",
  "tooth",
  "tongue",
  "ear",
  "nose",
  "footprints",
  "eye",
  "eyes",
  "brain",
  "speaking_head",
  "bust_in_silhouette",
  "busts_in_silhouette",
  "baby",
  "girl",
  "child",
  "boy",
  "woman",
  "adult",
  "man",
  "blonde_woman",
  "blonde_man",
  "bearded_person",
  "older_woman",
  "older_adult",
  "older_man",
  "man_with_gua_pi_mao",
  "woman_with_headscarf",
  "woman_with_turban",
  "man_with_turban",
  "policewoman",
  "policeman",
  "construction_worker_woman",
  "construction_worker_man",
  "guardswoman",
  "guardsman",
  "female_detective",
  "male_detective",
  "woman_health_worker",
  "man_health_worker",
  "woman_farmer",
  "man_farmer",
  "woman_cook",
  "man_cook",
  "woman_student",
  "man_student",
  "woman_singer",
  "man_singer",
  "woman_teacher",
  "man_teacher",
  "woman_factory_worker",
  "man_factory_worker",
  "woman_technologist",
  "man_technologist",
  "woman_office_worker",
  "man_office_worker",
  "woman_mechanic",
  "man_mechanic",
  "woman_scientist",
  "man_scientist",
  "woman_artist",
  "man_artist",
  "woman_firefighter",
  "man_firefighter",
  "woman_pilot",
  "man_pilot",
  "woman_astronaut",
  "man_astronaut",
  "woman_judge",
  "man_judge",
  "bride_with_veil",
  "man_in_tuxedo",
  "princess",
  "prince",
  "woman_superhero",
  "man_superhero",
  "woman_supervillain",
  "man_supervillain",
  "mrs_claus",
  "santa",
  "sorceress",
  "wizard",
  "woman_elf",
  "man_elf",
  "woman_vampire",
  "man_vampire",
  "woman_zombie",
  "man_zombie",
  "woman_genie",
  "man_genie",
  "mermaid",
  "merman",
  "woman_fairy",
  "man_fairy",
  "angel",
  "pregnant_woman",
  "breastfeeding",
  "bowing_woman",
  "bowing_man",
  "tipping_hand_woman",
  "tipping_hand_man",
  "no_good_woman",
  "no_good_man",
  "ok_woman",
  "ok_man",
  "raising_hand_woman",
  "raising_hand_man",
  "woman_facepalming",
  "man_facepalming",
  "woman_shrugging",
  "man_shrugging",
  "pouting_woman",
  "pouting_man",
  "frowning_woman",
  "frowning_man",
  "haircut_woman",
  "haircut_man",
  "massage_woman",
  "massage_man",
  "woman_in_steamy_room",
  "man_in_steamy_room",
  "nail_care",
  "selfie",
  "dancer",
  "man_dancing",
  "dancing_women",
  "dancing_men",
  "business_suit_levitating",
  "walking_woman",
  "walking_man",
  "running_woman",
  "running_man",
  "couple",
  "two_women_holding_hands",
  "two_men_holding_hands",
  "couple_with_heart_woman_man",
  "couple_with_heart_woman_woman",
  "couple_with_heart_man_man",
  "couplekiss_man_woman",
  "couplekiss_woman_woman",
  "couplekiss_man_man",
  "family_man_woman_boy",
  "family_man_woman_girl",
  "family_man_woman_girl_boy",
  "family_man_woman_boy_boy",
  "family_man_woman_girl_girl",
  "family_woman_woman_boy",
  "family_woman_woman_girl",
  "family_woman_woman_girl_boy",
  "family_woman_woman_boy_boy",
  "family_woman_woman_girl_girl",
  "family_man_man_boy",
  "family_man_man_girl",
  "family_man_man_girl_boy",
  "family_man_man_boy_boy",
  "family_man_man_girl_girl",
  "family_woman_boy",
  "family_woman_girl",
  "family_woman_girl_boy",
  "family_woman_boy_boy",
  "family_woman_girl_girl",
  "family_man_boy",
  "family_man_girl",
  "family_man_girl_boy",
  "family_man_boy_boy",
  "family_man_girl_girl",
  "yarn",
  "thread",
  "coat",
  "labcoat",
  "womans_clothes",
  "tshirt",
  "jeans",
  "necktie",
  "dress",
  "bikini",
  "kimono",
  "flat_shoe",
  "high_heel",
  "sandal",
  "boot",
  "mans_shoe",
  "athletic_shoe",
  "hiking_boot",
  "socks",
  "gloves",
  "scarf",
  "tophat",
  "billed_hat",
  "womans_hat",
  "mortar_board",
  "rescue_worker_helmet",
  "crown",
  "pouch",
  "purse",
  "handbag",
  "briefcase",
  "school_satchel",
  "luggage",
  "eyeglasses",
  "dark_sunglasses",
  "goggles",
  "closed_umbrella",
  "dog",
  "cat",
  "mouse",
  "hamster",
  "rabbit",
  "fox_face",
  "bear",
  "panda_face",
  "koala",
  "tiger",
  "lion",
  "cow",
  "pig",
  "pig_nose",
  "frog",
  "monkey_face",
  "see_no_evil",
  "hear_no_evil",
  "speak_no_evil",
  "monkey",
  "chicken",
  "penguin",
  "bird",
  "baby_chick",
  "hatching_chick",
  "hatched_chick",
  "duck",
  "eagle",
  "owl",
  "bat",
  "wolf",
  "boar",
  "horse",
  "unicorn",
  "honeybee",
  "bug",
  "butterfly",
  "snail",
  "shell",
  "beetle",
  "ant",
  "mosquito",
  "grasshopper",
  "spider",
  "spider_web",
  "scorpion",
  "turtle",
  "snake",
  "lizard",
  "t-rex",
  "sauropod",
  "octopus",
  "squid",
  "shrimp",
  "lobster",
  "crab",
  "blowfish",
  "tropical_fish",
  "fish",
  "dolphin",
  "whale",
  "whale2",
  "shark",
  "crocodile",
  "tiger2",
  "leopard",
  "zebra",
  "gorilla",
  "elephant",
  "hippopotamus",
  "rhinoceros",
  "dromedary_camel",
  "giraffe",
  "kangaroo",
  "camel",
  "water_buffalo",
  "ox",
  "cow2",
  "racehorse",
  "pig2",
  "ram",
  "sheep",
  "llama",
  "goat",
  "deer",
  "dog2",
  "poodle",
  "cat2",
  "rooster",
  "turkey",
  "peacock",
  "parrot",
  "swan",
  "dove",
  "rabbit2",
  "raccoon",
  "badger",
  "rat",
  "mouse2",
  "chipmunk",
  "hedgehog",
  "paw_prints",
  "dragon",
  "dragon_face",
  "cactus",
  "christmas_tree",
  "evergreen_tree",
  "deciduous_tree",
  "palm_tree",
  "seedling",
  "herb",
  "shamrock",
  "four_leaf_clover",
  "bamboo",
  "tanabata_tree",
  "leaves",
  "fallen_leaf",
  "maple_leaf",
  "ear_of_rice",
  "hibiscus",
  "sunflower",
  "rose",
  "wilted_flower",
  "tulip",
  "blossom",
  "cherry_blossom",
  "bouquet",
  "mushroom",
  "earth_americas",
  "earth_africa",
  "earth_asia",
  "full_moon",
  "waning_gibbous_moon",
  "last_quarter_moon",
  "waning_crescent_moon",
  "new_moon",
  "waxing_crescent_moon",
  "first_quarter_moon",
  "waxing_gibbous_moon",
  "new_moon_with_face",
  "full_moon_with_face",
  "first_quarter_moon_with_face",
  "last_quarter_moon_with_face",
  "sun_with_face",
  "crescent_moon",
  "star",
  "star2",
  "dizzy",
  "sparkles",
  "comet",
  "sunny",
  "sun_behind_small_cloud",
  "partly_sunny",
  "sun_behind_large_cloud",
  "sun_behind_rain_cloud",
  "cloud",
  "cloud_with_rain",
  "cloud_with_lightning_and_rain",
  "cloud_with_lightning",
  "zap",
  "fire",
  "boom",
  "snowflake",
  "cloud_with_snow",
  "snowman",
  "snowman_with_snow",
  "wind_face",
  "dash",
  "tornado",
  "fog",
  "open_umbrella",
  "umbrella",
  "droplet",
  "sweat_drops",
  "ocean",
  "green_apple",
  "apple",
  "pear",
  "tangerine",
  "lemon",
  "banana",
  "watermelon",
  "grapes",
  "strawberry",
  "melon",
  "cherries",
  "peach",
  "mango",
  "pineapple",
  "coconut",
  "kiwi_fruit",
  "tomato",
  "eggplant",
  "avocado",
  "broccoli",
  "leafy_greens",
  "cucumber",
  "hot_pepper",
  "corn",
  "carrot",
  "potato",
  "sweet_potato",
  "croissant",
  "bagel",
  "bread",
  "baguette_bread",
  "pretzel",
  "cheese",
  "egg",
  "fried_egg",
  "pancakes",
  "bacon",
  "steak",
  "poultry_leg",
  "meat_on_bone",
  "bone",
  "hotdog",
  "hamburger",
  "fries",
  "pizza",
  "sandwich",
  "stuffed_flatbread",
  "taco",
  "burrito",
  "green_salad",
  "shallow_pan_of_food",
  "canned_food",
  "spaghetti",
  "ramen",
  "stew",
  "curry",
  "sushi",
  "bento",
  "fried_shrimp",
  "rice_ball",
  "rice",
  "rice_cracker",
  "fish_cake",
  "fortune_cookie",
  "moon_cake",
  "oden",
  "dango",
  "shaved_ice",
  "ice_cream",
  "icecream",
  "pie",
  "cupcake",
  "cake",
  "birthday",
  "custard",
  "lollipop",
  "candy",
  "chocolate_bar",
  "popcorn",
  "doughnut",
  "dumpling",
  "cookie",
  "chestnut",
  "peanuts",
  "honey_pot",
  "milk_glass",
  "baby_bottle",
  "coffee",
  "tea",
  "cup_with_straw",
  "sake",
  "beer",
  "beers",
  "clinking_glasses",
  "wine_glass",
  "tumbler_glass",
  "cocktail",
  "tropical_drink",
  "champagne",
  "spoon",
  "fork_and_knife",
  "plate_with_cutlery",
  "bowl_with_spoon",
  "takeout_box",
  "chopsticks",
  "salt",
  "soccer",
  "basketball",
  "football",
  "baseball",
  "softball",
  "tennis",
  "volleyball",
  "rugby_football",
  "flying_disc",
  "8ball",
  "golf",
  "golfing_woman",
  "golfing_man",
  "ping_pong",
  "badminton",
  "goal_net",
  "ice_hockey",
  "field_hockey",
  "lacrosse",
  "cricket",
  "ski",
  "skier",
  "snowboarder",
  "person_fencing",
  "women_wrestling",
  "men_wrestling",
  "woman_cartwheeling",
  "man_cartwheeling",
  "woman_playing_handball",
  "man_playing_handball",
  "ice_skate",
  "curling_stone",
  "skateboard",
  "sled",
  "bow_and_arrow",
  "fishing_pole_and_fish",
  "boxing_glove",
  "martial_arts_uniform",
  "rowing_woman",
  "rowing_man",
  "climbing_woman",
  "climbing_man",
  "swimming_woman",
  "swimming_man",
  "woman_playing_water_polo",
  "man_playing_water_polo",
  "woman_in_lotus_position",
  "man_in_lotus_position",
  "surfing_woman",
  "surfing_man",
  "basketball_woman",
  "basketball_man",
  "weight_lifting_woman",
  "weight_lifting_man",
  "biking_woman",
  "biking_man",
  "mountain_biking_woman",
  "mountain_biking_man",
  "horse_racing",
  "trophy",
  "running_shirt_with_sash",
  "medal_sports",
  "medal_military",
  "1st_place_medal",
  "2nd_place_medal",
  "3rd_place_medal",
  "reminder_ribbon",
  "rosette",
  "ticket",
  "tickets",
  "performing_arts",
  "art",
  "circus_tent",
  "woman_juggling",
  "man_juggling",
  "microphone",
  "headphones",
  "musical_score",
  "musical_keyboard",
  "drum",
  "saxophone",
  "trumpet",
  "guitar",
  "violin",
  "clapper",
  "video_game",
  "dart",
  "game_die",
  "chess_pawn",
  "slot_machine",
  "jigsaw",
  "bowling",
  "red_car",
  "taxi",
  "blue_car",
  "bus",
  "trolleybus",
  "racing_car",
  "police_car",
  "ambulance",
  "fire_engine",
  "minibus",
  "truck",
  "articulated_lorry",
  "tractor",
  "kick_scooter",
  "motorcycle",
  "bike",
  "motor_scooter",
  "rotating_light",
  "oncoming_police_car",
  "oncoming_bus",
  "oncoming_automobile",
  "oncoming_taxi",
  "aerial_tramway",
  "mountain_cableway",
  "suspension_railway",
  "railway_car",
  "train",
  "monorail",
  "bullettrain_side",
  "bullettrain_front",
  "light_rail",
  "mountain_railway",
  "steam_locomotive",
  "train2",
  "metro",
  "tram",
  "station",
  "flying_saucer",
  "helicopter",
  "small_airplane",
  "airplane",
  "flight_departure",
  "flight_arrival",
  "sailboat",
  "motor_boat",
  "speedboat",
  "ferry",
  "passenger_ship",
  "rocket",
  "artificial_satellite",
  "seat",
  "canoe",
  "anchor",
  "construction",
  "fuelpump",
  "busstop",
  "vertical_traffic_light",
  "traffic_light",
  "ship",
  "ferris_wheel",
  "roller_coaster",
  "carousel_horse",
  "building_construction",
  "foggy",
  "tokyo_tower",
  "factory",
  "fountain",
  "rice_scene",
  "mountain",
  "mountain_snow",
  "mount_fuji",
  "volcano",
  "japan",
  "camping",
  "tent",
  "national_park",
  "motorway",
  "railway_track",
  "sunrise",
  "sunrise_over_mountains",
  "desert",
  "beach_umbrella",
  "desert_island",
  "city_sunrise",
  "city_sunset",
  "cityscape",
  "night_with_stars",
  "bridge_at_night",
  "milky_way",
  "stars",
  "sparkler",
  "fireworks",
  "rainbow",
  "houses",
  "european_castle",
  "japanese_castle",
  "stadium",
  "statue_of_liberty",
  "house",
  "house_with_garden",
  "derelict_house",
  "office",
  "department_store",
  "post_office",
  "european_post_office",
  "hospital",
  "bank",
  "hotel",
  "convenience_store",
  "school",
  "love_hotel",
  "wedding",
  "classical_building",
  "church",
  "mosque",
  "synagogue",
  "kaaba",
  "shinto_shrine",
  "watch",
  "iphone",
  "calling",
  "computer",
  "keyboard",
  "desktop_computer",
  "printer",
  "computer_mouse",
  "trackball",
  "joystick",
  "clamp",
  "minidisc",
  "floppy_disk",
  "cd",
  "dvd",
  "vhs",
  "camera",
  "camera_flash",
  "video_camera",
  "movie_camera",
  "film_projector",
  "film_strip",
  "telephone_receiver",
  "phone",
  "pager",
  "fax",
  "tv",
  "radio",
  "studio_microphone",
  "level_slider",
  "control_knobs",
  "compass",
  "stopwatch",
  "timer_clock",
  "alarm_clock",
  "mantelpiece_clock",
  "hourglass_flowing_sand",
  "hourglass",
  "satellite",
  "battery",
  "electric_plug",
  "bulb",
  "flashlight",
  "candle",
  "fire_extinguisher",
  "wastebasket",
  "oil_drum",
  "money_with_wings",
  "dollar",
  "yen",
  "euro",
  "pound",
  "moneybag",
  "credit_card",
  "gem",
  "balance_scale",
  "toolbox",
  "wrench",
  "hammer",
  "hammer_and_pick",
  "hammer_and_wrench",
  "pick",
  "nut_and_bolt",
  "gear",
  "brick",
  "chains",
  "magnet",
  "gun",
  "bomb",
  "firecracker",
  "hocho",
  "dagger",
  "crossed_swords",
  "shield",
  "smoking",
  "coffin",
  "funeral_urn",
  "amphora",
  "crystal_ball",
  "prayer_beads",
  "nazar_amulet",
  "barber",
  "alembic",
  "telescope",
  "microscope",
  "hole",
  "pill",
  "syringe",
  "dna",
  "microbe",
  "petri_dish",
  "test_tube",
  "thermometer",
  "broom",
  "basket",
  "toilet_paper",
  "label",
  "bookmark",
  "toilet",
  "shower",
  "bathtub",
  "bath",
  "soap",
  "sponge",
  "lotion_bottle",
  "key",
  "old_key",
  "couch_and_lamp",
  "sleeping_bed",
  "bed",
  "door",
  "bellhop_bell",
  "teddy_bear",
  "framed_picture",
  "world_map",
  "parasol_on_ground",
  "moyai",
  "shopping",
  "shopping_cart",
  "balloon",
  "flags",
  "ribbon",
  "gift",
  "confetti_ball",
  "tada",
  "dolls",
  "wind_chime",
  "crossed_flags",
  "izakaya_lantern",
  "red_envelope",
  "email",
  "envelope_with_arrow",
  "incoming_envelope",
  "e-mail",
  "love_letter",
  "postbox",
  "mailbox_closed",
  "mailbox",
  "mailbox_with_mail",
  "mailbox_with_no_mail",
  "package",
  "postal_horn",
  "inbox_tray",
  "outbox_tray",
  "scroll",
  "page_with_curl",
  "bookmark_tabs",
  "receipt",
  "bar_chart",
  "chart_with_upwards_trend",
  "chart_with_downwards_trend",
  "page_facing_up",
  "date",
  "calendar",
  "spiral_calendar",
  "card_index",
  "card_file_box",
  "ballot_box",
  "file_cabinet",
  "clipboard",
  "spiral_notepad",
  "file_folder",
  "open_file_folder",
  "card_index_dividers",
  "newspaper_roll",
  "newspaper",
  "notebook",
  "closed_book",
  "green_book",
  "blue_book",
  "orange_book",
  "notebook_with_decorative_cover",
  "ledger",
  "books",
  "open_book",
  "safety_pin",
  "link",
  "paperclip",
  "paperclips",
  "scissors",
  "triangular_ruler",
  "straight_ruler",
  "abacus",
  "pushpin",
  "round_pushpin",
  "closed_lock_with_key",
  "lock",
  "unlock",
  "lock_with_ink_pen",
  "pen",
  "fountain_pen",
  "black_nib",
  "memo",
  "pencil2",
  "crayon",
  "paintbrush",
  "mag",
  "mag_right",
  "heart",
  "orange_heart",
  "yellow_heart",
  "green_heart",
  "blue_heart",
  "purple_heart",
  "black_heart",
  "broken_heart",
  "heavy_heart_exclamation",
  "two_hearts",
  "revolving_hearts",
  "heartbeat",
  "heartpulse",
  "sparkling_heart",
  "cupid",
  "gift_heart",
  "heart_decoration",
  "peace_symbol",
  "latin_cross",
  "star_and_crescent",
  "om",
  "wheel_of_dharma",
  "star_of_david",
  "six_pointed_star",
  "menorah",
  "yin_yang",
  "orthodox_cross",
  "place_of_worship",
  "ophiuchus",
  "aries",
  "taurus",
  "gemini",
  "cancer",
  "leo",
  "virgo",
  "libra",
  "scorpius",
  "sagittarius",
  "capricorn",
  "aquarius",
  "pisces",
  "id",
  "atom_symbol",
  "u7a7a",
  "u5272",
  "radioactive",
  "biohazard",
  "mobile_phone_off",
  "vibration_mode",
  "u6709",
  "u7121",
  "u7533",
  "u55b6",
  "u6708",
  "eight_pointed_black_star",
  "vs",
  "accept",
  "white_flower",
  "ideograph_advantage",
  "secret",
  "congratulations",
  "u5408",
  "u6e80",
  "u7981",
  "a",
  "b",
  "ab",
  "cl",
  "o2",
  "sos",
  "no_entry",
  "name_badge",
  "no_entry_sign",
  "x",
  "o",
  "stop_sign",
  "anger",
  "hotsprings",
  "no_pedestrians",
  "do_not_litter",
  "no_bicycles",
  "non-potable_water",
  "underage",
  "no_mobile_phones",
  "exclamation",
  "grey_exclamation",
  "question",
  "grey_question",
  "bangbang",
  "interrobang",
  "100",
  "low_brightness",
  "high_brightness",
  "trident",
  "fleur_de_lis",
  "part_alternation_mark",
  "warning",
  "children_crossing",
  "beginner",
  "recycle",
  "u6307",
  "chart",
  "sparkle",
  "eight_spoked_asterisk",
  "negative_squared_cross_mark",
  "white_check_mark",
  "diamond_shape_with_a_dot_inside",
  "cyclone",
  "loop",
  "globe_with_meridians",
  "m",
  "atm",
  "zzz",
  "sa",
  "passport_control",
  "customs",
  "baggage_claim",
  "left_luggage",
  "wheelchair",
  "no_smoking",
  "wc",
  "parking",
  "potable_water",
  "mens",
  "womens",
  "baby_symbol",
  "restroom",
  "put_litter_in_its_place",
  "cinema",
  "signal_strength",
  "koko",
  "ng",
  "ok",
  "up",
  "cool",
  "new",
  "free",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "keycap_ten",
  "asterisk",
  "1234",
  "eject_button",
  "arrow_forward",
  "pause_button",
  "next_track_button",
  "stop_button",
  "record_button",
  "play_or_pause_button",
  "previous_track_button",
  "fast_forward",
  "rewind",
  "twisted_rightwards_arrows",
  "repeat",
  "repeat_one",
  "arrow_backward",
  "arrow_up_small",
  "arrow_down_small",
  "arrow_double_up",
  "arrow_double_down",
  "arrow_right",
  "arrow_left",
  "arrow_up",
  "arrow_down",
  "arrow_upper_right",
  "arrow_lower_right",
  "arrow_lower_left",
  "arrow_upper_left",
  "arrow_up_down",
  "left_right_arrow",
  "arrows_counterclockwise",
  "arrow_right_hook",
  "leftwards_arrow_with_hook",
  "arrow_heading_up",
  "arrow_heading_down",
  "hash",
  "information_source",
  "abc",
  "abcd",
  "capital_abcd",
  "symbols",
  "musical_note",
  "notes",
  "wavy_dash",
  "curly_loop",
  "heavy_check_mark",
  "arrows_clockwise",
  "heavy_plus_sign",
  "heavy_minus_sign",
  "heavy_division_sign",
  "heavy_multiplication_x",
  "infinity",
  "heavy_dollar_sign",
  "currency_exchange",
  "copyright",
  "registered",
  "tm",
  "end",
  "back",
  "on",
  "top",
  "soon",
  "ballot_box_with_check",
  "radio_button",
  "white_circle",
  "black_circle",
  "red_circle",
  "large_blue_circle",
  "small_orange_diamond",
  "small_blue_diamond",
  "large_orange_diamond",
  "large_blue_diamond",
  "small_red_triangle",
  "black_small_square",
  "white_small_square",
  "black_large_square",
  "white_large_square",
  "small_red_triangle_down",
  "black_medium_square",
  "white_medium_square",
  "black_medium_small_square",
  "white_medium_small_square",
  "black_square_button",
  "white_square_button",
  "speaker",
  "sound",
  "loud_sound",
  "mute",
  "mega",
  "loudspeaker",
  "bell",
  "no_bell",
  "black_joker",
  "mahjong",
  "spades",
  "clubs",
  "hearts",
  "diamonds",
  "flower_playing_cards",
  "thought_balloon",
  "right_anger_bubble",
  "speech_balloon",
  "left_speech_bubble",
  "clock1",
  "clock2",
  "clock3",
  "clock4",
  "clock5",
  "clock6",
  "clock7",
  "clock8",
  "clock9",
  "clock10",
  "clock11",
  "clock12",
  "clock130",
  "clock230",
  "clock330",
  "clock430",
  "clock530",
  "clock630",
  "clock730",
  "clock830",
  "clock930",
  "clock1030",
  "clock1130",
  "clock1230",
  "white_flag",
  "black_flag",
  "pirate_flag",
  "checkered_flag",
  "triangular_flag_on_post",
  "rainbow_flag",
  "united_nations",
  "afghanistan",
  "aland_islands",
  "albania",
  "algeria",
  "american_samoa",
  "andorra",
  "angola",
  "anguilla",
  "antarctica",
  "antigua_barbuda",
  "argentina",
  "armenia",
  "aruba",
  "australia",
  "austria",
  "azerbaijan",
  "bahamas",
  "bahrain",
  "bangladesh",
  "barbados",
  "belarus",
  "belgium",
  "belize",
  "benin",
  "bermuda",
  "bhutan",
  "bolivia",
  "caribbean_netherlands",
  "bosnia_herzegovina",
  "botswana",
  "brazil",
  "british_indian_ocean_territory",
  "british_virgin_islands",
  "brunei",
  "bulgaria",
  "burkina_faso",
  "burundi",
  "cape_verde",
  "cambodia",
  "cameroon",
  "canada",
  "canary_islands",
  "cayman_islands",
  "central_african_republic",
  "chad",
  "chile",
  "cn",
  "christmas_island",
  "cocos_islands",
  "colombia",
  "comoros",
  "congo_brazzaville",
  "congo_kinshasa",
  "cook_islands",
  "costa_rica",
  "croatia",
  "cuba",
  "curacao",
  "cyprus",
  "czech_republic",
  "denmark",
  "djibouti",
  "dominica",
  "dominican_republic",
  "ecuador",
  "egypt",
  "el_salvador",
  "equatorial_guinea",
  "eritrea",
  "estonia",
  "ethiopia",
  "eu",
  "falkland_islands",
  "faroe_islands",
  "fiji",
  "finland",
  "fr",
  "french_guiana",
  "french_polynesia",
  "french_southern_territories",
  "gabon",
  "gambia",
  "georgia",
  "de",
  "ghana",
  "gibraltar",
  "greece",
  "greenland",
  "grenada",
  "guadeloupe",
  "guam",
  "guatemala",
  "guernsey",
  "guinea",
  "guinea_bissau",
  "guyana",
  "haiti",
  "honduras",
  "hong_kong",
  "hungary",
  "iceland",
  "india",
  "indonesia",
  "iran",
  "iraq",
  "ireland",
  "isle_of_man",
  "israel",
  "it",
  "cote_divoire",
  "jamaica",
  "jp",
  "jersey",
  "jordan",
  "kazakhstan",
  "kenya",
  "kiribati",
  "kosovo",
  "kuwait",
  "kyrgyzstan",
  "laos",
  "latvia",
  "lebanon",
  "lesotho",
  "liberia",
  "libya",
  "liechtenstein",
  "lithuania",
  "luxembourg",
  "macau",
  "macedonia",
  "madagascar",
  "malawi",
  "malaysia",
  "maldives",
  "mali",
  "malta",
  "marshall_islands",
  "martinique",
  "mauritania",
  "mauritius",
  "mayotte",
  "mexico",
  "micronesia",
  "moldova",
  "monaco",
  "mongolia",
  "montenegro",
  "montserrat",
  "morocco",
  "mozambique",
  "myanmar",
  "namibia",
  "nauru",
  "nepal",
  "netherlands",
  "new_caledonia",
  "new_zealand",
  "nicaragua",
  "niger",
  "nigeria",
  "niue",
  "norfolk_island",
  "northern_mariana_islands",
  "north_korea",
  "norway",
  "oman",
  "pakistan",
  "palau",
  "palestinian_territories",
  "panama",
  "papua_new_guinea",
  "paraguay",
  "peru",
  "philippines",
  "pitcairn_islands",
  "poland",
  "portugal",
  "puerto_rico",
  "qatar",
  "reunion",
  "romania",
  "ru",
  "rwanda",
  "st_barthelemy",
  "st_helena",
  "st_kitts_nevis",
  "st_lucia",
  "st_pierre_miquelon",
  "st_vincent_grenadines",
  "samoa",
  "san_marino",
  "sao_tome_principe",
  "saudi_arabia",
  "senegal",
  "serbia",
  "seychelles",
  "sierra_leone",
  "singapore",
  "sint_maarten",
  "slovakia",
  "slovenia",
  "solomon_islands",
  "somalia",
  "south_africa",
  "south_georgia_south_sandwich_islands",
  "kr",
  "south_sudan",
  "es",
  "sri_lanka",
  "sudan",
  "suriname",
  "swaziland",
  "sweden",
  "switzerland",
  "syria",
  "taiwan",
  "tajikistan",
  "tanzania",
  "thailand",
  "timor_leste",
  "togo",
  "tokelau",
  "tonga",
  "trinidad_tobago",
  "tunisia",
  "tr",
  "turkmenistan",
  "turks_caicos_islands",
  "tuvalu",
  "uganda",
  "ukraine",
  "united_arab_emirates",
  "uk",
  "england",
  "scotland",
  "wales",
  "us",
  "us_virgin_islands",
  "uruguay",
  "uzbekistan",
  "vanuatu",
  "vatican_city",
  "venezuela",
  "vietnam",
  "wallis_futuna",
  "western_sahara",
  "yemen",
  "zambia",
  "zimbabwe"
];
var emojilib = {
  lib: require$$0,
  ordered: require$$1,
  fitzpatrick_scale_modifiers: ["🏻", "🏼", "🏽", "🏾", "🏿"]
};
const emojilib$1 = /* @__PURE__ */ getDefaultExportFromCjs(emojilib);
var charRegex = () => {
  const astralRange = "\\ud800-\\udfff";
  const comboMarksRange = "\\u0300-\\u036f";
  const comboHalfMarksRange = "\\ufe20-\\ufe2f";
  const comboSymbolsRange = "\\u20d0-\\u20ff";
  const comboMarksExtendedRange = "\\u1ab0-\\u1aff";
  const comboMarksSupplementRange = "\\u1dc0-\\u1dff";
  const comboRange = comboMarksRange + comboHalfMarksRange + comboSymbolsRange + comboMarksExtendedRange + comboMarksSupplementRange;
  const varRange = "\\ufe0e\\ufe0f";
  const familyRange = "\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83C\\uDF93";
  const astral = `[${astralRange}]`;
  const combo = `[${comboRange}]`;
  const fitz = "\\ud83c[\\udffb-\\udfff]";
  const modifier = `(?:${combo}|${fitz})`;
  const nonAstral = `[^${astralRange}]`;
  const regional = "(?:\\uD83C[\\uDDE6-\\uDDFF]){2}";
  const surrogatePair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  const zwj = "\\u200d";
  const blackFlag = "(?:\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40(?:\\udc65|\\udc73|\\udc77)\\udb40(?:\\udc6e|\\udc63|\\udc6c)\\udb40(?:\\udc67|\\udc74|\\udc73)\\udb40\\udc7f)";
  const family = `[${familyRange}]`;
  const optModifier = `${modifier}?`;
  const optVar = `[${varRange}]?`;
  const optJoin = `(?:${zwj}(?:${[nonAstral, regional, surrogatePair].join("|")})${optVar + optModifier})*`;
  const seq = optVar + optModifier + optJoin;
  const nonAstralCombo = `${nonAstral}${combo}?`;
  const symbol = `(?:${[nonAstralCombo, combo, regional, surrogatePair, astral, family].join("|")})`;
  return new RegExp(`${blackFlag}|${fitz}(?=${fitz})|${symbol + seq}`, "g");
};
const charRegex$1 = /* @__PURE__ */ getDefaultExportFromCjs(charRegex);
charRegex$1();
var NON_SPACING_MARK = String.fromCharCode(65039);
var nonSpacingRegex = new RegExp(NON_SPACING_MARK, "g");
function normalizeCode(code2) {
  return code2.replace(nonSpacingRegex, "");
}
function normalizeName(name2) {
  return /:.+:/.test(name2) ? name2.slice(1, -1) : name2;
}
var emojiData = Object.entries(emojilib$1.lib).map(
  ([name2, { char: emoji }]) => [name2, emoji]
);
var emojiCodesByName = new Map(emojiData);
new Map(
  emojiData.map(([name2, emoji]) => [normalizeCode(emoji), name2])
);
var get = (codeOrName) => {
  distExports.assert.string(codeOrName);
  return emojiCodesByName.get(normalizeName(codeOrName));
};
const emoticon = [
  {
    name: "angry",
    emoji: "😠",
    tags: ["mad", "annoyed"],
    description: "angry face",
    emoticons: [">:(", ">:[", ">:-(", ">:-[", ">=(", ">=[", ">=-(", ">=-["]
  },
  {
    name: "blush",
    emoji: "😊",
    tags: ["proud"],
    description: "smiling face with smiling eyes",
    emoticons: [
      ':")',
      ':"]',
      ':"D',
      ':-")',
      ':-"]',
      ':-"D',
      '=")',
      '="]',
      '="D',
      '=-")',
      '=-"]',
      '=-"D'
    ]
  },
  {
    name: "broken_heart",
    emoji: "💔",
    tags: [],
    description: "broken heart",
    emoticons: ["<\\3", "</3"]
  },
  {
    name: "confused",
    emoji: "😕",
    tags: [],
    description: "confused face",
    emoticons: [":/", ":\\", ":-/", ":-\\", "=/", "=\\", "=-/", "=-\\"]
  },
  {
    name: "cry",
    emoji: "😢",
    tags: ["sad", "tear"],
    description: "crying face",
    emoticons: [
      ":,(",
      ":,[",
      ":,|",
      ":,-(",
      ":,-[",
      ":,-|",
      ":'(",
      ":'[",
      ":'|",
      ":'-(",
      ":'-[",
      ":'-|",
      "=,(",
      "=,[",
      "=,|",
      "=,-(",
      "=,-[",
      "=,-|",
      "='(",
      "='[",
      "='|",
      "='-(",
      "='-[",
      "='-|"
    ]
  },
  {
    name: "frowning",
    emoji: "😦",
    tags: [],
    description: "frowning face with open mouth",
    emoticons: [":(", ":[", ":-(", ":-[", "=(", "=[", "=-(", "=-["]
  },
  {
    name: "heart",
    emoji: "❤️",
    tags: ["love"],
    description: "red heart",
    emoticons: ["<3"]
  },
  {
    name: "imp",
    emoji: "👿",
    tags: ["angry", "devil", "evil", "horns"],
    description: "angry face with horns",
    emoticons: ["]:(", "]:[", "]:-(", "]:-[", "]=(", "]=[", "]=-(", "]=-["]
  },
  {
    name: "innocent",
    emoji: "😇",
    tags: ["angel"],
    description: "smiling face with halo",
    emoticons: [
      "o:)",
      "o:]",
      "o:D",
      "o:-)",
      "o:-]",
      "o:-D",
      "o=)",
      "o=]",
      "o=D",
      "o=-)",
      "o=-]",
      "o=-D",
      "O:)",
      "O:]",
      "O:D",
      "O:-)",
      "O:-]",
      "O:-D",
      "O=)",
      "O=]",
      "O=D",
      "O=-)",
      "O=-]",
      "O=-D",
      "0:)",
      "0:]",
      "0:D",
      "0:-)",
      "0:-]",
      "0:-D",
      "0=)",
      "0=]",
      "0=D",
      "0=-)",
      "0=-]",
      "0=-D"
    ]
  },
  {
    name: "joy",
    emoji: "😂",
    tags: ["tears"],
    description: "face with tears of joy",
    emoticons: [
      ":,)",
      ":,]",
      ":,D",
      ":,-)",
      ":,-]",
      ":,-D",
      ":')",
      ":']",
      ":'D",
      ":'-)",
      ":'-]",
      ":'-D",
      "=,)",
      "=,]",
      "=,D",
      "=,-)",
      "=,-]",
      "=,-D",
      "=')",
      "=']",
      "='D",
      "='-)",
      "='-]",
      "='-D"
    ]
  },
  {
    name: "kissing",
    emoji: "😗",
    tags: [],
    description: "kissing face",
    emoticons: [":*", ":-*", "=*", "=-*"]
  },
  {
    name: "laughing",
    emoji: "😆",
    tags: ["happy", "haha"],
    description: "grinning squinting face",
    emoticons: [
      "x)",
      "x]",
      "xD",
      "x-)",
      "x-]",
      "x-D",
      "X)",
      "X]",
      "X-)",
      "X-]",
      "X-D"
    ]
  },
  {
    name: "man",
    emoji: "👨",
    tags: ["mustache", "father", "dad"],
    description: "man",
    emoticons: [":3", ":-3", "=3", "=-3", ";3", ";-3", "x3", "x-3", "X3", "X-3"]
  },
  {
    name: "neutral_face",
    emoji: "😐",
    tags: ["meh"],
    description: "neutral face",
    emoticons: [":|", ":-|", "=|", "=-|"]
  },
  {
    name: "no_mouth",
    emoji: "😶",
    tags: ["mute", "silence"],
    description: "face without mouth",
    emoticons: [":-"]
  },
  {
    name: "open_mouth",
    emoji: "😮",
    tags: ["surprise", "impressed", "wow"],
    description: "face with open mouth",
    emoticons: [
      ":o",
      ":O",
      ":0",
      ":-o",
      ":-O",
      ":-0",
      "=o",
      "=O",
      "=0",
      "=-o",
      "=-O",
      "=-0"
    ]
  },
  {
    name: "rage",
    emoji: "😡",
    tags: ["angry"],
    description: "pouting face",
    emoticons: [":@", ":-@", "=@", "=-@"]
  },
  {
    name: "smile",
    emoji: "😄",
    tags: ["happy", "joy", "laugh", "pleased"],
    description: "grinning face with smiling eyes",
    emoticons: [":D", ":-D", "=D", "=-D"]
  },
  {
    name: "smiley",
    emoji: "😃",
    tags: ["happy", "joy", "haha"],
    description: "grinning face with big eyes",
    emoticons: [":)", ":]", ":-)", ":-]", "=)", "=]", "=-)", "=-]"]
  },
  {
    name: "smiling_imp",
    emoji: "😈",
    tags: ["devil", "evil", "horns"],
    description: "smiling face with horns",
    emoticons: [
      "]:)",
      "]:]",
      "]:D",
      "]:-)",
      "]:-]",
      "]:-D",
      "]=)",
      "]=]",
      "]=D",
      "]=-)",
      "]=-]",
      "]=-D"
    ]
  },
  {
    name: "sob",
    emoji: "😭",
    tags: ["sad", "cry", "bawling"],
    description: "loudly crying face",
    emoticons: [
      ":,'(",
      ":,'[",
      ":,'-(",
      ":,'-[",
      ":',(",
      ":',[",
      ":',-(",
      ":',-[",
      "=,'(",
      "=,'[",
      "=,'-(",
      "=,'-[",
      "=',(",
      "=',[",
      "=',-(",
      "=',-["
    ]
  },
  {
    name: "stuck_out_tongue",
    emoji: "😛",
    tags: [],
    description: "face with tongue",
    emoticons: [
      ":p",
      ":P",
      ":d",
      ":-p",
      ":-P",
      ":-d",
      "=p",
      "=P",
      "=d",
      "=-p",
      "=-P",
      "=-d"
    ]
  },
  {
    name: "stuck_out_tongue_closed_eyes",
    emoji: "😝",
    tags: ["prank"],
    description: "squinting face with tongue",
    emoticons: ["xP", "x-p", "x-P", "x-d", "Xp", "Xd", "X-p", "X-P", "X-d"]
  },
  {
    name: "stuck_out_tongue_winking_eye",
    emoji: "😜",
    tags: ["prank", "silly"],
    description: "winking face with tongue",
    emoticons: [";p", ";P", ";d", ";-p", ";-P", ";-d"]
  },
  {
    name: "sunglasses",
    emoji: "😎",
    tags: ["cool"],
    description: "smiling face with sunglasses",
    emoticons: [
      "8)",
      "8]",
      "8D",
      "8-)",
      "8-]",
      "8-D",
      "B)",
      "B]",
      "B-)",
      "B-]",
      "B-D"
    ]
  },
  {
    name: "sweat",
    emoji: "😓",
    tags: [],
    description: "downcast face with sweat",
    emoticons: [
      ",:(",
      ",:[",
      ",:-(",
      ",:-[",
      ",=(",
      ",=[",
      ",=-(",
      ",=-[",
      "':(",
      "':[",
      "':-(",
      "':-[",
      "'=(",
      "'=[",
      "'=-(",
      "'=-["
    ]
  },
  {
    name: "sweat_smile",
    emoji: "😅",
    tags: ["hot"],
    description: "grinning face with sweat",
    emoticons: [
      ",:)",
      ",:]",
      ",:D",
      ",:-)",
      ",:-]",
      ",:-D",
      ",=)",
      ",=]",
      ",=D",
      ",=-)",
      ",=-]",
      ",=-D",
      "':)",
      "':]",
      "':D",
      "':-)",
      "':-]",
      "':-D",
      "'=)",
      "'=]",
      "'=D",
      "'=-)",
      "'=-]",
      "'=-D"
    ]
  },
  {
    name: "unamused",
    emoji: "😒",
    tags: ["meh"],
    description: "unamused face",
    emoticons: [
      ":$",
      ":s",
      ":z",
      ":S",
      ":Z",
      ":-$",
      ":-s",
      ":-z",
      ":-S",
      ":-Z",
      "=$",
      "=s",
      "=z",
      "=S",
      "=Z",
      "=-$",
      "=-s",
      "=-z",
      "=-S",
      "=-Z"
    ]
  },
  {
    name: "wink",
    emoji: "😉",
    tags: ["flirt"],
    description: "winking face",
    emoticons: [";)", ";]", ";D", ";-)", ";-]", ";-D"]
  }
];
const RE_EMOJI = /:\+1:|:-1:|:[\w-]+:/g;
const RE_SHORT = /[$@|*'",;.=:\-)([\]\\/<>038BOopPsSdDxXzZ]{2,5}/g;
const RE_PUNCT = /(?:_|-(?!1))/g;
const DEFAULT_SETTINGS = {
  padSpaceAfter: false,
  emoticon: false,
  accessible: false
};
function plugin(options) {
  const settings = Object.assign({}, DEFAULT_SETTINGS, options);
  const pad = !!settings.padSpaceAfter;
  const emoticonEnable = !!settings.emoticon;
  const accessible = !!settings.accessible;
  function aria2(text2, label2) {
    return {
      type: "text",
      meta: null,
      value: text2,
      data: {
        hName: "span",
        hProperties: {
          role: "img",
          ariaLabel: label2
        },
        hChildren: [{ type: "text", value: text2 }]
      }
    };
  }
  function replaceEmoticon(match2) {
    const iconFull = emoticon.find((e2) => e2.emoticons.includes(match2));
    const iconPart = emoticon.find((e2) => e2.emoticons.includes(match2.slice(0, -1)));
    const icon = iconFull || iconPart;
    if (!icon) {
      return false;
    }
    const trimmedChar = !iconFull && iconPart ? match2.slice(-1) : "";
    const addPad = pad ? " " : "";
    const replaced = icon.emoji + addPad + trimmedChar;
    if (accessible) {
      return aria2(replaced, icon.name + " emoticon");
    }
    return replaced;
  }
  function replaceEmoji(match2) {
    let got = get(match2);
    if (typeof got === "undefined") {
      return false;
    }
    if (pad) {
      got = got + " ";
    }
    if (accessible) {
      const label2 = match2.slice(1, -1).replace(RE_PUNCT, " ") + " emoji";
      return aria2(got, label2);
    }
    return got;
  }
  const replacers = [[RE_EMOJI, replaceEmoji]];
  if (emoticonEnable) {
    replacers.push([RE_SHORT, replaceEmoticon]);
  }
  function transformer(tree) {
    findAndReplace(tree, replacers);
  }
  return transformer;
}
const Spinner = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Box$1,
    {
      sx: {
        display: "flex",
        width: "100%",
        height: "100%",
        justifyContent: "center",
        alignItems: "center"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CircularProgress, {})
    }
  );
};
function stringify$1(values2, options) {
  const settings = options || {};
  const input = values2[values2.length - 1] === "" ? [...values2, ""] : values2;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const emptyOptions$1 = {};
function name(name2, options) {
  const settings = options || emptyOptions$1;
  const re2 = settings.jsx ? nameReJsx : nameRe;
  return re2.test(name2);
}
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema(property, normal, space2);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask2, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask2 === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask2 & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values2, key2, value) {
  if (value) {
    values2[key2] = value;
  }
}
const own$4 = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$4.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize$1(prop)] = prop;
      normal[normalize$1(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}
const xlink = create({
  space: "xlink",
  transform(_2, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_2, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_2, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
const html$2 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap$1 = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap$1, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
const html$1 = merge([xml, xlink, xmlns, aria, html$2], "html");
const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function stringify(values2) {
  return values2.join(" ").trim();
}
var cjs = {};
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;
var TRIM_REGEX = /^\s+|\s+$/g;
var NEWLINE = "\n";
var FORWARD_SLASH = "/";
var ASTERISK = "*";
var EMPTY_STRING = "";
var TYPE_COMMENT = "comment";
var TYPE_DECLARATION = "declaration";
var inlineStyleParser = function(style2, options) {
  if (typeof style2 !== "string") {
    throw new TypeError("First argument must be a string");
  }
  if (!style2)
    return [];
  options = options || {};
  var lineno = 1;
  var column2 = 1;
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines)
      lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column2 = ~i ? str.length - i : column2 + str.length;
  }
  function position2() {
    var start = { line: lineno, column: column2 };
    return function(node2) {
      node2.position = new Position(start);
      whitespace2();
      return node2;
    };
  }
  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column2 };
    this.source = options.source;
  }
  Position.prototype.content = style2;
  function error(msg) {
    var err = new Error(
      options.source + ":" + lineno + ":" + column2 + ": " + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column2;
    err.source = style2;
    if (options.silent)
      ;
    else {
      throw err;
    }
  }
  function match2(re2) {
    var m2 = re2.exec(style2);
    if (!m2)
      return;
    var str = m2[0];
    updatePosition(str);
    style2 = style2.slice(str.length);
    return m2;
  }
  function whitespace2() {
    match2(WHITESPACE_REGEX);
  }
  function comments(rules) {
    var c2;
    rules = rules || [];
    while (c2 = comment2()) {
      if (c2 !== false) {
        rules.push(c2);
      }
    }
    return rules;
  }
  function comment2() {
    var pos = position2();
    if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
      return;
    var i = 2;
    while (EMPTY_STRING != style2.charAt(i) && (ASTERISK != style2.charAt(i) || FORWARD_SLASH != style2.charAt(i + 1))) {
      ++i;
    }
    i += 2;
    if (EMPTY_STRING === style2.charAt(i - 1)) {
      return error("End of comment missing");
    }
    var str = style2.slice(2, i - 2);
    column2 += 2;
    updatePosition(str);
    style2 = style2.slice(i);
    column2 += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }
  function declaration2() {
    var pos = position2();
    var prop = match2(PROPERTY_REGEX);
    if (!prop)
      return;
    comment2();
    if (!match2(COLON_REGEX))
      return error("property missing ':'");
    var val = match2(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });
    match2(SEMICOLON_REGEX);
    return ret;
  }
  function declarations() {
    var decls = [];
    comments(decls);
    var decl;
    while (decl = declaration2()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace2();
  return declarations();
};
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cjs, "__esModule", { value: true });
var inline_style_parser_1 = __importDefault(inlineStyleParser);
function StyleToObject(style2, iterator) {
  var styleObject = null;
  if (!style2 || typeof style2 !== "string") {
    return styleObject;
  }
  var declarations = (0, inline_style_parser_1.default)(style2);
  var hasIterator = typeof iterator === "function";
  declarations.forEach(function(declaration2) {
    if (declaration2.type !== "declaration") {
      return;
    }
    var property = declaration2.property, value = declaration2.value;
    if (hasIterator) {
      iterator(property, value, declaration2);
    } else if (value) {
      styleObject = styleObject || {};
      styleObject[property] = value;
    }
  });
  return styleObject;
}
var _default = cjs.default = StyleToObject;
const styleToObject = _default.default || _default;
const pointEnd = point$2("end");
const pointStart = point$2("start");
function point$2(type) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type] || {};
    if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
      return {
        line: point3.line,
        column: point3.column,
        offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
      };
    }
  }
}
function position$1(node2) {
  const start = pointStart(node2);
  const end2 = pointEnd(node2);
  if (start && end2) {
    return { start, end: end2 };
  }
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point$1(value);
  }
  return "";
}
function point$1(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const own$3 = {}.hasOwnProperty;
const emptyMap = /* @__PURE__ */ new Map();
const cap = /[A-Z]/g;
const dashSomething = /-([a-z])/g;
const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create2;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create2 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create2 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create2,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg : html$1,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one(state, node2, key2) {
  if (node2.type === "element") {
    return element(state, node2, key2);
  }
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
    return mdxExpression(state, node2);
  }
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
    return mdxJsxElement(state, node2, key2);
  }
  if (node2.type === "mdxjsEsm") {
    return mdxEsm(state, node2);
  }
  if (node2.type === "root") {
    return root$1(state, node2, key2);
  }
  if (node2.type === "text") {
    return text$3(state, node2);
  }
}
function element(state, node2, key2) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    schema = svg;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = findComponentFromName(state, node2.tagName, false);
  const props = createElementProps(state, node2);
  let children = createChildren(state, node2);
  if (tableElements.has(node2.tagName)) {
    children = children.filter(function(child2) {
      return typeof child2 === "string" ? !whitespace(child2) : true;
    });
  }
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key2);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const program = node2.data.estree;
    const expression = program.body[0];
    ok$4(expression.type === "ExpressionStatement");
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateExpression(expression.expression)
    );
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  }
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key2) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.name === "svg" && parentSchema.space === "html") {
    schema = svg;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
  const props = createJsxElementProps(state, node2);
  const children = createChildren(state, node2);
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key2);
}
function root$1(state, node2, key2) {
  const props = {};
  addChildren(props, createChildren(state, node2));
  return state.create(node2, state.Fragment, props, key2);
}
function text$3(_2, node2) {
  return node2.value;
}
function addNode(state, props, type, node2) {
  if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
    props.node = node2;
  }
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    if (value) {
      props.children = value;
    }
  }
}
function productionCreate(_2, jsx, jsxs) {
  return create2;
  function create2(_3, type, props, key2) {
    const isStaticChildren = Array.isArray(props.children);
    const fn = isStaticChildren ? jsxs : jsx;
    return key2 ? fn(type, props, key2) : fn(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create2;
  function create2(node2, type, props, key2) {
    const isStaticChildren = Array.isArray(props.children);
    const point2 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key2,
      isStaticChildren,
      {
        columnNumber: point2 ? point2.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point2 ? point2.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue;
  let prop;
  for (prop in node2.properties) {
    if (prop !== "children" && own$3.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key2, value] = result;
        if (state.tableCellAlignToStyle && key2 === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
          alignValue = value;
        } else {
          props[key2] = value;
        }
      }
    }
  }
  if (alignValue) {
    const style2 = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "mdxJsxExpressionAttribute") {
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const program = attribute.data.estree;
        const expression = program.body[0];
        ok$4(expression.type === "ExpressionStatement");
        const objectExpression = expression.expression;
        ok$4(objectExpression.type === "ObjectExpression");
        const property = objectExpression.properties[0];
        ok$4(property.type === "SpreadElement");
        Object.assign(
          props,
          state.evaluater.evaluateExpression(property.argument)
        );
      } else {
        crashEstree(state, node2.position);
      }
    } else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value === "object") {
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const program = attribute.value.data.estree;
          const expression = program.body[0];
          ok$4(expression.type === "ExpressionStatement");
          value = state.evaluater.evaluateExpression(expression.expression);
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        value = attribute.value === null ? true : attribute.value;
      }
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  }
  return props;
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index2 < node2.children.length) {
    const child2 = node2.children[index2];
    let key2;
    if (state.passKeys) {
      const name2 = child2.type === "element" ? child2.tagName : child2.type === "mdxJsxFlowElement" || child2.type === "mdxJsxTextElement" ? child2.name : void 0;
      if (name2) {
        const count = countsByName.get(name2) || 0;
        key2 = name2 + "-" + count;
        countsByName.set(name2, count + 1);
      }
    }
    const result = one(state, child2, key2);
    if (result !== void 0)
      children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify$1(value) : stringify(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, value) {
  const result = {};
  try {
    styleToObject(value, replacer);
  } catch (error) {
    if (!state.ignoreInvalidStyle) {
      const cause = (
        /** @type {Error} */
        error
      );
      const message = new VFileMessage("Cannot parse `style` attribute", {
        ancestors: state.ancestors,
        cause,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      message.file = state.filePath || void 0;
      message.url = docs + "#cannot-parse-style-attribute";
      throw message;
    }
  }
  return result;
  function replacer(name2, value2) {
    let key2 = name2;
    if (key2.slice(0, 2) !== "--") {
      if (key2.slice(0, 4) === "-ms-")
        key2 = "ms-" + key2.slice(4);
      key2 = key2.replace(dashSomething, toCamel);
    }
    result[key2] = value2;
  }
}
function findComponentFromName(state, name$1, allowExpression) {
  let result;
  if (!allowExpression) {
    result = { type: "Literal", value: name$1 };
  } else if (name$1.includes(".")) {
    const identifiers = name$1.split(".");
    let index2 = -1;
    let node2;
    while (++index2 < identifiers.length) {
      const prop = name(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: Boolean(index2 && prop.type === "Literal"),
        optional: false
      } : prop;
    }
    result = node2;
  } else {
    result = name(name$1) && !/^[a-z]/.test(name$1) ? { type: "Identifier", name: name$1 } : { type: "Literal", value: name$1 };
  }
  if (result.type === "Literal") {
    const name2 = (
      /** @type {keyof JSX.IntrinsicElements} */
      result.value
    );
    return own$3.call(state.components, name2) ? state.components[name2] : name2;
  }
  if (state.evaluater) {
    return state.evaluater.evaluateExpression(result);
  }
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  message.file = state.filePath || void 0;
  message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
  throw message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from2;
  for (from2 in domCasing) {
    if (own$3.call(domCasing, from2)) {
      cssCasing[transformStyleToCssCasing(from2)] = domCasing[from2];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from2) {
  let to = from2.replace(cap, toDash);
  if (to.slice(0, 3) === "ms-")
    to = "-" + to;
  return to;
}
function toCamel(_2, $1) {
  return $1.toUpperCase();
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}
const urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
const content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token2 = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token2;
    }
    previous2 = token2;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token2, eof) {
    const stream = self2.sliceStream(token2);
    if (eof)
      stream.push(null);
    token2.previous = childToken;
    if (childToken)
      childToken.next = token2;
    childToken = token2;
    childFlow.defineSkip(token2.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token2.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index2][1].end || // …or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content$1, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory("string");
const text$2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1)
          ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token2 = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token2.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token2);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token2, context],
            ["exit", token2, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
function createTokenizer(parser, initialize, from2) {
  let point2 = Object.assign(
    from2 ? Object.assign({}, from2) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token2, expandTabs) {
    return serializeChunks(sliceStream(token2), expandTabs);
  }
  function sliceStream(token2) {
    return sliceChunks(chunks, token2);
  }
  function now() {
    const { line: line2, column: column2, offset, _index, _bufferIndex } = point2;
    return {
      line: line2,
      column: column2,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
  }
  function enter(type, fields) {
    const token2 = fields || {};
    token2.type = type;
    token2.start = now();
    context.events.push(["enter", token2, context]);
    stack.push(token2);
    return token2;
  }
  function exit2(type) {
    const token2 = stack.pop();
    token2.end = now();
    context.events.push(["exit", token2, context]);
    return token2;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_2, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start;
        function start(code2) {
          const def = code2 !== null && map2[code2];
          const all2 = code2 !== null && map2.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok();
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from3) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from3,
        context.events.length - from3,
        construct.resolve(context.events.slice(from3), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token2) {
  const startIndex = token2.start._index;
  const startBufferIndex = token2.start._bufferIndex;
  const endIndex = token2.end._index;
  const endBufferIndex = token2.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab)
            continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};
const string = {
  [38]: characterReference,
  [92]: characterEscape
};
const text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$1
}, Symbol.toStringTag, { value: "Module" }));
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document$2),
    flow: create2(flow$1),
    string: create2(string$1),
    text: create2(text$2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from2) {
      return createTokenizer(parser, initial, from2);
    }
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column2 = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end2) {
    const chunks = [];
    let match2;
    let next2;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match2 = search.exec(value);
      endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match2) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column2 += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column2++;
            break;
          }
          case 9: {
            next2 = Math.ceil(column2 / 4) * 4;
            chunks.push(-2);
            while (column2++ < next2)
              chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column2 = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column2 = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end2) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer)
        chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}
const own$2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config2 = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config2, (options || {}).mdastExtensions || []);
  const data = {};
  return compile2;
  function compile2(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config: config2,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config2[events[index2][0]];
      if (own$2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index2][2].sliceSerialize
            },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index2 = -1;
    while (++index2 < config2.transforms.length) {
      tree = config2.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length2) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length2) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
              ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length2++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length2++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length2;
  }
  function opener(create2, and) {
    return open;
    function open(token2) {
      enter.call(this, create2(token2), token2);
      if (and)
        and.call(this, token2);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token2, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token2, errorHandler]);
    node2.position = {
      start: point(token2.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token2) {
      if (and)
        and.call(this, token2);
      exit2.call(this, token2);
    }
  }
  function exit2(token2, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token2.type + "` (" + stringifyPosition({
          start: token2.start,
          end: token2.end
        }) + "): it’s not open"
      );
    } else if (open[0].type !== token2.type) {
      if (onExitError) {
        onExitError.call(this, token2, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token2, open[0]);
      }
    }
    node2.position.end = point(token2.end);
  }
  function resume() {
    return toString$2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token2) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token2), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token2) {
    const label2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label2;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token2).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token2) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token2).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token2) {
    const node2 = this.stack[this.stack.length - 1];
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point(token2.start),
        // @ts-expect-error: we’ll add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token2) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token2);
    tail.position.end = point(token2.end);
  }
  function onexitlineending(token2) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token2.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config2.canContainEols.includes(context.type)) {
      onenterdata.call(this, token2);
      onexitdata.call(this, token2);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token2) {
    const string2 = this.sliceSerialize(token2);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token2) {
    const label2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label2;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token2)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token2) {
    this.data.characterReferenceType = token2.type;
  }
  function onexitcharacterreferencevalue(token2) {
    const data2 = this.sliceSerialize(token2);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point(token2.end);
  }
  function onexitautolinkprotocol(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token2);
  }
  function onexitautolinkemail(token2) {
    onexitdata.call(this, token2);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token2);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token2) {
    return {
      type: "list",
      ordered: token2.type === "listOrdered",
      start: null,
      spread: token2._spread,
      children: []
    };
  }
  function listItem2(token2) {
    return {
      type: "listItem",
      spread: token2._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point(d2) {
  return {
    line: d2.line,
    column: d2.column,
    offset: d2.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key2;
  for (key2 in extension2) {
    if (own$2.call(extension2, key2)) {
      switch (key2) {
        case "canContainEols": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key2];
          if (right) {
            combined[key2].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key2];
          if (right) {
            Object.assign(combined[key2], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties2 = {};
  if (node2.lang) {
    properties2.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties: properties2,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id2);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id2);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id2);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id2, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function html(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
function imageReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const def = state.definitionById.get(id2);
  if (!def) {
    return revert(state, node2);
  }
  const properties2 = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties2.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties: properties2, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function image(state, node2) {
  const properties2 = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties2.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties2.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties: properties2, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function inlineCode(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function linkReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const def = state.definitionById.get(id2);
  if (!def) {
    return revert(state, node2);
  }
  const properties2 = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties2.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties: properties2,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function link(state, node2) {
  const properties2 = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties2.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties: properties2,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties2 = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties2.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child2 = results[index2];
    if (loose || index2 !== 0 || child2.type !== "element" || child2.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child2.type === "element" && child2.tagName === "p" && !loose) {
      children.push(...child2.children);
    } else {
      children.push(child2);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties: properties2, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}
function list(state, node2) {
  const properties2 = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties2.start = node2.start;
  }
  while (++index2 < results.length) {
    const child2 = results[index2];
    if (child2.type === "element" && child2.tagName === "li" && child2.properties && Array.isArray(child2.properties.className) && child2.properties.className.includes("task-list-item")) {
      properties2.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties: properties2,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body2 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end2 = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end2)
      body2.position = { start, end: end2 };
    tableContent.push(body2);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length2 = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length2) {
    const cell = node2.children[cellIndex];
    const properties2 = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties2.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties: properties2, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match2 = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match2) {
    lines.push(
      trimLine(source.slice(last, match2.index), last > 0, true),
      match2[0]
    );
    last = match2.index + match2[0].length;
    match2 = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end2) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end2) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function thematicBreak(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}
const VOID = -1;
const PRIMITIVE = 0;
const ARRAY = 1;
const OBJECT = 2;
const DATE = 3;
const REGEXP = 4;
const MAP = 5;
const SET = 6;
const ERROR = 7;
const BIGINT = 8;
const env = typeof self === "object" ? self : globalThis;
const deserializer = ($, _2) => {
  const as = (out, index2) => {
    $.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($.has(index2))
      return $.get(index2);
    const [type, value] = _2[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key2, index3] of value)
          object[unpair(key2)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source, flags: flags2 } = value;
        return as(new RegExp(source, flags2), index2);
      }
      case MAP: {
        const map2 = as(/* @__PURE__ */ new Map(), index2);
        for (const [key2, index3] of value)
          map2.set(unpair(key2), unpair(index3));
        return map2;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as(new env[name2](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
    }
    return as(new env[type](value), index2);
  };
  return unpair;
};
const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
const EMPTY = "";
const { toString } = {};
const { keys } = Object;
const typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
const serializer = (strict, json, $, _2) => {
  const as = (out, value) => {
    const index2 = _2.push(out) - 1;
    $.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type)
          return as([type, [...value]], value);
        const arr = [];
        const index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const key2 of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key2])))
            entries.push([pair(key2), pair(value[key2])]);
        }
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags: flags2 } = value;
        return as([TYPE, { source, flags: flags2 }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const [key2, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key2), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
const serialize = (value, { json, lossy } = {}) => {
  const _2 = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _2)(value), _2;
};
const structuredClone$1 = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));
function defaultFootnoteBackContent(_2, rereferenceIndex) {
  const result = [{ type: "text", value: "↩" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
    if (!def) {
      continue;
    }
    const content2 = state.all(def);
    const id2 = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id2);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...structuredClone$1(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
const own$1 = {}.hasOwnProperty;
const emptyOptions = {};
function createState(tree, options) {
  const settings = options || emptyOptions;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers$1 = { ...handlers, ...settings.handlers };
  const state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers$1,
    one: one2,
    options: settings,
    patch,
    wrap: wrap$1
  };
  visit$2(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map2 = node2.type === "definition" ? definitionById : footnoteById;
      const id2 = String(node2.identifier).toUpperCase();
      if (!map2.has(id2)) {
        map2.set(id2, node2);
      }
    }
  });
  return state;
  function one2(node2, parent) {
    const type = node2.type;
    const handle2 = state.handlers[type];
    if (own$1.call(state.handlers, type) && handle2) {
      return handle2(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = structuredClone$1(shallow);
        result.children = state.all(node2);
        return result;
      }
      return structuredClone$1(node2);
    }
    const unknown = state.options.unknownHandler || defaultUnknownHandler;
    return unknown(state, node2, parent);
  }
  function all2(parent) {
    const values2 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values2.push(...result);
          } else {
            values2.push(result);
          }
        }
      }
    }
    return values2;
  }
}
function patch(from2, to) {
  if (from2.position)
    to.position = position$1(from2);
}
function applyData(from2, to) {
  let result = to;
  if (from2 && from2.data) {
    const hName = from2.data.hName;
    const hChildren = from2.data.hChildren;
    const hProperties = from2.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, structuredClone$1(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own$1.call(data, "hProperties") || own$1.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap$1(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2)
      result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code2 = value.charCodeAt(index2);
  while (code2 === 9 || code2 === 32) {
    index2++;
    code2 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot2 = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot2) {
    result.children.push({ type: "text", value: "\n" }, foot2);
  }
  return result;
}
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...options || destination })
    );
  };
}
function bail(error) {
  if (error) {
    throw error;
  }
}
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next2(null, ...values2);
    function next2(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values2.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values2[index2];
        }
      }
      values2 = output;
      if (fn) {
        wrap(fn, next2)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware2, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware2.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware2.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
const path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path2);
  let start = 0;
  let end2 = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end2 < 0) {
        seenNonSlash = true;
        end2 = index2 + 1;
      }
    }
    return end2 < 0 ? "" : path2.slice(start, end2);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
          if (extIndex < 0) {
            end2 = index2;
          }
        } else {
          extIndex = -1;
          end2 = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end2) {
    end2 = firstNonSlashEnd;
  } else if (end2 < 0) {
    end2 = path2.length;
  }
  return path2.slice(start, end2);
}
function dirname(path2) {
  assertPath$1(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end2 = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end2 = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
}
function extname(path2) {
  assertPath$1(path2);
  let index2 = path2.length;
  let end2 = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end2 < 0) {
      unmatchedSlash = true;
      end2 = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end2);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath$1(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = proc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const func = proto[property];
    const apply = function() {
      return func.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    const names = Object.getOwnPropertyNames(func);
    for (const p2 of names) {
      const descriptor = Object.getOwnPropertyDescriptor(func, p2);
      if (descriptor)
        Object.defineProperty(apply, p2, descriptor);
    }
    return apply;
  }
);
const own = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$1(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > 👉 **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > 👉 **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key2, value) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key2] = value;
        return this;
      }
      return own.call(this.namespace, key2) && this.namespace[key2] || void 0;
    }
    if (key2) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key2;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > 👉 **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > 👉 **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > 👉 **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > 👉 **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > 👉 **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin2, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin2, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$1(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin2, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin2) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin2, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = extend$1(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin2, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
const emptyPlugins = [];
const emptyRemarkRehypeOptions = { allowDangerousHtml: true };
const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
const deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const allowedElements = options.allowedElements;
  const allowElement = options.allowElement;
  const children = options.children || "";
  const className = options.className;
  const components = options.components;
  const disallowedElements = options.disallowedElements;
  const rehypePlugins = options.rehypePlugins || emptyPlugins;
  const remarkPlugins = options.remarkPlugins || emptyPlugins;
  const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  const skipHtml = options.skipHtml;
  const unwrapDisallowed = options.unwrapDisallowed;
  const urlTransform = options.urlTransform || defaultUrlTransform;
  const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
  const file = new VFile();
  if (typeof children === "string") {
    file.value = children;
  }
  for (const deprecation of deprecations) {
    if (Object.hasOwn(options, deprecation.from)) {
      unreachable(
        "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
      );
    }
  }
  const mdastTree = processor.parse(file);
  let hastTree = processor.runSync(mdastTree, file);
  if (className) {
    hastTree = {
      type: "element",
      tagName: "div",
      properties: { className },
      // Assume no doctypes.
      children: (
        /** @type {Array<ElementContent>} */
        hastTree.type === "root" ? hastTree.children : [hastTree]
      )
    };
  }
  visit$2(hastTree, transform);
  return toJsxRuntime(hastTree, {
    Fragment: jsxRuntimeExports.Fragment,
    components,
    ignoreInvalidStyle: true,
    jsx: jsxRuntimeExports.jsx,
    jsxs: jsxRuntimeExports.jsxs,
    passKeys: true,
    passNode: true
  });
  function transform(node2, index2, parent) {
    if (node2.type === "raw" && parent && typeof index2 === "number") {
      if (skipHtml) {
        parent.children.splice(index2, 1);
      } else {
        parent.children[index2] = { type: "text", value: node2.value };
      }
      return index2;
    }
    if (node2.type === "element") {
      let key2;
      for (key2 in urlAttributes) {
        if (Object.hasOwn(urlAttributes, key2) && Object.hasOwn(node2.properties, key2)) {
          const value = node2.properties[key2];
          const test = urlAttributes[key2];
          if (test === null || test.includes(node2.tagName)) {
            node2.properties[key2] = urlTransform(String(value || ""), key2, node2);
          }
        }
      }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
      if (!remove && allowElement && typeof index2 === "number") {
        remove = !allowElement(node2, index2, parent);
      }
      if (remove && parent && typeof index2 === "number") {
        if (unwrapDisallowed && node2.children) {
          parent.children.splice(index2, 1, ...node2.children);
        } else {
          parent.children.splice(index2, 1);
        }
        return index2;
      }
    }
  }
}
function defaultUrlTransform(value) {
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (
    // If there is no protocol, it’s relative.
    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon))
  ) {
    return value;
  }
  return "";
}
const CodeBlock = ({ language, value }) => {
  const [copied, setCopied] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
    value,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      lib.CopyToClipboard,
      {
        text: value,
        onCopy: () => {
          setCopied(true);
          setTimeout(() => {
            setCopied(false);
          }, 1e3);
        },
        children: copied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            className: "icon icon-tabler icon-tabler-clipboard-check",
            width: "20",
            height: "20",
            viewBox: "0 0 24 24",
            strokeWidth: "1.5",
            stroke: "#2c3e50",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 5h-2a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-12a2 2 0 0 0 -2 -2h-2" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 3m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v0a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 14l2 2l4 -4" })
            ]
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            className: "icon icon-tabler icon-tabler-copy",
            width: "20",
            height: "20",
            viewBox: "0 0 24 24",
            strokeWidth: "1.5",
            stroke: "#2c3e50",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" })
            ]
          }
        )
      }
    )
  ] });
};
const ImageComponent = ({ src, alt, ...props }) => {
  const [imgSrc, setImgSrc] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  const [open, setOpen] = reactExports.useState(false);
  const handleClickOpen = () => {
    setOpen(true);
  };
  const handleClose = () => {
    setOpen(false);
  };
  reactExports.useEffect(() => {
    if (src.startsWith("http")) {
      fetch(src).then((response) => response.blob()).then((blob) => {
        const blobUrl = URL.createObjectURL(blob);
        setImgSrc(blobUrl);
        setLoading(false);
      }).catch((error) => {
        console.log(error);
        setLoading(false);
      });
      return;
    }
    const fileId = parseInt(src, 10);
    fetch(`${new Config().API_URL}/file/download/${fileId}`, {
      responseType: "blob"
    }).then((res) => res.blob()).then((response) => {
      const blobUrl = URL.createObjectURL(new Blob([response]));
      setImgSrc(blobUrl);
      setLoading(false);
    }).catch((error) => {
      console.log(error);
      setLoading(false);
    });
  }, [src]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: imgSrc,
        alt,
        ...props,
        className: "preview-image",
        onClick: handleClickOpen
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dialog$1,
      {
        fullScreen: true,
        open,
        onClose: handleClose,
        "aria-labelledby": "alert-dialog-title",
        "aria-describedby": "alert-dialog-description",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tollbar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton$1,
            {
              edge: "start",
              color: "inherit",
              onClick: handleClose,
              "aria-label": "close",
              children: '"closeicon"'
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: imgSrc, alt, ...props, className: "full-screen-image" })
        ]
      }
    )
  ] });
};
const MarkdownComponent = ({ source }) => {
  if (!source) {
    return null;
  }
  let formattedSource = source.replace(/ +/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Markdown,
    {
      components: {
        code({ node: node2, inline, className, children, ...props }) {
          const match2 = /language-(\w+)/.exec(className || "");
          return !inline && match2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            CodeBlock,
            {
              language: match2[1],
              value: String(children).replace(/\n$/, ""),
              ...props
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className, ...props, children });
        },
        a({ node: node2, children, href, ...props }) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link$1,
            {
              href,
              target: "_blank",
              rel: "noopener noreferrer",
              ...props,
              children
            }
          );
        },
        li({ node: node2, children, ordered, ...props }) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { ...props, children });
        },
        img: ImageComponent
      },
      remarkPlugins: [
        remarkGfm,
        remarkBreaks,
        remarkSlug,
        rehypeAutolinkHeadings,
        plugin
      ],
      children: formattedSource
    }
  ) });
};
const Message = ({
  msg_id,
  msg,
  userInfo = {},
  modelName = "",
  children = null
}) => {
  reactExports.useState(false);
  reactExports.useState(false);
  reactExports.useState(msg.message);
  const actionElements = children != null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Grid$1,
    {
      sx: { padding: "20px 0" },
      msg_id,
      className: `msg-box ${msg.type === "prompt" ? "user" : "ai"}
        `,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Grid$1,
          {
            item: true,
            xs: 1,
            sx: { display: "flex", justifyContent: "end", alignItems: "end" },
            children: msg.type === "prompt" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar$1,
              {
                className: "avatar",
                src: userInfo.avatar ?? "",
                sx: { fontSize: 15 },
                children: userInfo.initial === "" ? "personIcon" : userInfo.initial
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar$1,
              {
                className: "avatar",
                sx: { backgroundColor: "rebeccapurple" },
                children: modelName.charAt(0).toUpperCase()
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { maxWidth: "80%" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography$1,
            {
              sx: {
                fontSize: 12,
                color: "text.secondary",
                marginLeft: "20px",
                marginBottom: "5px"
              },
              children: msg.type === "prompt" ? userInfo.name : modelName
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid$1,
            {
              item: true,
              xs: 12,
              pr: { xs: msg.type === "prompt" ? 2 : 1 },
              pl: { xs: msg.type === "prompt" ? 6 : 2 },
              sx: { display: "flex", flexDirection: "column" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { className: "inner-msg", variant: "messages", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MarkdownComponent, { source: msg.message }) })
            }
          )
        ] }),
        actionElements && /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, md: 1.5, children })
      ]
    }
  );
};
const STYLE = ".container{display:flex;flex-flow:column!important;justify-content:flex-start;align-items:flex-start;width:100%;padding:0;overflow-y:auto}@media screen and (min-width: 600px){.container{max-height:400px}}.container::-webkit-scrollbar{width:6px}.container::-webkit-scrollbar-thumb{background-color:#c1c1c1;border-radius:10px}.container::-webkit-scrollbar-track{background-color:#f1f1f1}.chatContainer{scroll-behavior:smooth;min-height:400px}@media (max-width: 600px){.chatContainer{flex:1}}.msg-box{width:100%;padding:20px;display:flex;word-break:break-word;justify-content:flex-start!important;align-items:flex-end}.msg-box.user{flex-direction:row-reverse;color:#3976ef;align-items:center!important}.msg-box.ai{color:#000000de}.msg-box.ai .inner-msg{background-color:#f5f5f5;padding:20px;border-radius:16px}.inner-msg{width:100%;word-break:break-word}.inner-msg>*:first-child{margin-top:0!important}.inner-msg>*:last-child{margin-bottom:0!important}.inner-msg a,p,span{word-wrap:break-word}.avatar{min-width:40px;min-height:40px;max-width:40px;max-height:40px;font-size:11px!important}.msg-box.ai>.avatar{background-color:#639}.chatbox-input.label-apply label{top:8px}.chatbox-input.sending legend,.chatbox-input.sending label{display:none}.dots-loading{display:inline-block;clip-path:inset(0 1ch 0 0);animation:dots-loading 1s steps(4) infinite;color:#c3c3c3;margin-left:3px}@keyframes dots-loading{to{clip-path:inset(0 -1ch 0 0)}}.form-input{position:relative;width:100%}.form-input input::placeholder{opacity:0}.form-input input{width:100%;height:70px;padding:16.5px 5px 16.5px 14.5px;outline:none;border:1px solid rgba(0,0,0,.4);box-sizing:border-box;border-radius:4px;font-size:16px;font-family:InterYounet;font-weight:400;line-height:23px}.form-input:hover input{border:1px solid rgba(0,0,0,.8)}.form-input label{position:absolute;left:14.5px;top:50%;transform:translateY(-50%);transition:.3s;color:#00000080;font-size:16px;font-family:InterYounet;font-weight:400;line-height:23px}.form-input input:focus+label,.form-input input:not(:placeholder-shown)+label{top:0;font-size:12px;color:#3976ef;background:#fff;padding:7px}.form-input input:focus{border:1.8px solid rgb(57,118,239)}";
const STYLEMARKDOWN = ".preview-image{width:100%;max-width:285px}.full-screen-image{max-width:100vw;max-height:100vh}";
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames() {
      var classes = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg) {
          classes = appendClass(classes, parseValue(arg));
        }
      }
      return classes;
    }
    function parseValue(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (typeof arg !== "object") {
        return "";
      }
      if (Array.isArray(arg)) {
        return classNames.apply(null, arg);
      }
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
        return arg.toString();
      }
      var classes = "";
      for (var key2 in arg) {
        if (hasOwn2.call(arg, key2) && arg[key2]) {
          classes = appendClass(classes, key2);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames$1);
var classnamesExports = classnames$1.exports;
const classnames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const STYLES = ".wrapper{width:30px;height:30px;position:relative}.smallDot,.bigDot,.blue,.purple{position:absolute;border-radius:50%}.firstStage{scale:.6}.firstStage .blue{top:26px;left:20px}.blue{width:9px;height:9px;background:#5678f6}.firstStage .purple{top:25px;left:-5px}.purple{width:12px;height:12px;background:#6c70f7}.smallDot{opacity:1}.secondStage .smallDot,.thirdStage .smallDot{opacity:0}.secondStage .smallDot,.secondStage .blue,.secondStage .purple{left:50%;top:50%;transform:translate(-50%,-50%);width:14px;height:14px}.secondStage .bigDot{left:50%;top:50%;transform:translate(-50%,-50%);width:20px;height:20px}.thirdStage .smallDot{opacity:0;transition:.3s ease-in-out .3s opacity}.thirdStage .purple{left:50%;top:0;width:14px;height:14px;transform:translate(-50%);background:#8469f8}.thirdStage .blue{left:17px;top:16px;width:14px;height:14px;transform:translate(0);background:#4f7bf7}.bigDot{transform:translateY(-50%);top:50%;left:-18px;width:14px;height:14px;background:#8868f9}.bigDot.tick{border:2px solid #4285ff}.secondStage .bigDot{width:48px;height:48px;background:linear-gradient(135deg,#b45afc 15%,#4285ff 50%,#00b2f8 80%)}.thirdStage .bigDot{left:0;top:16px;width:14px;height:14px;transform:translate(0);background:#a160fa}.firstStage .dot1{top:50%;left:-37px}.dot1{width:6px;height:6px;background:#aa5dfb;transform:translateY(-50%)}.firstStage .dot2{top:-3px;left:-25px}.dot2{width:8px;height:8px;background:#9f61fa}.firstStage .dot3{top:-15px;left:-7px}.dot3{width:8px;height:8px;background:#8c68f9}.firstStage .dot4{top:27px;left:-29px}.dot4{width:8px;height:8px;background:#9065f9}.firstStage .dot5{top:50%;left:50%;transform:translate(-50%,-50%)}.dot5{width:10px;height:10px;background:#5478f6}.firstStage .dot6{top:-3px;left:2px}.dot6{width:8px;height:8px;background:#4f7bf7}.firstStage .dot7{top:41px;left:-16px}.dot7{width:6px;height:6px;background:#766ef8}.firstStage .dot8{top:52px;left:-3px}.dot8{width:6px;height:6px;background:#5379f7}.firstStage .dot9{top:41px;left:12px}.dot9{width:6px;height:6px;background:#3a85f8}.firstStage .dot10{top:-15px;left:25px}.dot10{width:8px;height:8px;background:#517af6}.firstStage .dot11{top:-3px;left:40px}.dot11{width:8px;height:8px;background:#0091f9}.firstStage .dot12{transform:translateY(-50%);top:50%;left:29px}.dot12{width:6px;height:6px;background:#268af8}.firstStage .dot13{transform:translateY(-50%);top:50%;left:57px}.dot13{width:6px;height:6px;background:#00a6fb}.firstStage .dot14{top:27px;left:41px}.dot14{width:8px;height:8px;background:#009ffa}.thirdStage .dot1,.thirdStage .dot2,.thirdStage .dot3,.thirdStage .dot4,.thirdStage .dot5{left:50%;top:0;width:14px;height:14px;transform:translate(-50%)}.thirdStage .dot6,.thirdStage .dot7,.thirdStage .dot8,.thirdStage .dot9,.thirdStage .dot10{left:17px;top:16px;width:14px;height:14px;transform:translate(0)}.thirdStage .dot11,.thirdStage .dot12,.thirdStage .dot13,.thirdStage .dot14{left:0;top:16px;width:14px;height:14px;transform:translate(0)}.line1{position:absolute;width:32px;height:2px;background:linear-gradient(90deg,#8c68f9,#517af6);top:-12px;left:-4px}.line2{position:absolute;width:66px;height:2px;background:linear-gradient(90deg,#8c68f9,#0091f9);top:0;left:-21px}.line3{position:absolute;width:96px;height:2px;background:linear-gradient(90deg,#8c68f9,#0091f9);top:14px;left:-36px}.line4{position:absolute;width:71px;height:2px;background:linear-gradient(90deg,#8c68f9,#0091f9);top:30px;left:-27px}.line5{position:absolute;width:30px;height:2px;background:linear-gradient(90deg,#8c68f9,#0091f9);top:43px;left:-14px}.line{opacity:1}.secondStage .line,.thirdStage .line{opacity:0}.line{transition:.3s ease-in-out .3s opacity}.secondStage .line,.thirdStage .line{transition:.1s ease-in-out opacity}.bigDot{transition:.3s ease-in-out all;z-index:10}.smallDot,.blue,.purple{transition:.3s ease-in-out transform,.3s ease-in-out left,.3s ease-in-out top}.thirdStage{animation:rotate 2s linear infinite}.bouncing{animation:bouncing 1s ease-in-out infinite}.tick{animation-duration:.2s;animation-name:tick;animation-fill-mode:forwards;animation-play-state:running}.secondStage .bigDot{transition:.3s ease-in-out all,.3s ease-in-out .4s width,.3s ease-in-out .4s height,.1s ease .4s opacity}.secondStage .smallDot{transition:.3s ease-in-out all,.1s ease .4s opacity}.thirdStage .bigDot,.thirdStage .smallDot,.thirdStage .blue,.thirdStage .purple{transition:.3s ease-in-out .4s transform,.3s ease-in-out .4s left,.3s ease-in-out .4s top,.3s ease-in-out all,.3s ease-in-out height}@keyframes rotate{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes bouncing{0%{width:48px;height:48px}50%{width:52px;height:52px}to{width:48px;height:48px}}@keyframes tick{0%{width:48px;height:48px}50%{width:50px;height:50px}to{width:48px;height:48px}}";
function Logo({ stage, isLoading, textInputText }) {
  const [tick, setTick] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (textInputText.length) {
      setTick(true);
      setTimeout(() => {
        setTick(false);
      }, 100);
    }
  }, [textInputText]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: { __html: STYLES } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classnames(
          "wrapper",
          stage === 1 && "firstStage",
          stage === 2 && !isLoading && "secondStage",
          (stage === 3 || isLoading) && "thirdStage"
        ),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("line", "line1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("line", "line2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("line", "line3") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("line", "line4") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("line", "line5") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot3") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot4") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot5") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot6") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot7") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot8") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot9") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot10") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot11") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot11") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot12") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot13") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("smallDot", "dot14") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("blue", isLoading && "loading") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("purple", isLoading && "loading") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: classnames(
                "bigDot",
                isLoading && "loading",
                tick && "tick"
                // bouncing && !tick && !isLoading && styles.bouncing,
              )
            }
          )
        ]
      }
    )
  ] });
}
const MessageStructureSkeleton = ({ loading = false, modelInfo = {} }) => {
  if (!loading) {
    return;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid$1, { container: true, className: "container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Grid$1,
      {
        container: true,
        sx: {
          padding: { md: "20px 50px 20px 60px", xs: "20px 0" }
        },
        msg_id: 0,
        className: "msg-box user",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid$1,
            {
              item: true,
              xs: 1,
              sx: { display: "flex", justifyContent: "end", alignSelf: "end" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar$1, { className: "avatar" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 10, md: 10, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: { xs: 3, md: 2 }, className: "inner-msg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { animation: "wave", sx: { width: "100%" } }) }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Grid$1,
      {
        container: true,
        sx: {
          padding: { md: "20px 50px 20px 60px", xs: "20px 0" }
        },
        msg_id: 1,
        className: "msg-box ai",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid$1,
            {
              item: true,
              xs: 1,
              sx: {
                display: "flex",
                justifyContent: "end",
                alignSelf: "end",
                marginRight: "10px"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar$1, { className: "avatar", children: modelInfo.modelName })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 10, md: 10, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Typography$1,
            {
              px: { xs: 3, md: 2 },
              className: "inner-msg",
              style: { width: "100%" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { animation: "wave", sx: { width: "100%" } }) })
            }
          ) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Grid$1,
      {
        container: true,
        sx: {
          padding: { md: "20px 50px 20px 60px", xs: "20px 0" }
        },
        msg_id: 2,
        className: "msg-box user",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid$1,
            {
              item: true,
              xs: 1,
              sx: { display: "flex", justifyContent: "end", alignSelf: "end" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar$1, { className: "avatar" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 10, md: 10, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: { xs: 3, md: 2 }, className: "inner-msg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { animation: "wave", sx: { width: "100%" } }) }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Grid$1,
      {
        container: true,
        sx: {
          padding: { md: "20px 50px 20px 60px", xs: "20px 0" }
        },
        msg_id: 3,
        className: "msg-box ai",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grid$1,
            {
              item: true,
              xs: 1,
              sx: {
                display: "flex",
                justifyContent: "end",
                alignSelf: "end",
                marginRight: "10px"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar$1, { className: "avatar", children: modelInfo.modelName })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid$1, { item: true, xs: 10, md: 10, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Typography$1, { px: { xs: 3, md: 2 }, className: "inner-msg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { animation: "wave", sx: { width: "100%" } }) }) })
        ]
      }
    )
  ] });
};
function Chatbox({
  info = {},
  type,
  // 'rabbit' or 'shared'
  sendSignal = { count: 0, msg: "" },
  onTry = () => {
  },
  setIsOpened,
  modelHash
}) {
  const chatContainerRef = reactExports.useRef(null);
  const controllerRef = reactExports.useRef(new AbortController());
  const { isMobileDevice } = useDeviceDetect();
  const [isMsgSending, setMsgLoadState] = reactExports.useState(false);
  const [searchSource, setSearchSource] = reactExports.useState("Thinking...");
  const [isInputFocused, setInputFocused] = reactExports.useState(false);
  const [rabbitChatId, setRabbitChatId] = reactExports.useState(false);
  const questionRef = reactExports.useRef(null);
  const [messages, setMessages] = reactExports.useState([]);
  const [guestId, setGuestId] = reactExports.useState();
  const [model, setModel] = reactExports.useState();
  const [userMessage, setUserMessage] = reactExports.useState("");
  const [aiMessage, setAiMessage] = reactExports.useState("");
  const [chatNotExist, setChatNotExist] = reactExports.useState(false);
  const [dataLoading, setDataLoading] = reactExports.useState(true);
  const [stage, setStage] = reactExports.useState(0);
  const modelName = reactExports.useMemo(() => {
    if (!model)
      return "";
    return model.name;
  }, [model]);
  reactExports.useEffect(() => {
    if (isInputFocused) {
      console.log("54", isInputFocused);
      setStage(2);
    } else {
      console.log("57", isInputFocused);
      setStage(1);
    }
  }, [isInputFocused]);
  let sourcesTimer = null;
  reactExports.useEffect(() => {
    getShareData(modelHash).then((data) => {
      if (data.code >= 400) {
        setDataLoading(false);
        setChatNotExist(true);
        return;
      }
      setMessages(data.messages);
      setModel(data.chat.model);
      setGuestId(data.guest.guest_id);
      setDataLoading(false);
      console.debug("76");
      setStage(1);
    });
  }, []);
  const cleanChunkSources = (initial = "") => {
    clearInterval(sourcesTimer);
    setSearchSource(initial);
  };
  const saveAiResponse = async (msg = "") => {
    let emptyError = false;
    console.log("saveAiResponse", msg);
    emptyError = (msg == null ? void 0 : msg.trim()) == "";
    if (emptyError) {
      return;
    }
    let msgParams = {
      message: encodeData(msg ?? messages),
      type: "response"
    };
    await fetch(new Config().API_URL + "/message", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${getToken("token")}`
      },
      body: JSON.stringify(msgParams)
    }).then((r2) => r2.json()).then((r2) => {
      if (r2) {
        console.log("saveAiResponse");
      }
    }).catch((err) => {
      console.log("err", err);
    });
  };
  const handleAbortRequest = () => {
    abortRequestAction({ userAction: true });
    saveAiResponse();
    setMsgLoadState(false);
  };
  const abortRequestAction = (reason = {}) => {
    var _a, _b, _c;
    if (((_b = (_a = controllerRef == null ? void 0 : controllerRef.current) == null ? void 0 : _a.signal) == null ? void 0 : _b.aborted) !== false) {
      return;
    }
    (_c = controllerRef == null ? void 0 : controllerRef.current) == null ? void 0 : _c.abort(reason);
  };
  const sendMessage = async (e2, newMessage = null) => {
    var _a, _b, _c, _d, _e;
    setInputFocused(true);
    if (e2) {
      e2.preventDefault();
    }
    let question2 = questionRef.current.value, ref = questionRef, emptyError = false, maxWordsAllowed = 0, firstChunkArrived = false, cachedMsg = "";
    emptyError = newMessage ? newMessage.trim() == "" : question2.trim() == "";
    if (emptyError) {
      alert("Message is empty");
      questionRef.current.focus();
      setInputFocused(true);
      return;
    }
    maxWordsAllowed = newMessage ? newMessage.split(" ").length : question2.split(" ").length;
    if (maxWordsAllowed > 1500) {
      alert("The message is exceeded maximum words allowed of 1500");
      questionRef.current.focus();
      setInputFocused(true);
      return;
    }
    const message = newMessage ?? question2;
    let instance = typeof message == "object" ? message : {
      type: "prompt",
      message
    };
    setUserMessage(instance);
    setMsgLoadState(true);
    ref.current.value = "";
    let msgParams = {
      message: encodeData(newMessage ?? question2),
      type: "prompt",
      chatId: ((_b = (_a = getToken("younetChat", "json")) == null ? void 0 : _a.chat) == null ? void 0 : _b.id) || "ugur",
      guestId: (_d = (_c = getToken("younetChat", "json")) == null ? void 0 : _c.guest) == null ? void 0 : _d.guest_id
    };
    cachedMsg = "";
    setTimeout(() => {
      var _a2;
      if (chatContainerRef.current)
        chatContainerRef.current.scrollTop = (_a2 = chatContainerRef == null ? void 0 : chatContainerRef.current) == null ? void 0 : _a2.scrollHeight;
    });
    const errorCallback = (response = { message: [] }) => {
      console.log("errorCallback", response);
      let messages2 = response.message;
      let errMsg = (messages2 == null ? void 0 : messages2.length) > 0 && messages2[0] == "guest.chat.over_limit" ? "You reached a maximum of 5 AI interactions. Register to get more. " : "Something went wrong.. Please, try again later..";
      alert(errMsg);
      cleanChunkSources("Thinking...");
      setMsgLoadState(false);
      setStage(1);
      questionRef.current.focus();
      setInputFocused(true);
    };
    const bufferCallback = (resp) => {
      var _a2, _b2;
      try {
        if (resp.error) {
          if (resp.data != "") {
            cachedMsg += resp.data;
          }
          (_a2 = controllerRef == null ? void 0 : controllerRef.current) == null ? void 0 : _a2.abort();
          saveAiResponse(cachedMsg);
          cleanChunkSources("Thinking...");
          ref.current.focus();
          return;
        }
        console.log("234 bufferCallback", resp);
        setStage(3);
        if (resp.data) {
          let data = resp.data;
          cachedMsg += resp.data;
          if (chatContainerRef.current)
            chatContainerRef.current.scrollTop = (_b2 = chatContainerRef == null ? void 0 : chatContainerRef.current) == null ? void 0 : _b2.scrollHeight;
          setAiMessage((prev2) => {
            return {
              ...prev2 ? prev2 : {
                type: "response"
              },
              message: cachedMsg
            };
          });
          if (!firstChunkArrived && data != "") {
            firstChunkArrived = true;
            cleanChunkSources("Typing...");
          }
          if (!resp.response) {
            return;
          }
        }
        if (resp.response) {
          const { response } = resp;
          ref.current.value = "";
          cleanChunkSources("Thinking...");
          setMsgLoadState(false);
          setRabbitChatId(resp.response.chat_id);
          const message2 = {
            message: response.message,
            type: response.type
          };
          if (response.message && response.type) {
          }
          setAiMessage("");
          setUserMessage("");
          setMessages((prev2) => {
            return [...prev2, instance, message2];
          });
          setStage(2);
          ref.current.disabled = false;
          ref.current.focus();
          return;
        }
      } catch (error) {
        alert(error.message);
        questionRef.current.focus();
        setInputFocused(true);
      }
    };
    controllerRef.current = new AbortController();
    let signal = (_e = controllerRef == null ? void 0 : controllerRef.current) == null ? void 0 : _e.signal;
    setStage(3);
    createStream("/message", bufferCallback, msgParams, signal, errorCallback);
  };
  const [txt, setTxt] = reactExports.useState("");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Box$1,
    {
      sx: {
        position: "relative",
        backgroundColor: "white",
        boxShadow: "0px 0px 10px 0px rgba(0,0,0,0.1)",
        borderRadius: "5px",
        border: "1px solid #e0e0e0",
        height: {
          xs: "100dvh",
          sm: "auto"
        },
        minHeight: {
          xs: "-webkit-fill-available",
          sm: "auto"
        },
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-between"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$1,
          {
            sx: {
              display: {
                xs: "block",
                sm: "none"
              },
              position: "absolute",
              left: "10px",
              top: "10px",
              zIndex: 9999999999
            },
            onClick: () => setIsOpened(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                className: "icon icon-tabler icon-tabler-x",
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                strokeWidth: "1.5",
                stroke: "#000000",
                fill: "none",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M18 6l-12 12" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 6l12 12" })
                ]
              }
            )
          }
        ),
        chatNotExist && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Chat Not Exist" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Box$1,
          {
            sx: {
              overflowY: "auto"
            },
            ref: chatContainerRef,
            className: "container chatContainer",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: { __html: STYLE } }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: { __html: STYLEMARKDOWN } }),
              dataLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(MessageStructureSkeleton, { loading: true }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Message,
                  {
                    msg: {
                      message: "👋 Hi there! How can I help you today?",
                      type: "response"
                    },
                    userInfo: {},
                    modelName
                  }
                ),
                messages.map((msg, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Message,
                  {
                    msg,
                    userInfo: {},
                    modelName
                  },
                  index2
                )),
                userMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { msg: userMessage, userInfo: {}, modelName }),
                aiMessage && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { msg: aiMessage, userInfo: {}, modelName })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$1,
          {
            sx: {
              display: "flex",
              justifyContent: "center",
              padding: "20px 0"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stage, isLoading: dataLoading, textInputText: txt })
          }
        ),
        isMsgSending && searchSource !== "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              paddingBottom: "10px"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dots-loading", children: searchSource })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Box$1,
          {
            sx: {
              width: "100%",
              display: "flex",
              justifyContent: "center",
              padding: "15px 10px"
            },
            children: dataLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { height: "73px" } }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-input", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton$1,
                {
                  sx: {
                    borderRadius: "5px",
                    alignSelf: "flex-end",
                    position: "absolute",
                    right: "5px",
                    top: "50%",
                    transform: "translateY(-50%)"
                  },
                  onClick: (e2) => {
                    if (isMsgSending) {
                      handleAbortRequest();
                    } else {
                      sendMessage(e2);
                    }
                  },
                  children: isMsgSending ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: "MuiSvgIcon-root MuiSvgIcon-fontSizeMedium MuiSvgIcon-root MuiSvgIcon-fontSizeLarge css-p79yt4",
                      "aria-hidden": "true",
                      viewBox: "0 0 24 24",
                      "data-testid": "StopIcon",
                      tabIndex: "-1",
                      fill: "#5f6368",
                      height: "24",
                      width: "24",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6 6h12v12H6z" })
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: "MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-1ly4ijh",
                      focusable: "false",
                      "aria-hidden": "true",
                      viewBox: "0 0 24 24",
                      height: "24",
                      width: "24",
                      "data-testid": "SendIcon",
                      fill: "rgb(57, 118, 239)",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.01 21 23 12 2.01 3 2 10l15 2-15 2z" })
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  disabled: isMsgSending,
                  onInput: (e2) => {
                    setTxt((prev2) => {
                      var _a, _b, _c, _d;
                      if ((prev2 == null ? void 0 : prev2.length) > 0 && ((_b = (_a = e2 == null ? void 0 : e2.target) == null ? void 0 : _a.value) == null ? void 0 : _b.length) == 0) {
                        console.log("424");
                        setStage(1);
                      } else if ((!prev2 || (prev2 == null ? void 0 : prev2.length) == 0) && ((_d = (_c = e2.target) == null ? void 0 : _c.value) == null ? void 0 : _d.length) > 0) {
                        console.log("430");
                        setStage(2);
                      }
                      return e2.target.value;
                    });
                  },
                  label: !isMsgSending ? `Talk to "${modelName}"` : "",
                  focused: isInputFocused.toString(),
                  onFocus: () => {
                    setInputFocused(true);
                  },
                  onBlur: () => setInputFocused(false),
                  variant: "outlined",
                  onKeyDown: (e2) => {
                    if (e2.key == "Enter" && !isMobileDevice) {
                      if (!e2.shiftKey) {
                        sendMessage(e2);
                      }
                    }
                  },
                  placeholder: isMsgSending == false ? `Talk to "${modelName}"` : "",
                  id: "younet-input",
                  ref: questionRef
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "younet-input", children: !isMsgSending && `Talk to "${modelName}"` })
            ] }) })
          }
        )
      ]
    }
  );
}
function App({ modelHash, RIGHT = 24, BOTTOM = 20, HEIGHT = 60, WIDTH = 60 }) {
  const CONFIG = new Config({
    RIGHT,
    BOTTOM,
    HEIGHT,
    WIDTH
  });
  console.log("CONFIG", CONFIG);
  if (!modelHash) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Missing modelHash" });
  }
  const [isOpened, setIsOpened] = reactExports.useState(null);
  const [chatContainerIsOpened, setChatContainerIsOpened] = reactExports.useState(false);
  const containerRef = reactExports.useRef(null);
  const handleClick = () => {
    reactExports.startTransition(() => {
      setIsOpened((prev2) => !prev2);
    });
  };
  const logoRef = reactExports.useRef(null);
  const closeRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (isOpened === null)
      return;
    if (isOpened) {
      setChatContainerIsOpened(true);
    } else if (isOpened === false) {
      setTimeout(() => {
        setChatContainerIsOpened(false);
      }, 500);
    }
    if (!logoRef.current || !closeRef.current)
      return;
    console.log("isOpened", isOpened);
    if (isOpened) {
      closeRef.current.classList.remove("opened");
      logoRef.current.classList.remove("closed");
      logoRef.current.classList.add("opened");
      closeRef.current.classList.add("closed");
    } else if (!isOpened) {
      logoRef.current.classList.remove("opened");
      closeRef.current.classList.remove("closed");
      logoRef.current.classList.add("closed");
      closeRef.current.classList.add("opened");
    }
  }, [isOpened]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: { __html: STYLE$1 } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Box$1,
      {
        sx: {
          position: {
            sm: "absolute",
            xs: "fixed"
          },
          bottom: {
            sm: `${CONFIG.BOTTOM + CONFIG.HEIGHT + 10}px`,
            xs: 0
          },
          right: {
            sm: `${CONFIG.RIGHT}px`,
            xs: 0
          },
          borderRadius: {
            sm: "100%"
          },
          cursor: {
            sm: "pointer",
            xs: "pointer"
          },
          maxWidth: {
            sm: "445px"
          },
          minWidth: {
            sm: "445px"
          },
          width: {
            xs: "100%",
            sm: "445px"
          },
          height: {
            xs: "100dvh",
            sm: "auto"
          },
          minHeight: {
            xs: "400px"
          }
        },
        children: [
          chatContainerIsOpened && /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { display: "flex" }, ref: containerRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Grow$1,
            {
              in: isOpened,
              style: {
                transformOrigin: "bottom right",
                zIndex: 9999
              },
              container: containerRef.current,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Box$1, { sx: { width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Chatbox, { modelHash, setIsOpened }) })
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "animation-ping ",
              style: {
                display: isOpened ? "none" : "block",
                cursor: "pointer",
                position: "fixed",
                bottom: `${CONFIG.BOTTOM}px`,
                right: `${CONFIG.RIGHT}px`,
                height: `${CONFIG.HEIGHT}px`,
                width: `${CONFIG.WIDTH}px`,
                backgroundColor: "#3976ef",
                borderRadius: "100%"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Box$1,
            {
              className: "closeRef logo",
              ref: closeRef,
              style: {
                cursor: "pointer",
                position: "fixed",
                bottom: `${CONFIG.BOTTOM}px`,
                right: `${CONFIG.RIGHT}px`,
                height: `${CONFIG.HEIGHT}px`,
                width: `${CONFIG.WIDTH}px`
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  className: "MuiSvgIcon-root MuiSvgIcon-fontSizeMedium MuiSvgIcon-root MuiSvgIcon-fontSizeLarge css-p79yt4",
                  focusable: "false",
                  "aria-hidden": "true",
                  viewBox: "0 0 24 24",
                  "data-testid": "CloseIcon",
                  tabIndex: "-1",
                  title: "Close",
                  height: 30,
                  width: 30,
                  fill: "white",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" })
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              ref: logoRef,
              className: `logo`,
              style: {
                cursor: "pointer",
                position: "fixed",
                bottom: `${CONFIG.BOTTOM}px`,
                right: `${CONFIG.RIGHT}px`
              },
              height: CONFIG.HEIGHT,
              width: CONFIG.WIDTH,
              onClick: handleClick,
              src: LogoImg
            }
          )
        ]
      }
    )
  ] });
}
if (!document.getElementById("younet-embed-chatbox")) {
  const root2 = document.createElement("div");
  root2.id = "younet-embed-chatbox";
  root2.style.position = "fixed";
  root2.style.bottom = "0px";
  root2.style.right = "0px";
  console.log("import meta url", import.meta.url);
  const u2 = new URL(import.meta.url);
  const lastSlash = u2.href.lastIndexOf("/");
  const href = u2.href.substring(0, lastSlash + 1) + "Inter-Regular.ttf";
  const InterRegularUrl = href;
  const stylefont = document.createElement("style");
  stylefont.innerHTML = `
    @font-face {
      font-family: 'InterYounet';
      src: url('${InterRegularUrl}');
    }
  `;
  document.head.appendChild(stylefont);
  const url = new URL(import.meta.url);
  console.log("mainjsx url", url);
  const modelHash = url.searchParams.get("modelHash");
  const height2 = url.searchParams.get("height");
  const width2 = url.searchParams.get("width");
  const bottom = url.searchParams.get("bottom");
  const right = url.searchParams.get("right");
  const shadow = root2.attachShadow({ mode: "open" });
  document.body.appendChild(root2);
  const cache = createCache({
    key: "css",
    prepend: true,
    container: shadow
  });
  client.createRoot(shadow).render(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(CacheProvider, { value: cache, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CssBaseline, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        App,
        {
          modelHash,
          RIGHT: right,
          BOTTOM: bottom,
          HEIGHT: height2,
          WIDTH: width2
        }
      )
    ] })
  );
}
